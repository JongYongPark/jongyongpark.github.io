


#

Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 **타입**과 **사용 방식**에 따라 결정됩니다.

### 스택(Stack)

- **특징**:
  - 고정된 크기의 데이터를 저장합니다.
  - 함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다.
  - 메모리 할당과 해제가 빠릅니다.

- **저장되는 데이터**:
  - 정수형(`i32`, `u64` 등), 부동소수점형(`f32`, `f64`), 불리언(`bool`), 문자(`char`) 등 **크기가 컴파일 시에 결정되는 기본 타입**.
  - 배열(`[T; N]`), 튜플(`(T1, T2, ...)`) 등 **고정 크기의 컬렉션 타입**.

예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:

```rust
fn main() {
    let x: i32 = 10;
    let y: (f64, char) = (3.14, 'A');
    let arr: [u8; 3] = [1, 2, 3];
}
```


위의 `x`, `y`, `arr` 변수들은 모두 스택에 저장됩니다.

### 힙(Heap)

- **특징**:
  - 크기가 동적으로 결정되는 데이터를 저장합니다.
  - 명시적으로 할당하며, 소유권 시스템을 통해 자동으로 해제됩니다.
  - 메모리 할당과 해제가 스택보다 느립니다.

- **저장되는 데이터**:
  - `String`, `Vec<T>` 등 **크기가 동적인 컬렉션 타입**.
  - `Box<T>`를 통한 **힙 할당된 데이터**.

예를 들어, 다음과 같은 코드는 힙에 데이터를 저장합니다:

```rust
fn main() {
    let s: String = String::from("Hello, Rust!");
    let v: Vec<i32> = vec![1, 2, 3, 4, 5];
    let b: Box<f64> = Box::new(3.14);
}
```


위의 `s`, `v`, `b` 변수들은 힙에 데이터를 저장하고, 스택에는 해당 데이터에 대한 포인터와 메타데이터를 저장합니다.

### 소유권과 메모리 관리

Rust는 **소유권(Ownership)** 시스템을 통해 메모리를 관리합니다. 각 값은 하나의 소유자만 가질 수 있으며, 소유자가 스코프를 벗어나면 메모리가 자동으로 해제됩니다. 이러한 시스템 덕분에 개발자는 명시적으로 메모리를 해제하지 않아도 메모리 누수 없이 안전한 코드를 작성할 수 있습니다.

자세한 내용은 [Comprehensive Rust의 메모리 관리](https://google.github.io/comprehensive-rust/ko/memory-management/approaches.html)에서 확인할 수 있습니다.

### 요약

- **스택**: 고정 크기의 기본 타입과 컬렉션이 저장되며, 빠른 메모리 할당과 해제를 제공합니다.
- **힙**: 크기가 동적인 데이터가 저장되며, 소유권 시스템을 통해 자동으로 메모리가 관리됩니다.

Rust의 이러한 메모리 관리 방식은 성능과 안전성을 동시에 추구하는 데 큰 장점을 제공합니다. 



# 
Rust에서 **힙(heap)**과 **스택(stack)**에 저장되는 자료형을 자세히 구분하여 설명하겠습니다. 자료형의 특성에 따라 메모리 할당 방식이 다르며, 이는 주로 **크기**가 **컴파일 타임에 결정되는지** 아니면 **런타임에 결정되는지**에 따라 달라집니다.

### **스택(Stack)**

스택은 **고정 크기**의 데이터가 저장되는 영역입니다. 이 영역에 저장되는 자료형은 컴파일 시 크기가 결정되어야 하며, 함수가 끝나면 자동으로 메모리가 해제됩니다. 주로 기본 타입과 크기가 고정된 자료형들이 여기에 저장됩니다.

#### **스택에 저장되는 자료형**
1. **정수형 (Integer Types)**
   - 예: `i32`, `u64`, `i64`, `u8`, `i8`, `i16`, `u16`
   - 정수형은 고정된 크기를 가지므로 스택에 저장됩니다.
   ```rust
   let x: i32 = 10;
   ```

2. **부동소수점형 (Floating Point Types)**
   - 예: `f32`, `f64`
   - 부동소수점형 역시 크기가 고정되어 스택에 저장됩니다.
   ```rust
   let y: f64 = 3.14;
   ```

3. **불리언형 (Boolean Type)**
   - `bool` 타입은 `true` 또는 `false` 값을 가지며, 크기가 고정되어 스택에 저장됩니다.
   ```rust
   let is_active: bool = true;
   ```

4. **문자형 (Character Type)**
   - `char` 타입은 하나의 유니코드 문자로 4바이트 크기를 가지며, 스택에 저장됩니다.
   ```rust
   let c: char = 'A';
   ```

5. **고정 크기의 배열 (Fixed-size Arrays)**
   - 예: `[i32; 5]`, `[char; 3]`
   - 배열의 크기가 컴파일 타임에 결정되면 스택에 저장됩니다.
   ```rust
   let arr: [i32; 3] = [1, 2, 3];
   ```

6. **고정 크기의 튜플 (Fixed-size Tuples)**
   - 예: `(i32, f64, bool)`
   - 튜플도 고정 크기의 데이터이므로 스택에 저장됩니다.
   ```rust
   let tup: (i32, f64, bool) = (10, 3.14, true);
   ```

### **힙(Heap)**

힙은 **동적 크기**의 데이터가 저장되는 영역입니다. 런타임에 크기가 결정되는 자료형이 대부분이며, **소유권 시스템**에 따라 메모리가 자동으로 할당 및 해제됩니다. 힙에 저장되는 자료형은 일반적으로 **크기가 변할 수 있거나 런타임에 크기를 알 수 없는** 자료형입니다.

#### **힙에 저장되는 자료형**
1. **`String`**
   - `String`은 길이가 동적으로 변할 수 있는 문자열을 저장합니다. Rust에서 `String`은 힙에 저장됩니다.
   ```rust
   let s: String = String::from("Hello, Rust!");
   ```

2. **`Vec<T>` (벡터)**
   - `Vec<T>`는 크기가 동적으로 변할 수 있는 배열입니다. 힙에 데이터를 저장하며, 벡터의 크기는 런타임에 결정됩니다.
   ```rust
   let v: Vec<i32> = vec![1, 2, 3];
   ```

3. **`Box<T>`**
   - `Box<T>`는 힙에 데이터를 저장하는 스마트 포인터입니다. 값을 힙에 할당하고, 해당 값을 소유합니다.
   ```rust
   let b: Box<i32> = Box::new(10);
   ```

4. **`HashMap<K, V>`**
   - `HashMap`은 키-값 쌍을 저장하는 컬렉션으로, 데이터는 힙에 저장됩니다. `HashMap`의 크기와 내용은 런타임에 결정됩니다.
   ```rust
   use std::collections::HashMap;

   let mut map = HashMap::new();
   map.insert("key1", 10);
   map.insert("key2", 20);
   ```

5. **`Rc<T>` (Reference Counted)**
   - `Rc<T>`는 참조 카운트를 사용하여 힙에서 값을 공유하는 스마트 포인터입니다. 여러 소유자가 값을 공유할 수 있도록 지원합니다.
   ```rust
   use std::rc::Rc;

   let value = Rc::new(10);
   ```

6. **`Arc<T>` (Atomic Reference Counted)**
   - `Arc<T>`는 `Rc<T>`와 비슷하지만, 멀티스레딩 환경에서 안전하게 사용할 수 있는 스마트 포인터입니다.
   ```rust
   use std::sync::Arc;

   let arc_value = Arc::new(20);
   ```

### **스택과 힙 간의 차이점**
- **스택**은 **고정 크기**의 데이터에 적합하고, 빠르게 할당과 해제됩니다. 함수 호출이 끝나면 스택에 저장된 변수들이 자동으로 제거됩니다.
- **힙**은 **동적 크기**의 데이터에 적합하며, 메모리 할당과 해제가 **느리지만**, 런타임에 크기가 결정되는 데이터나 크기가 변할 수 있는 데이터에 유용합니다.

### **스택과 힙의 예시 요약**

| 자료형      | 메모리 위치     | 설명                                               |
|-------------|----------------|----------------------------------------------------|
| `i32`       | 스택           | 고정된 크기의 정수 타입                           |
| `f64`       | 스택           | 고정된 크기의 부동소수점 타입                     |
| `bool`      | 스택           | 고정된 크기의 불리언 타입                         |
| `char`      | 스택           | 고정된 크기의 문자 타입                          |
| `[i32; 3]`  | 스택           | 고정 크기의 배열                                  |
| `(i32, f64)`| 스택           | 고정 크기의 튜플                                  |
| `String`    | 힙             | 동적 크기의 문자열 (힙에 할당)                   |
| `Vec<i32>`  | 힙             | 동적 크기의 벡터 (힙에 할당)                     |
| `Box<i32>`  | 힙             | 힙에 할당된 값                                     |
| `HashMap`   | 힙             | 동적 크기의 키-값 쌍을 저장하는 컬렉션            |
| `Rc<T>`     | 힙             | 참조 카운트가 있는 스마트 포인터                 |
| `Arc<T>`    | 힙             | 멀티스레드 환경에서 안전한 참조 카운트 스마트 포인터 |

### 결론
- **스택**은 고정된 크기의 데이터를 빠르게 처리하고, **힙**은 크기가 동적이거나 런타임에 할당되는 데이터를 처리합니다.
- Rust에서는 **소유권 시스템**을 통해 메모리 관리가 자동으로 이루어지며, 이를 통해 안전하고 효율적인 메모리 관리가 가능합니다.


#

Rust에서 `String`, `str`, 그리고 **string literal**은 메모리 상에서 다르게 취급됩니다. 각자의 메모리 할당 방식과 특성에 대해 자세히 설명드리겠습니다. 또한, 각 자료형들이 어떻게 **참조(Reference)**를 처리하는지도 다루겠습니다.

### 1. **`String`**
- **`String`**은 **힙(heap)**에 동적으로 할당되는 문자열 타입입니다. `String`은 크기가 동적으로 변할 수 있기 때문에, 데이터가 힙에 저장됩니다. `String`은 **소유권**을 가지며, 그 값에 대한 소유권을 이동시키거나 참조할 수 있습니다.
  
#### 특성:
- **동적 크기**: 문자열의 크기가 런타임에 결정되며, 문자열 길이에 따라 메모리가 할당됩니다.
- **소유권**: `String`은 해당 값을 소유하므로, 값이 더 이상 필요하지 않으면 자동으로 메모리가 해제됩니다.

#### 예시:
```rust
fn main() {
    let s: String = String::from("Hello, Rust!");
    println!("{}", s);  // `s`는 소유권을 가짐
}
```

- **참조**: `String`에 대한 참조는 `&String`으로 받을 수 있습니다. 참조는 데이터를 **읽기 전용**으로 다룰 수 있으며, 소유권을 이전하지 않고 접근할 수 있습니다.
  
```rust
fn print_string(s: &String) {
    println!("{}", s); // s는 참조형 변수
}

fn main() {
    let s: String = String::from("Hello, Rust!");
    print_string(&s); // s의 참조를 전달
}
```

### 2. **`str`**
- **`str`**은 **슬라이스(slice)** 타입으로, 문자열의 일부를 참조하는 형태입니다. `str`은 **고정된 크기**가 아니기 때문에, 일반적으로 문자열 리터럴이나 `String`의 일부로 사용됩니다. `str` 자체는 직접적으로 생성되지 않으며, **`&str`** 형태로만 존재합니다.

#### 특성:
- **불변**: `str`은 **불변(immutable)** 데이터입니다.
- **슬라이스**: `str`은 문자열에 대한 슬라이스로, 실제 데이터를 소유하지 않으며 다른 문자열에 대한 참조를 가리킵니다.
- **주로 사용**: 주로 `String`에서 슬라이스를 얻거나, 문자열 리터럴로 사용됩니다.

#### 예시:
```rust
fn main() {
    let hello: &str = "Hello, Rust!";  // 문자열 리터럴은 &str 타입
    println!("{}", hello);  // &str은 참조 타입
}
```

- **참조**: `&str`은 `String`에서 얻은 **불변 참조**이며, `&String`에서 슬라이스를 만들어서 사용하거나 문자열 리터럴 자체로 사용됩니다.

```rust
fn print_str(s: &str) {
    println!("{}", s);  // s는 &str 타입, 문자열의 참조
}

fn main() {
    let s: String = String::from("Hello, Rust!");
    print_str(&s);  // String에서 &str 참조를 가져와서 전달
}
```

### 3. **String Literal**
- **문자열 리터럴**(String literal)은 **`&'static str`** 타입입니다. 이는 Rust에서 코드에 하드코딩된 **불변 문자열**입니다. 문자열 리터럴은 **정적으로** 메모리에 저장되며, 프로그램이 실행되는 동안 변경되지 않습니다. 문자열 리터럴은 주로 `&str` 타입으로 다뤄집니다.

#### 특성:
- **불변**: 문자열 리터럴은 변경할 수 없습니다.
- **정적 메모리**: 컴파일 타임에 메모리에 할당되며, 프로그램이 종료될 때까지 메모리에 유지됩니다.
- **불변 참조**: 문자열 리터럴은 `&'static str` 타입이며, 프로그램 전반에 걸쳐 참조될 수 있습니다.

#### 예시:
```rust
fn main() {
    let greeting: &str = "Hello, world!";  // 문자열 리터럴
    println!("{}", greeting);
}
```

- **참조**: 문자열 리터럴은 이미 메모리에 고정되어 있기 때문에, 기본적으로 `&str` 타입의 참조로 사용됩니다.

---

### **메모리 저장 위치 비교**
| 자료형        | 메모리 위치  | 설명 |
|---------------|--------------|------|
| `String`      | 힙 (Heap)    | 동적으로 크기가 결정되는 문자열. `String`은 힙에 할당됩니다. |
| `&str`        | 스택 (Stack) | 문자열 리터럴이나 `String`의 슬라이스로, 불변 참조로 사용됩니다. |
| 문자열 리터럴 (`"Hello"`) | 데이터 세그먼트 (Text Segment) | 프로그램 실행 시 정적으로 메모리에 저장되며, `'static` 수명이 부여됩니다. |

### **참조 시스템**
- **`&String`**: `String`에 대한 **불변 참조**입니다. 소유권을 이동시키지 않고 데이터를 참조할 수 있습니다.
- **`&str`**: 문자열의 **불변 참조**이며, 일반적으로 `String`에서 얻거나 문자열 리터럴에서 사용됩니다.

#### 예시: `&String` vs `&str`
```rust
fn print_string(s: &String) {
    println!("{}", s);
}

fn print_str(s: &str) {
    println!("{}", s);
}

fn main() {
    let my_string = String::from("Hello, Rust!");
    
    // &String 참조를 전달
    print_string(&my_string);
    
    // &str 참조를 전달
    print_str(&my_string); // String에서 &str 참조를 얻음
    print_str("Hello, world!"); // 문자열 리터럴은 자동으로 &str 타입
}
```

---

### **정리**
- **`String`**: 힙에 저장되고, 크기가 동적으로 변할 수 있는 문자열 타입. 값에 대한 소유권을 가집니다.
- **`str`**: 슬라이스로, 고정된 크기의 불변 문자열을 참조하는 타입. `&str`은 대부분 문자열 리터럴이나 `String`의 슬라이스에서 사용됩니다.
- **문자열 리터럴**: `&'static str` 타입으로, 컴파일 시 메모리에 정적으로 할당된 불변 문자열입니다.

이들을 적절하게 사용하면 메모리 효율성을 높이고, 성능 최적화에 도움이 될 수 있습니다.



#
텍스트로 설명한 내용을 도표와 그림 형식으로 표현할 수 있습니다. 아래는 각 자료형(`String`, `str`, 문자열 리터럴 등)들이 메모리 상에서 어떻게 저장되는지에 대한 구조를 보여주는 간단한 다이어그램입니다.

### **메모리 구조 도표**

```
+-----------------------------------------------------------+
|                프로그램 메모리 (프로세스 메모리)                 |
+-----------------------------------------------------------+
|               데이터 세그먼트 (Text Segment)                  |
|  +--------------------------------------------------------+  |
|  |                문자열 리터럴 "Hello, world!"              |  |
|  |                (정적 메모리)                              |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
|                힙 (Heap)                                      |
|  +--------------------------------------------------------+  |
|  |                        String                            |  |
|  |    "Hello, Rust!" -> (힙에 저장되는 동적 메모리)             |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
|                스택 (Stack)                                   |
|  +--------------------------------------------------------+  |
|  |    &String -> 스택에 저장된 `String`의 참조               |  |
|  |    &str -> "Hello, world!" (문자열 리터럴에 대한 참조)      |  |
|  |    &str -> "Hello, Rust!" (String에서 얻은 슬라이스)       |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
```

### **메모리 구조의 상세 설명**

1. **데이터 세그먼트 (Text Segment)**
   - 프로그램 실행 시 **문자열 리터럴**은 데이터 세그먼트에 **정적으로** 저장됩니다.
   - 예시: `"Hello, world!"`와 같은 문자열 리터럴은 프로그램이 시작될 때 메모리에 할당되어, 실행 중에 변경되지 않는 데이터로 저장됩니다. 이 영역은 **불변**입니다.

2. **힙 (Heap)**
   - **`String`**은 동적으로 메모리 할당을 받습니다. 즉, 프로그램 실행 중에 문자열의 크기가 변할 수 있기 때문에 **힙(Heap)**에 저장됩니다.
   - 예시: `String::from("Hello, Rust!")`로 생성된 문자열은 힙에 저장됩니다. 크기와 내용이 런타임에 결정되므로, 힙에 할당되어 관리됩니다.

3. **스택 (Stack)**
   - **`&String`**과 **`&str`**은 **참조**를 나타냅니다. `&String`은 `String`의 참조이고, `&str`은 **슬라이스**로서 문자열에 대한 불변 참조를 가리킵니다.
   - 예시:
     - `&String`은 스택에 저장된 `String`의 **참조**를 가리킵니다.
     - `"Hello, world!"`는 리터럴이므로 **`&str`**은 스택에 있는 **`&'static str`** 참조입니다.
     - `String`에서 `.as_str()` 메서드를 호출하면 얻은 **`&str`**은 `String`의 힙 메모리 데이터를 참조합니다.

### **다이어그램 상세화**

```plaintext
--------------------------------------------------------
|                프로그램 메모리 (프로세스 메모리)         |
--------------------------------------------------------
| 데이터 세그먼트 (Text Segment)                         |
|------------------------------------------------------|
|   "Hello, world!" ->  메모리 주소: 0x1234             |
|   (문자열 리터럴, 정적으로 할당된 메모리)               |
|------------------------------------------------------|
| 힙 (Heap)                                              |
|------------------------------------------------------|
|   String -> 0x5678 -> "Hello, Rust!" (힙 메모리)       |
|------------------------------------------------------|
| 스택 (Stack)                                           |
|------------------------------------------------------|
|   &String -> 0x5678 (참조, 스택에 위치)                |
|   &str -> "Hello, world!" (문자열 리터럴에 대한 참조)   |
|   &str -> "Hello, Rust!" (String에서 얻은 슬라이스)     |
--------------------------------------------------------
```

### **참고 사항**

- **문자열 리터럴**은 프로그램이 시작될 때 메모리에 고정적으로 배치됩니다. `"Hello, world!"`와 같은 리터럴은 **데이터 세그먼트**에 저장되며, 불변 참조로서 스택에서 사용할 수 있습니다.
- **`String`**은 동적으로 메모리가 할당되며, 해당 값이 힙에 저장됩니다. 크기가 동적으로 변할 수 있기 때문에 런타임에 메모리가 할당되고 해제됩니다.
- **`&String`**과 **`&str`**은 모두 **참조 타입**입니다. 이들은 스택에 저장되며, 각각 `String`과 문자열 리터럴 또는 `String`의 슬라이스를 참조합니다.

---

이 그림은 각 자료형이 어떻게 메모리에서 다루어지는지, 그리고 그들 간의 관계를 직관적으로 이해하는 데 도움이 될 것입니다.

# 

Rust의 **소유권(Ownership)** 시스템은 메모리 안전성을 보장하는 핵심 개념 중 하나입니다. 소유권 시스템은 **힙(Heap)**과 **스택(Stack)**을 어떻게 다루는지에 따라 중요한 특징을 갖습니다. 이 두 메모리 영역에서 **소유권**과 **대상(값)**이 어떻게 이동하거나 참조되는지 설명하겠습니다.

### 1. **스택(Stack)과 힙(Heap)**

- **스택(Stack)**: 데이터를 빠르게 할당하고 해제하는 **LIFO(Last-In-First-Out)** 방식의 메모리 영역입니다. **값의 크기가 고정된 타입**(예: 정수, 부동 소수점, 고정 크기의 배열 등)을 주로 저장합니다.
- **힙(Heap)**: 크기가 동적으로 결정되는 데이터를 저장하는 **비순차적** 메모리 영역입니다. **`Box`, `Vec`, `String`**과 같은 동적 크기의 타입들은 힙에 저장됩니다.

### 2. **소유권 시스템**

Rust에서 소유권 시스템은 **값에 대한 소유권**을 추적하여 **메모리 안전성**을 보장하고, **스택**과 **힙**에 저장되는 값들이 어떻게 관리되는지 결정합니다. 이 시스템은 **스택에 저장된 변수**의 **소유권**이 어떻게 **힙에 저장된 값**에 영향을 미치는지에 대한 규칙을 정의합니다.

#### 기본 규칙:
1. **소유권 이동 (Ownership Transfer)**:
   - 변수는 소유권을 가지며, 그 변수의 소유권이 다른 변수로 이동하면 **이전 변수는 더 이상 유효하지 않**습니다. 
   - 값이 **스택**에 저장되면 **소유권 이동**은 스택에 있는 변수에서 다른 변수로 이동합니다. 하지만 **힙에 저장된 데이터**의 경우, 데이터는 힙에 저장되고 해당 메모리 주소만 스택에 복사됩니다.
   
2. **소유권 복사 (Copy)**:
   - **`Copy` 트레이트**가 구현된 타입들은 **소유권 이동 없이** 데이터를 복사할 수 있습니다. 예를 들어, 정수형 타입(`i32`, `f64`)이나 배열과 같은 크기가 고정된 타입들은 소유권을 이동하지 않고 복사할 수 있습니다. 
   
3. **불변 참조와 가변 참조 (Immutable and Mutable References)**:
   - **불변 참조**(예: `&T`)는 데이터를 읽기 전용으로 참조할 수 있고, **가변 참조**(예: `&mut T`)는 데이터를 수정할 수 있습니다. 
   - **가변 참조**는 한 번에 **하나만 존재할 수 있습니다**. 따라서 하나의 값에 대해 가변 참조와 불변 참조가 동시에 존재할 수 없습니다.

---

### 3. **스택에서의 소유권**

스택에 저장된 값은 **스코프가 끝날 때 자동으로 해제**됩니다. 스택에 있는 변수는 **고정 크기**여서 메모리에서 쉽게 관리할 수 있습니다. 스택에 저장된 값은 **소유권이 함수나 변수 간에 이동**할 때, 해당 변수가 끝날 때 자동으로 메모리에서 제거됩니다.

#### 예시 1: **정수형 타입 (Copy)**
```rust
fn main() {
    let x = 10;  // x는 스택에 저장되고 소유권을 가짐
    let y = x;   // x의 값을 y로 복사(이 경우는 Copy가 가능)
    println!("x: {}, y: {}", x, y);  // x와 y는 각각 독립된 값
}
```
- 이 예제에서 `x`는 정수 `10`을 스택에 저장합니다. `y = x`에서 `x`의 값은 복사됩니다. 따라서 `x`와 `y`는 서로 독립적인 값을 가집니다.

#### 예시 2: **구조체 타입 (Move)**
```rust
struct MyStruct {
    value: i32,
}

fn main() {
    let a = MyStruct { value: 10 };
    let b = a;  // a의 소유권이 b로 이동
    // println!("{}", a.value);  // 오류: a는 더 이상 유효하지 않음
}
```
- 이 예제에서 `a`는 `MyStruct`를 소유합니다. `b = a`에서 `a`의 소유권이 `b`로 이동합니다. `a`는 더 이상 유효하지 않으며, `a`를 참조하려고 하면 오류가 발생합니다.

---

### 4. **힙에서의 소유권**

힙에 저장된 값은 **동적 메모리 할당**을 통해 관리되며, **스택에 저장된 포인터만**이 힙에 저장된 데이터를 가리킵니다. 데이터 자체는 힙에 저장되며, 소유권이 이동하면 힙의 메모리 역시 관리됩니다. 

#### 예시 3: **String (힙 메모리 할당)**
```rust
fn main() {
    let s1 = String::from("Hello");  // String은 힙에 저장
    let s2 = s1;  // s1의 소유권이 s2로 이동
    // println!("{}", s1);  // 오류: s1은 더 이상 유효하지 않음
}
```
- 이 예제에서 `String`은 **힙**에 저장됩니다. `s1`의 소유권이 `s2`로 이동하면, 더 이상 `s1`을 사용할 수 없습니다. **힙에 할당된 메모리**는 `s2`가 끝날 때 자동으로 해제됩니다.

#### 예시 4: **`Vec` (동적 배열)**
```rust
fn main() {
    let v1 = vec![1, 2, 3];  // v1은 힙에 저장된 동적 배열
    let v2 = v1;  // v1의 소유권이 v2로 이동
    // println!("{:?}", v1);  // 오류: v1은 더 이상 유효하지 않음
}
```
- `Vec`은 힙에 저장된 데이터입니다. `v1`의 소유권이 `v2`로 이동하면 `v1`은 더 이상 유효하지 않으며, 힙에 있는 메모리는 `v2`가 끝날 때 자동으로 해제됩니다.

---

### 5. **소유권과 참조의 관계**
- **불변 참조 (`&T`)**: 스택에 **참조를 저장**합니다. 힙에 있는 값을 가리킬 수 있으며, 참조된 값은 **변경할 수 없습니다**.
- **가변 참조 (`&mut T`)**: 하나의 값에 대해 **하나의 가변 참조만** 존재할 수 있습니다. 가변 참조는 값의 소유권을 변경하지 않지만, **값을 변경**할 수 있습니다.

#### 예시 5: **참조를 사용한 예**
```rust
fn main() {
    let s1 = String::from("Hello");
    let s2 = &s1;  // 불변 참조
    println!("{}", s2);  // s2는 s1의 불변 참조
    // s1의 소유권은 여전히 s1에게 있음
}
```
- 이 예제에서 `s2`는 `s1`의 **불변 참조**입니다. `s2`는 `s1`의 값을 변경할 수 없으며, `s1`의 소유권은 여전히 `s1`이 가지고 있습니다.

---

### **정리**

- **스택**에 저장되는 값들은 고정 크기의 타입(예: `i32`, `bool`, `char`)이나 참조 타입이며, 함수나 변수의 스코프를 벗어나면 자동으로 해제됩니다.
- **힙**에 저장되는 값들은 동적 크기(예: `String`, `Vec`, `Box`)를 가지며, 값은 힙에 저장되지만, 그 값을 가리키는 **스택 포인터**가 존재합니다.
- **소유권**은 데이터가 **힙에 있을 때**, 스택에서의 변수 간에 **이동**하는 형태로 다루어지며, **참조**를 통해 값에 접근하거나, 값을 **이동**시킬 수 있습니다.






