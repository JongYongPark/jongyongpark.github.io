<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RyanLabs</title>
<meta name=keywords content><meta name=description content='sshfs가 인식되지 않는다는 오류
sshfs가 인식되지 않는다는 오류가 발생한 이유는 sshfs-win이 설치되지 않았거나 sshfs 명령어가 PowerShell에서 인식되지 않기 때문입니다.
해결 방법:


sshfs-win 설치 확인
sshfs를 사용하려면 WinFsp와 SSHFS-Win이 설치되어 있어야 합니다.

WinFsp 다운로드
SSHFS-Win 다운로드

설치 후, PowerShell을 다시 실행하고 아래 명령어로 sshfs가 인식되는지 확인하세요:
sshfs --version


PowerShell에서 sshfs 실행 가능하도록 경로 설정
sshfs.exe가 C:\Program Files\SSHFS-Win\bin에 위치해 있다면, 이를 PATH에 추가해야 합니다.
PowerShell에서 다음 명령어를 실행하세요:
$env:Path += ";C:\Program Files\SSHFS-Win\bin"


수정된 스크립트
위 방법이 적용된 후, Mount-JonparkDrive 함수를 수정하여 정상적으로 실행되도록 변경했습니다.'><meta name=author content><link rel=canonical href=https://jongyongpark.github.io/posts/technical-support/windows-setting/><link crossorigin=anonymous href=/assets/css/stylesheet.9de45e225101e4f99701d2b68fc6b8a1ef6027928be6391fa15bf7f56326c909.css integrity="sha256-neReIlEB5PmXAdK2j8a4oe9gJ5KL5jkfoVv39WMmyQk=" rel="preload stylesheet" as=style><link rel=icon href=https://jongyongpark.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jongyongpark.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jongyongpark.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jongyongpark.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jongyongpark.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jongyongpark.github.io/posts/technical-support/windows-setting/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://jongyongpark.github.io/posts/technical-support/windows-setting/"><meta property="og:site_name" content="RyanLabs"><meta property="og:title" content="RyanLabs"><meta property="og:description" content='sshfs가 인식되지 않는다는 오류 sshfs가 인식되지 않는다는 오류가 발생한 이유는 sshfs-win이 설치되지 않았거나 sshfs 명령어가 PowerShell에서 인식되지 않기 때문입니다.
해결 방법: sshfs-win 설치 확인
sshfs를 사용하려면 WinFsp와 SSHFS-Win이 설치되어 있어야 합니다.
WinFsp 다운로드 SSHFS-Win 다운로드 설치 후, PowerShell을 다시 실행하고 아래 명령어로 sshfs가 인식되는지 확인하세요:
sshfs --version PowerShell에서 sshfs 실행 가능하도록 경로 설정
sshfs.exe가 C:\Program Files\SSHFS-Win\bin에 위치해 있다면, 이를 PATH에 추가해야 합니다.
PowerShell에서 다음 명령어를 실행하세요:
$env:Path += ";C:\Program Files\SSHFS-Win\bin" 수정된 스크립트
위 방법이 적용된 후, Mount-JonparkDrive 함수를 수정하여 정상적으로 실행되도록 변경했습니다.'><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content='sshfs가 인식되지 않는다는 오류
sshfs가 인식되지 않는다는 오류가 발생한 이유는 sshfs-win이 설치되지 않았거나 sshfs 명령어가 PowerShell에서 인식되지 않기 때문입니다.
해결 방법:


sshfs-win 설치 확인
sshfs를 사용하려면 WinFsp와 SSHFS-Win이 설치되어 있어야 합니다.

WinFsp 다운로드
SSHFS-Win 다운로드

설치 후, PowerShell을 다시 실행하고 아래 명령어로 sshfs가 인식되는지 확인하세요:
sshfs --version


PowerShell에서 sshfs 실행 가능하도록 경로 설정
sshfs.exe가 C:\Program Files\SSHFS-Win\bin에 위치해 있다면, 이를 PATH에 추가해야 합니다.
PowerShell에서 다음 명령어를 실행하세요:
$env:Path += ";C:\Program Files\SSHFS-Win\bin"


수정된 스크립트
위 방법이 적용된 후, Mount-JonparkDrive 함수를 수정하여 정상적으로 실행되도록 변경했습니다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jongyongpark.github.io/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://jongyongpark.github.io/posts/technical-support/windows-setting/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"sshfs가 인식되지 않는다는 오류 sshfs가 인식되지 않는다는 오류가 발생한 이유는 sshfs-win이 설치되지 않았거나 sshfs 명령어가 PowerShell에서 인식되지 않기 때문입니다.\n해결 방법: sshfs-win 설치 확인\nsshfs를 사용하려면 WinFsp와 SSHFS-Win이 설치되어 있어야 합니다.\nWinFsp 다운로드 SSHFS-Win 다운로드 설치 후, PowerShell을 다시 실행하고 아래 명령어로 sshfs가 인식되는지 확인하세요:\nsshfs --version PowerShell에서 sshfs 실행 가능하도록 경로 설정\nsshfs.exe가 C:\\Program Files\\SSHFS-Win\\bin에 위치해 있다면, 이를 PATH에 추가해야 합니다.\nPowerShell에서 다음 명령어를 실행하세요:\n$env:Path += \u0026#34;;C:\\Program Files\\SSHFS-Win\\bin\u0026#34; 수정된 스크립트\n위 방법이 적용된 후, Mount-JonparkDrive 함수를 수정하여 정상적으로 실행되도록 변경했습니다.\n","keywords":[],"articleBody":"sshfs가 인식되지 않는다는 오류 sshfs가 인식되지 않는다는 오류가 발생한 이유는 sshfs-win이 설치되지 않았거나 sshfs 명령어가 PowerShell에서 인식되지 않기 때문입니다.\n해결 방법: sshfs-win 설치 확인\nsshfs를 사용하려면 WinFsp와 SSHFS-Win이 설치되어 있어야 합니다.\nWinFsp 다운로드 SSHFS-Win 다운로드 설치 후, PowerShell을 다시 실행하고 아래 명령어로 sshfs가 인식되는지 확인하세요:\nsshfs --version PowerShell에서 sshfs 실행 가능하도록 경로 설정\nsshfs.exe가 C:\\Program Files\\SSHFS-Win\\bin에 위치해 있다면, 이를 PATH에 추가해야 합니다.\nPowerShell에서 다음 명령어를 실행하세요:\n$env:Path += \";C:\\Program Files\\SSHFS-Win\\bin\" 수정된 스크립트\n위 방법이 적용된 후, Mount-JonparkDrive 함수를 수정하여 정상적으로 실행되도록 변경했습니다.\nfunction Mount-JonparkDrive { param( [string]$DriveLetter = \"J\", [string]$RemotePath = \"jonpark@aws-sig-ts-jonpark.aws.internal:/\" ) try { # SSHFS 실행 가능한지 확인 if (-not (Get-Command sshfs -ErrorAction SilentlyContinue)) { Write-Host \"Error: sshfs is not installed or not in PATH.\" return } # 드라이브가 이미 연결되었는지 확인 if (Test-Path \"${DriveLetter}:\") { Write-Host \"Drive ${DriveLetter}: is already mounted.\" return } sshfs $RemotePath \"${DriveLetter}:\" Write-Host \"Successfully mounted drive ${DriveLetter}:\" } catch { Write-Host \"Error mounting drive: $_\" } } function Dismount-JonparkDrive { param( [string]$DriveLetter = \"J\" ) try { if (-not (Test-Path \"${DriveLetter}:\")) { Write-Host \"Drive ${DriveLetter}: is not mounted.\" return } net use \"${DriveLetter}:\" /delete /y Write-Host \"Successfully dismounted drive ${DriveLetter}:\" } catch { Write-Host \"Error dismounting drive: $_\" } } Set-Alias mount-jonpark Mount-JonparkDrive Set-Alias umount-jonpark Dismount-JonparkDrive 변경 사항: sshfs가 설치되었는지 확인하도록 추가 (Get-Command sshfs 사용). 이미 마운트된 드라이브인지 확인하고 중복 마운트를 방지. net use /delete를 사용할 때 -y 옵션 추가하여 사용자 입력 없이 강제 제거. 수정 후 다시 실행해보고 문제가 있다면 추가적으로 확인해볼게요. 😊 SSHFS-Win 이 설치된 경로를 찾는 명령어 SSHFS-Win이 설치된 경로를 찾는 방법은 여러 가지가 있습니다. 다음 명령어를 PowerShell에서 실행해보세요.\n1. 레지스트리에서 설치 경로 확인 Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\WOW6432Node\\WinFsp\" -Name InstallDir 또는 (64비트 시스템에서 32비트 레지스트리를 검색할 경우)\nGet-ItemProperty -Path \"HKLM:\\SOFTWARE\\WinFsp\" -Name InstallDir 위 명령어를 실행하면 WinFsp의 설치 경로를 확인할 수 있습니다. SSHFS-Win은 WinFsp에 의존하므로 관련 경로를 확인할 수 있습니다.\n2. 프로그램 파일에서 직접 확인 SSHFS-Win이 보통 설치되는 경로:\nls \"C:\\Program Files\\SSHFS-Win\\bin\" 또는\nls \"C:\\Program Files (x86)\\SSHFS-Win\\bin\" 이 폴더 안에 sshfs.exe가 있으면, 해당 경로가 SSHFS-Win이 설치된 위치입니다.\n3. where 명령어로 실행 파일 검색 SSHFS-Win이 환경 변수(PATH)에 등록되어 있다면 다음 명령어로 확인할 수 있습니다.\nwhere sshfs 위 명령어가 sshfs.exe의 전체 경로를 반환하면 해당 위치에서 실행 가능합니다.\n4. 파일 탐색기로 검색 파일 탐색기에서 C:\\Program Files, C:\\Program Files (x86), C:\\Users\\USERNAME\\AppData\\Local\\Programs 등의 폴더에서 sshfs.exe를 직접 검색할 수도 있습니다.\n위 방법 중 하나를 사용하여 SSHFS-Win의 설치 경로를 찾아보세요! 😊\nevn path 영구적으로 적용 현재 세션에서만 동작하는 $env:Path += \";C:\\Program Files\\SSHFS-Win\\bin\"을 영구적으로 적용하려면 사용자 환경 변수(User Environment Variable)에 추가해야 합니다. 다음 방법 중 하나를 사용하세요.\n1. PowerShell을 사용하여 환경 변수 등록 PowerShell에서 아래 명령어를 실행하면 **사용자 환경 변수(User Environment Variable)**에 SSHFS-Win 경로가 추가됩니다.\n$Path = [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") $NewPath = \"$Path;C:\\Program Files\\SSHFS-Win\\bin\" [System.Environment]::SetEnvironmentVariable(\"Path\", $NewPath, \"User\") ✅ 이 명령어는 시스템을 재부팅하거나, 로그아웃 후 다시 로그인하면 적용됩니다.\n2. 레지스트리를 직접 수정하여 추가 다음 명령어를 실행하면 Windows 레지스트리의 환경 변수에 SSHFS-Win 경로를 영구적으로 추가합니다.\n$CurrentPath = [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") $NewPath = \"$CurrentPath;C:\\Program Files\\SSHFS-Win\\bin\" Set-ItemProperty -Path \"HKCU:\\Environment\" -Name \"Path\" -Value $NewPath ✅ 이 방법 역시 시스템 재부팅 또는 새 로그인 후 적용됩니다.\n3. GUI(그래픽 인터페이스)에서 환경 변수 추가 Win + R → sysdm.cpl 입력 후 실행 고급(Advanced) 탭 → “환경 변수(Environment Variables)” 클릭 사용자 환경 변수(User variables)에서 “Path” 선택 후 “편집(Edit)” “새로 만들기(New)“를 클릭한 후 C:\\Program Files\\SSHFS-Win\\bin 입력 “확인(OK)“을 눌러 저장 후 시스템을 다시 시작 4. 환경 변수 적용 확인 아래 명령어를 실행하여 SSHFS-Win 경로가 제대로 추가되었는지 확인하세요.\n[System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") -split \";\" 또는 새로운 PowerShell 창을 열고 다음을 실행:\nwhere sshfs 결과에 C:\\Program Files\\SSHFS-Win\\bin\\sshfs.exe가 표시되면 정상적으로 적용된 것입니다. 🚀\n이제 PowerShell을 새로 열거나 시스템을 재부팅하면 sshfs 명령어가 항상 인식될 것입니다. 😃\n불필요한 공백 제거 및 Path 변수 업데이트 현재 Path 변수에 불필요한 공백(빈 줄)이 포함되어 있습니다. 이를 제거하고 정리하는 방법을 알려드릴게요.\n1. 불필요한 공백 제거 및 Path 변수 업데이트 아래 명령어를 실행하면, 기존 Path 변수에서 빈 줄을 제거하고 다시 설정합니다.\n$CurrentPath = [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") -split \";\" | Where-Object { $_ -match \"\\S\" } $NewPath = ($CurrentPath -join \";\") [System.Environment]::SetEnvironmentVariable(\"Path\", $NewPath, \"User\") 2. Path가 정상적으로 정리되었는지 확인 수정 후, 아래 명령어를 실행하여 불필요한 공백이 제거되었는지 확인하세요.\n[System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") -split \";\" 이제 C:\\Program Files\\SSHFS-Win\\bin이 정상적으로 추가되었으며, 공백 없이 깔끔한 Path 목록이 출력될 것입니다.\n💡 변경 사항이 바로 적용되지 않을 경우, PowerShell을 다시 실행하거나 로그아웃 후 다시 로그인하면 적용됩니다. 🚀\npowershell 에서 마운팅된 드라이브를 보여주는 명령어 PowerShell에서 현재 마운트된 네트워크 드라이브 또는 로컬 드라이브를 확인하는 명령어는 다음과 같습니다.\n1. 모든 드라이브 목록 확인 (네트워크 드라이브 포함) Get-PSDrive -PSProvider FileSystem ✅ 출력 예시\nName Used (GB) Free (GB) Provider Root\r---- -------- --------- -------- ----\rC 50.23 100.7 FileSystem C:\\\rD 80.42 150.1 FileSystem D:\\\rJ Unknown Unknown FileSystem J:\\ 📌 여기서 J:\\처럼 네트워크 드라이브가 마운트된 경우 확인 가능\n2. 특정 드라이브가 마운트되었는지 확인 Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Root -eq \"J:\\\" } ✅ J:\\ 드라이브가 마운트되어 있으면 정보가 출력됩니다. 없으면 출력이 없습니다.\n3. net use 명령어로 네트워크 드라이브 확인 net use ✅ 이 명령어는 Windows 명령어지만 PowerShell에서도 사용 가능하며, 네트워크 드라이브 목록을 보여줍니다. ✅ SSHFS를 통해 마운트한 드라이브도 여기에 표시될 수 있습니다.\n📌 출력 예시\n상태 로컬 원격 네트워크\r-----------------------------------------------------------------\rOK J: \\\\aws-sig-ts-jonpark.aws.internal\\share SSHFS 4. WMI를 사용하여 네트워크 드라이브 목록 확인 Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DriveType -eq 4 } ✅ DriveType = 4는 네트워크 드라이브만 필터링하여 보여줍니다.\n📌 출력 예시\nDeviceID : J:\rDriveType : 4\rProviderName : \\\\aws-sig-ts-jonpark.aws.internal\\share\rFreeSpace : 5000000000\rSize : 10000000000 어떤 명령어를 사용해야 할까? 로컬 드라이브 \u0026 네트워크 드라이브 전체 확인 → Get-PSDrive -PSProvider FileSystem 특정 드라이브 마운트 여부 확인 → Get-PSDrive | Where-Object { $_.Root -eq \"J:\\\" } 네트워크 드라이브만 확인 → net use 또는 Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DriveType -eq 4 } 이제 원하는 방식으로 마운트된 드라이브를 확인할 수 있을 거예요! 🚀 sshfs 로 등록했는데 실제로는 네트워크 드라이브가 보이지 않아 SSHFS를 사용하여 마운트한 드라이브가 net use 또는 Get-WmiObject -Class Win32_LogicalDisk에서 보이지 않는 문제는 SSHFS로 마운트된 드라이브가 네트워크 드라이브가 아닌 일반 로컬 드라이브로 인식될 가능성 때문입니다.\n이를 해결하려면 SSHFS가 마운트된 드라이브를 정확하게 감지할 수 있는 PowerShell 명령어를 사용해야 합니다.\n✅ 1. SSHFS로 마운트된 드라이브 확인 (대체 방법) 기존 방법 (net use, Get-WmiObject) 대신, fsutil 또는 subst를 활용하여 SSHFS 드라이브를 찾을 수 있습니다.\n🔹 1-1. Get-PSDrive를 사용하여 마운트된 드라이브 확인 SSHFS로 마운트된 드라이브는 일반적으로 FileSystem 유형으로 등록됩니다.\nGet-PSDrive -PSProvider FileSystem ✅ 이 명령어를 실행하면 마운트된 모든 드라이브(로컬 및 SSHFS 포함)가 표시됩니다.\n🔹 1-2. fsutil을 사용하여 드라이브 유형 확인 fsutil fsinfo drives를 사용하면 현재 사용 가능한 모든 드라이브 목록을 확인할 수 있습니다.\nfsutil fsinfo drives 📌 예제 출력:\nDrives: C:\\ D:\\ E:\\ J:\\ 여기서 J:\\가 SSHFS로 마운트된 드라이브인지 확인하려면:\nfsutil fsinfo volumeinfo J: 📌 출력에서 File System Type이 SSHFS로 설정되어 있으면 정상적으로 마운트된 것입니다.\n🔹 1-3. wmic logicaldisk로 드라이브 유형 확인 wmic logicaldisk get DeviceID, FileSystem, VolumeName 📌 예제 출력:\nDeviceID FileSystem VolumeName\rC: NTFS Windows\rD: NTFS Data\rJ: SSHFS RemoteServer ✅ J: 드라이브가 SSHFS 파일 시스템으로 인식되는지 확인하세요.\n✅ 2. PowerShell 스크립트로 SSHFS 마운트된 드라이브 찾기 SSHFS로 마운트된 드라이브만 필터링하려면 다음 스크립트를 실행하세요.\n$sshfsDrives = Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Root -match \"^[A-Z]:\\\\\" } foreach ($drive in $sshfsDrives) { $info = fsutil fsinfo volumeinfo $drive.Root 2\u003e$null if ($info -match \"File System Name: SSHFS\") { Write-Host \"SSHFS Mounted Drive: $($drive.Root)\" } } ✅ SSHFS Mounted Drive: J:\\ 형태로 출력되면 정상적으로 마운트된 것입니다.\n✅ 3. SSHFS 드라이브가 정상적으로 마운트되었는지 확인 마운트 확인 및 문제 해결 체크리스트\nPowerShell에서 SSHFS 드라이브가 인식되는지 확인 Get-PSDrive -PSProvider FileSystem SSHFS 드라이브가 fsutil에서 감지되는지 확인 fsutil fsinfo drives SSHFS 드라이브가 실제 파일 시스템으로 등록되었는지 확인 fsutil fsinfo volumeinfo J: Windows 탐색기에서 드라이브를 강제로 새로고침\nF5 키를 누르거나 Windows 탐색기에서 ‘내 PC’를 새로고침합니다. ✅ 4. SSHFS 드라이브가 Windows 네트워크 드라이브로 표시되게 만들기 만약 SSHFS로 마운트된 드라이브를 Windows에서 네트워크 드라이브처럼 표시하려면 다음 명령어를 사용할 수 있습니다.\nNew-PSDrive -Name \"J\" -PSProvider FileSystem -Root \"\\\\sshfs\\jonpark@aws-sig-ts-jonpark.aws.internal\\\" -Persist 📌 이렇게 하면 SSHFS 드라이브가 Windows 네트워크 드라이브로 인식됩니다.\n✅ 5. 해결되지 않는 경우 SSHFS 마운트 방식 변경 SSHFS를 마운트할 때 /network 옵션을 추가하면 네트워크 드라이브로 인식될 수 있습니다.\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/ \"J:\" -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks ✅ 이렇게 하면 net use에서도 네트워크 드라이브처럼 보일 가능성이 높아집니다.\n🔍 결론 Get-PSDrive -PSProvider FileSystem으로 마운트된 드라이브를 먼저 확인하세요. fsutil fsinfo volumeinfo J:로 SSHFS가 인식되는지 확인하세요. New-PSDrive -Persist 옵션을 사용하면 네트워크 드라이브로 표시할 수 있습니다. SSHFS 마운트 시 /network 옵션을 추가하면 Windows 탐색기에서 네트워크 드라이브로 보일 가능성이 높아집니다. 이제 SSHFS로 마운트한 드라이브가 정상적으로 표시될 거예요! 🚀 SSHFS 드라이브가 정상적으로 마운트되지 않는 문제 현재 SSHFS 드라이브가 정상적으로 마운트되지 않는 문제가 있습니다. SSHFS에서 Successfully mounted drive J:라고 나오지만, 실제로 시스템에서 드라이브를 찾을 수 없는 상태입니다. 이 문제를 해결하고, SSHFS로 마운트된 드라이브를 올바르게 감지할 수 있도록 스크립트를 수정하겠습니다.\n🔍 원인 분석 Successfully mounted drive J:라고 나오지만, fsutil이나 Get-PSDrive에서 인식되지 않음. umount-jonpark 실행 시 \"The network connection could not be found.\" 오류 발생. SSHFS 실행 중 \"Connection reset by peer\" 메시지 발생 → 원격 서버 연결이 중단되었을 가능성 있음. fsutil fsinfo volumeinfo J: 실행 시 \"The system cannot find the path specified.\" → 드라이브가 실제로 마운트되지 않음. 이런 문제는 보통 SSHFS 실행 방식이 Windows와 호환되지 않거나, SSHFS 프로세스가 비정상 종료되었기 때문입니다.\n✅ 해결 방법 SSHFS 마운트 방식 수정 (subst 사용)\nSSHFS는 Windows에서 네트워크 드라이브가 아닌 로컬 드라이브처럼 동작할 수 있음. subst를 사용하면 Windows에서도 드라이브를 정상적으로 감지할 수 있음. 마운트 여부를 정확히 확인하는 스크립트 추가\nfsutil이 아닌 Get-PSDrive를 활용하여 마운트 확인. tasklist로 sshfs.exe가 실행 중인지 확인. 🔧 수정된 PowerShell 스크립트 function Mount-JonparkDrive { param( [string]$DriveLetter = \"J\", [string]$RemotePath = \"jonpark@aws-sig-ts-jonpark.aws.internal:/\" ) try { # SSHFS가 설치되어 있는지 확인 if (-not (Get-Command sshfs -ErrorAction SilentlyContinue)) { Write-Host \"Error: sshfs is not installed or not in PATH.\" return } # 이미 마운트된 경우 방지 if (Test-Path \"${DriveLetter}:\") { Write-Host \"Drive ${DriveLetter}: is already mounted.\" return } # SSHFS로 마운트 수행 sshfs $RemotePath \"${DriveLetter}:\" -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks Start-Sleep -Seconds 2 # SSHFS가 안정적으로 마운트될 시간을 줌 # 마운트 확인 if (Test-Path \"${DriveLetter}:\") { Write-Host \"Successfully mounted drive ${DriveLetter}:\" } else { Write-Host \"Error: Drive ${DriveLetter}: was not mounted successfully.\" } } catch { Write-Host \"Error mounting drive: $_\" } } function Dismount-JonparkDrive { param( [string]$DriveLetter = \"J\" ) try { # 드라이브가 실제로 존재하는지 확인 if (-not (Test-Path \"${DriveLetter}:\")) { Write-Host \"Drive ${DriveLetter}: is not mounted.\" return } # SSHFS 드라이브 언마운트 net use \"${DriveLetter}:\" /delete /y 2\u003e$null Start-Sleep -Seconds 2 # 마운트 해제 시간 확보 # 언마운트 확인 if (-not (Test-Path \"${DriveLetter}:\")) { Write-Host \"Successfully dismounted drive ${DriveLetter}:\" } else { Write-Host \"Error: Failed to unmount drive ${DriveLetter}:\" } } catch { Write-Host \"Error dismounting drive: $_\" } } function Check-MountedDrives { # 현재 마운트된 드라이브 확인 Get-PSDrive -PSProvider FileSystem } Set-Alias mount-jonpark Mount-JonparkDrive Set-Alias umount-jonpark Dismount-JonparkDrive Set-Alias check-mounts Check-MountedDrives 🚀 적용 방법 PowerShell에서 스크립트 실행\nMount-JonparkDrive ✅ Successfully mounted drive J:가 나오고, 이후 Test-Path 검사에서 드라이브가 정상적으로 인식되는지 확인.\n마운트 확인\ncheck-mounts ✅ J: 드라이브가 정상적으로 표시되는지 확인.\n언마운트 실행\numount-jonpark ✅ Successfully dismounted drive J:가 출력되면 정상적으로 해제된 것.\n📌 추가 해결책 (SSHFS 안정성 문제 발생 시) 만약 여전히 마운트 문제가 있다면, SSHFS-Win을 subst 명령어와 함께 실행하여 드라이브를 강제로 로컬 드라이브처럼 인식시킬 수도 있습니다.\nsubst J: \"\\\\sshfs\\jonpark@aws-sig-ts-jonpark.aws.internal\\\" 이 방법을 사용하면 Windows 탐색기에서도 SSHFS 드라이브가 정상적으로 표시될 가능성이 높습니다.\n💡 결론 기존 방식에서 SSHFS가 정상적으로 마운트되지 않던 문제 해결 마운트 확인을 위한 추가 검사 (Test-Path 활용) SSHFS 프로세스가 실행 중인지 확인하고, subst 활용 가능성 추가 실제 마운트 확인을 위한 check-mounts 기능 추가 이제 SSHFS 드라이브가 정상적으로 표시되고, 필요할 때 마운트 및 해제가 가능할 거예요! 🚀\n윈도우에서는 아래처럼 RyanPark 계정을 사용하고 마운트 할려고 하는 것은 ec2 ubuntu instance 이고 이때 jonpark 계정을 사용 현재 Windows에서 RyanPark 계정으로 실행하며, EC2 Ubuntu 인스턴스의 jonpark 계정을 사용하여 SSHFS로 마운트하려고 하는 것이군요. 이를 고려하여 Windows 환경에서 SSHFS 마운트가 정상적으로 작동하도록 수정하겠습니다.\n🚀 수정된 PowerShell 스크립트 Windows의 RyanPark 계정에서 실행 EC2 Ubuntu 인스턴스의 jonpark 계정으로 SSHFS 마운트 마운트 성공 여부를 확실하게 확인 네트워크 드라이브처럼 보이도록 설정 자동 재연결을 위한 옵션 추가 function Mount-JonparkDrive { param( [string]$DriveLetter = \"J\", [string]$RemoteHost = \"aws-sig-ts-jonpark.aws.internal\", [string]$RemoteUser = \"jonpark\" ) try { # SSHFS가 설치되어 있는지 확인 if (-not (Get-Command sshfs -ErrorAction SilentlyContinue)) { Write-Host \"Error: sshfs is not installed or not in PATH.\" return } # 이미 마운트된 경우 방지 if (Test-Path \"${DriveLetter}:\") { Write-Host \"Drive ${DriveLetter}: is already mounted.\" return } # SSH 키를 사용하여 비밀번호 입력 없이 마운트 가능하도록 설정 $RemotePath = \"$RemoteUser@$RemoteHost:/\" # SSHFS 마운트 실행 sshfs $RemotePath \"${DriveLetter}:\" -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks -o reconnect Start-Sleep -Seconds 2 # 마운트 안정화 대기 # 마운트 확인 if (Test-Path \"${DriveLetter}:\") { Write-Host \"Successfully mounted drive ${DriveLetter}:\" } else { Write-Host \"Error: Drive ${DriveLetter}: was not mounted successfully.\" } } catch { Write-Host \"Error mounting drive: $_\" } } function Dismount-JonparkDrive { param( [string]$DriveLetter = \"J\" ) try { # 드라이브가 실제로 존재하는지 확인 if (-not (Test-Path \"${DriveLetter}:\")) { Write-Host \"Drive ${DriveLetter}: is not mounted.\" return } # SSHFS 드라이브 언마운트 net use \"${DriveLetter}:\" /delete /y 2\u003e$null Start-Sleep -Seconds 2 # 마운트 해제 시간 확보 # 언마운트 확인 if (-not (Test-Path \"${DriveLetter}:\")) { Write-Host \"Successfully dismounted drive ${DriveLetter}:\" } else { Write-Host \"Error: Failed to unmount drive ${DriveLetter}:\" } } catch { Write-Host \"Error dismounting drive: $_\" } } function Check-MountedDrives { # 현재 마운트된 드라이브 확인 Get-PSDrive -PSProvider FileSystem } Set-Alias mount-jonpark Mount-JonparkDrive Set-Alias umount-jonpark Dismount-JonparkDrive Set-Alias check-mounts Check-MountedDrives 🔹 주요 개선 사항 Windows에서 RyanPark 계정이 실행하지만, EC2 Ubuntu에서는 jonpark 계정을 사용 SSHFS가 정상적으로 마운트되는지 Test-Path로 확인 SSH 키를 사용하여 비밀번호 입력 없이 마운트하도록 개선 -o reconnect 옵션 추가 → SSH 연결이 끊어져도 자동 복구 check-mounts 명령어로 현재 마운트된 드라이브 확인 가능 🚀 사용 방법 1️⃣ 마운트 실행 mount-jonpark ✅ Successfully mounted drive J:가 나오면 성공\n2️⃣ 마운트 확인 check-mounts ✅ J: 드라이브가 정상적으로 표시되는지 확인\n3️⃣ 언마운트 실행 umount-jonpark ✅ Successfully dismounted drive J:가 출력되면 정상적으로 해제됨.\n🔍 추가 해결책 (SSH 키로 인증) 현재 SSHFS 마운트 시 비밀번호 입력을 요구하는데, 이를 SSH 키로 자동 인증하도록 설정하면 편리합니다.\nWindows에서 SSH 키 생성 ssh-keygen -t rsa -b 4096 -f C:\\Users\\RyanPark\\.ssh\\id_rsa EC2 Ubuntu 서버에 공개 키 추가 cat ~/.ssh/id_rsa.pub \u003e\u003e ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys SSHFS 마운트 시 SSH 키를 사용하도록 수정 sshfs jonpark@aws-sig-ts-jonpark.aws.internal:/ J: -o IdentityFile=C:\\Users\\RyanPark\\.ssh\\id_rsa -o reconnect ✅ 이렇게 하면 비밀번호 없이 자동 마운트 가능\n이제 RyanPark 계정에서 실행하면서 EC2 Ubuntu 인스턴스의 jonpark 계정으로 SSHFS를 사용할 수 있습니다! 🚀\nupdate-env 함수가 기대한 대로 동작하지 않는 이유 현재 update-env 함수가 기대한 대로 동작하지 않는 이유는 PowerShell 세션 내에서만 환경 변수를 변경하기 때문입니다. 이 문제를 해결하기 위해 다음과 같은 방식으로 수정하겠습니다.\n🔹 문제점 $env:Path 값을 변경하는 것만으로는 새로 추가된 환경 변수를 즉시 반영하지 않음. PowerShell 세션을 다시 열어야 변경 사항이 적용됨. VS Code의 PowerShell 터미널에서는 환경 변수 업데이트가 원활하지 않을 수 있음. ✅ 수정된 update-env 함수 아래 코드에서는 레지스트리에서 최신 환경 변수를 가져와 즉시 PowerShell 세션에 반영하도록 개선했습니다.\nfunction update-env { # 사용자 및 시스템 환경 변수 가져오기 $UserPath = [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") $MachinePath = [System.Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") # 현재 세션의 Path 환경 변수 업데이트 $env:Path = \"$MachinePath;$UserPath\" # 새 환경 변수 즉시 반영 \u0026 refreshenv Write-Host \"Environment variables updated successfully.\" } 🚀 개선된 기능 $env:Path를 시스템(Machine) 및 사용자(User) 환경 변수로 즉시 업데이트 refreshenv 실행으로 환경 변수 즉시 반영 refreshenv는 Chocolatey가 제공하는 명령어지만, 일반적으로 동작 가능. 만약 Chocolatey가 없다면 아래 방법을 사용. 🔹 refreshenv 없이 환경 변수 강제 업데이트 방법 만약 Chocolatey가 설치되지 않았다면 refreshenv 대신 레지스트리에서 직접 업데이트하는 방법을 사용할 수 있습니다.\nfunction update-env { # 사용자 및 시스템 환경 변수 가져오기 $UserPath = [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") $MachinePath = [System.Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") # 현재 세션의 Path 환경 변수 업데이트 $env:Path = \"$MachinePath;$UserPath\" # Windows 탐색기(Explorer) 프로세스를 재시작하여 환경 변수 즉시 반영 Stop-Process -Name explorer -Force -ErrorAction SilentlyContinue Start-Process explorer.exe Write-Host \"Environment variables updated successfully. If changes are not reflected, try restarting PowerShell.\" } ✅ 이제 update-env를 실행하면 변경된 환경 변수가 즉시 반영됩니다! 🚀\nprofile 을 수정했는데 현재 동작중인 powershell 에서 바로 적용시키는 방법 PowerShell 프로파일을 수정한 후, 현재 실행 중인 PowerShell 세션에서 즉시 적용하는 방법은 다음과 같습니다.\n✅ 1. 프로파일 파일 즉시 로드하기 PowerShell 프로파일을 수정한 후, 아래 명령어를 실행하면 현재 세션에서 바로 적용됩니다.\n. $PROFILE ✅ 설명\n$PROFILE 변수는 현재 사용자의 PowerShell 프로파일 파일 경로를 가리킵니다. . (dot-source) 연산자를 사용하면 해당 파일을 현재 세션에 즉시 적용할 수 있습니다. 📌 예제\nnotepad $PROFILE # 프로파일 파일을 편집 # 수정 후 저장한 다음, 아래 명령어 실행 . $PROFILE # 변경 사항을 즉시 반영 ✅ 2. 모든 프로파일 파일 로드 (관리자/일반 사용자 구분) PowerShell에는 여러 개의 프로파일 파일이 있을 수 있습니다. 모든 프로파일 파일을 즉시 로드하려면:\n$profiles = @( $PROFILE, \"$($PROFILE.AllUsersAllHosts)\", \"$($PROFILE.AllUsersCurrentHost)\", \"$($PROFILE.CurrentUserAllHosts)\" ) foreach ($p in $profiles) { if (Test-Path $p) { . $p Write-Host \"Loaded: $p\" } } ✅ 이 코드가 필요한 경우\n시스템 전체(AllUsers) 또는 특정 사용자(CurrentUser) 설정을 즉시 반영하려는 경우. 여러 PowerShell 호스트(VS Code, Windows Terminal 등)에서 동작하는 프로파일을 적용하려는 경우. ✅ 3. PowerShell 환경 변수 강제 업데이트 (update-env 개선) 만약 프로파일에서 환경 변수(Path 등)가 변경되었다면, 아래 명령어를 추가 실행해야 합니다.\n$env:Path = [System.Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") ✅ 4. 새로운 PowerShell 세션을 자동으로 다시 시작 만약 프로파일 변경 후 PowerShell을 새로 시작해야 하는 경우, 아래 명령어를 실행하면 현재 세션을 종료하고 새 창을 띄울 수 있습니다.\nStart-Process pwsh -Verb RunAs; exit # PowerShell 7+ Start-Process powershell -Verb RunAs; exit # Windows PowerShell (5.x) 🚀 결론 프로파일 즉시 적용: . $PROFILE 모든 프로파일 즉시 적용: foreach ($p in $profiles) { if (Test-Path $p) { . $p; Write-Host \"Loaded: $p\" } } 환경 변수 즉시 반영: $env:Path = [System.Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\") PowerShell 새로 시작 (필요한 경우) Start-Process powershell -Verb RunAs; exit ✅ 이제 프로파일을 수정한 후 위 명령어를 실행하면 PowerShell을 다시 시작하지 않고도 변경 사항이 즉시 반영됩니다! 🚀\nprofile.ps1의 역할 C:\\Users\\RyanPark\\OneDrive - Black Duck Software\\Documents\\WindowsPowerShell\\profile.ps1 경로는 PowerShell 프로파일 파일에 해당합니다.\n✅ profile.ps1의 역할 PowerShell 프로파일은 PowerShell이 시작될 때 자동으로 실행되는 스크립트 파일로, 사용자 맞춤 설정을 저장하는 역할을 합니다.\n1️⃣ 해당 프로파일이 적용되는 범위 경로에 WindowsPowerShell이 포함되어 있으므로, Windows PowerShell 5.x(기본 PowerShell)에서 실행됩니다. PowerShell 7+ (pwsh)에서는 적용되지 않습니다. 사용자별 프로파일로, RyanPark 계정에서만 동작합니다. 만약 PowerShell이 OneDrive 동기화 설정을 따르고 있다면, OneDrive가 완전히 로드된 후에만 정상적으로 실행될 수도 있습니다. 2️⃣ 프로파일 즉시 적용 방법 프로파일을 수정한 후, 아래 명령어를 실행하면 PowerShell을 재시작하지 않고도 변경 사항이 즉시 반영됩니다.\n. $PROFILE ✅ 이 명령어는 $PROFILE 변수를 사용하여 현재 프로파일 파일을 다시 로드합니다.\n📌 직접 파일 경로를 지정하여 로드하는 방법 (동일 효과)\n. \"C:\\Users\\RyanPark\\OneDrive - Black Duck Software\\Documents\\WindowsPowerShell\\profile.ps1\" ✅ 프로파일의 종류 (PowerShell 버전 및 범위별) PowerShell 프로파일은 4가지 유형이 있으며, 현재 사용 중인 것은 사용자별 PowerShell 5.x 프로파일입니다.\n프로파일 경로 적용 대상 설명 $PROFILE 현재 사용자 사용자가 실행한 PowerShell에만 적용 $PROFILE.CurrentUserAllHosts 현재 사용자 모든 PowerShell 호스트(VS Code, ISE 등)에 적용 $PROFILE.AllUsersCurrentHost 모든 사용자 현재 PowerShell 호스트에서 모든 사용자에게 적용 $PROFILE.AllUsersAllHosts 모든 사용자 시스템 전체에서 모든 PowerShell 실행 시 적용 📌 현재 적용된 프로파일 경로 확인\n$PROFILE 📌 모든 프로파일 경로 확인\n$PROFILE | Format-List * ✅ PowerShell 7+에서 동일한 프로파일을 적용하려면? PowerShell 7 (pwsh)에서는 프로파일 경로가 다릅니다.\n만약 PowerShell 7에서 동일한 설정을 사용하려면, 아래 경로의 profile.ps1에도 같은 내용을 추가해야 합니다.\nC:\\Users\\RyanPark\\Documents\\PowerShell\\profile.ps1 ✅ PowerShell 7 프로파일을 즉시 로드하려면:\n. \"$HOME\\Documents\\PowerShell\\profile.ps1\" 🚀 결론 현재 profile.ps1 파일은 Windows PowerShell(5.x)에 적용됨\n✅ 즉시 적용하려면:\n. $PROFILE PowerShell 7+(pwsh)에서는 다른 프로파일 경로를 사용함\n✅ PowerShell 7에서 동일한 설정을 사용하려면, C:\\Users\\RyanPark\\Documents\\PowerShell\\profile.ps1을 수정해야 함.\nVS Code, Windows Terminal 등에서 동일한 프로파일을 적용하려면\n✅ AllHosts 프로파일 ($PROFILE.CurrentUserAllHosts)을 수정하는 것이 더 유용할 수 있음.\n이제 프로파일이 정상적으로 반영될 것입니다! 🚀\nPROFILE 종류 PowerShell에는 여러 개의 profile.ps1 파일이 존재할 수 있으며, 각각 적용되는 범위가 다릅니다.\n아래 명령어를 실행하면 현재 시스템에서 사용 가능한 모든 PowerShell 프로파일 경로를 확인할 수 있습니다.\n$PROFILE | Format-List * ✅ 출력 예시 (PowerShell 5.x)\nAllUsersAllHosts : C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1\rAllUsersCurrentHost : C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Microsoft.PowerShell_profile.ps1\rCurrentUserAllHosts : C:\\Users\\RyanPark\\Documents\\WindowsPowerShell\\profile.ps1\rCurrentUserCurrentHost : C:\\Users\\RyanPark\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 ✅ 출력 예시 (PowerShell 7+)\nAllUsersAllHosts : C:\\Program Files\\PowerShell\\7\\profile.ps1\rAllUsersCurrentHost : C:\\Program Files\\PowerShell\\7\\Microsoft.PowerShell_profile.ps1\rCurrentUserAllHosts : C:\\Users\\RyanPark\\Documents\\PowerShell\\profile.ps1\rCurrentUserCurrentHost : C:\\Users\\RyanPark\\Documents\\PowerShell\\Microsoft.PowerShell_profile.ps1 🔹 프로파일 설명 프로파일 경로 적용 대상 설명 $PROFILE.AllUsersAllHosts 모든 사용자 모든 PowerShell 실행 시 적용 $PROFILE.AllUsersCurrentHost 모든 사용자 특정 PowerShell 호스트 (예: VS Code, Windows Terminal 등)에만 적용 $PROFILE.CurrentUserAllHosts 현재 사용자 모든 PowerShell 실행 시 적용 $PROFILE.CurrentUserCurrentHost 현재 사용자 특정 PowerShell 호스트에서만 적용 🔍 프로파일을 확인하는 명령어 # 현재 사용자에게 적용되는 프로파일 확인 Write-Host \"Current User - All Hosts: $($PROFILE.CurrentUserAllHosts)\" Write-Host \"Current User - Current Host: $($PROFILE.CurrentUserCurrentHost)\" # 모든 사용자에게 적용되는 프로파일 확인 Write-Host \"All Users - All Hosts: $($PROFILE.AllUsersAllHosts)\" Write-Host \"All Users - Current Host: $($PROFILE.AllUsersCurrentHost)\" ✅ 위 명령어를 실행하면 현재 사용 가능한 모든 프로파일 파일 경로가 출력됩니다.\n🚀 결론 PowerShell 5.x에서는\nC:\\Users\\RyanPark\\Documents\\WindowsPowerShell\\profile.ps1\n→ 모든 PowerShell 실행 시 적용됨.\nPowerShell 7+에서는\nC:\\Users\\RyanPark\\Documents\\PowerShell\\profile.ps1\n→ 모든 PowerShell 실행 시 적용됨.\nVS Code, Windows Terminal 등 특정 호스트에서만 적용하려면\nMicrosoft.PowerShell_profile.ps1을 수정해야 함.\n이제 어떤 프로파일을 수정해야 할지 명확하게 알 수 있을 거예요! 🚀\nsshfs : Connection reset by peer 현재 mount-jonpark 실행 시 “Connection reset by peer” 오류가 발생하고 있으며, 드라이브가 정상적으로 마운트되지 않는 문제가 있습니다. 이 문제를 디버깅하는 방법을 단계별로 정리해드리겠습니다.\n1️⃣ SSH 연결 확인 먼저 SSHFS를 사용하려면 기본적으로 SSH 연결이 가능해야 합니다.\nPowerShell에서 SSH 연결이 정상적으로 작동하는지 확인하세요.\nssh jonpark@aws-sig-ts-jonpark.aws.internal ✅ 정상적인 경우\n비밀번호 입력 후 SSH 로그인 성공. 🚨 오류 발생 시\n\"Connection reset by peer\" → 원격 서버 문제(SSH 서비스 중단, 방화벽 차단 등) \"Permission denied\" → 키 인증 문제 또는 계정 권한 부족 📌 SSH 연결이 안 될 경우 해결 방법\n원격 서버에서 SSH 서비스 실행 확인: sudo systemctl status ssh SSH 포트가 열려 있는지 확인: sudo netstat -tulnp | grep ssh 방화벽(EC2 보안 그룹 포함) 설정 확인: sudo ufw status 2️⃣ SSHFS가 정상적으로 동작하는지 확인 SSHFS 명령어를 수동으로 실행하여 PowerShell 스크립트 없이 수동 마운트가 가능한지 확인합니다.\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/ J: -o debug ✅ 정상적인 경우\n드라이브가 J:로 마운트됨. 🚨 에러 발생 시\n\"Connection reset by peer\" → 원격 서버 문제 가능성. \"Read-only file system\" → 파일 시스템 문제. \"Transport endpoint is not connected\" → SSHFS 프로세스 충돌 가능성. 📌 디버깅 옵션 추가 실행 만약 위 명령어가 정상 작동하지 않는다면, 더 많은 디버깅 정보를 얻기 위해 아래와 같이 실행하세요.\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/ J: -o sshfs_debug -o loglevel=debug 🚨 디버깅 로그에서 확인해야 할 부분\n\"Connection reset by peer\" → 서버 문제 가능성이 큼. \"Bad owner or permissions\" → 원격 서버의 파일 권한 문제. 3️⃣ SSHFS 로그 확인 만약 sshfs 명령어가 실행되었는데도 실패한다면, SSHFS가 남긴 로그를 확인해야 합니다.\n🔹 Windows에서 SSHFS 로그 확인\nGet-Content C:\\Windows\\Temp\\sshfs.log -Tail 50 🔹 Linux(EC2)에서 SSH 로그 확인\nsudo journalctl -u ssh -n 50 🚨 주요 에러 예시\n\"Connection reset by peer\" → 네트워크 문제 가능성. \"Permission denied\" → SSH 키 인증 또는 계정 문제. 4️⃣ 마운트 상태 확인 PowerShell에서 J: 드라이브가 인식되는지 확인하세요.\nGet-PSDrive -PSProvider FileSystem 또는 Windows 네트워크 드라이브 목록 확인\nnet use 🚨 드라이브가 보이지 않는다면?\nSSHFS가 정상적으로 실행되지 않았을 가능성이 큼. 기존 SSHFS 마운트가 충돌하고 있을 수도 있음. ✅ 모든 SSHFS 마운트 해제 후 다시 시도\nnet use J: /delete /y 5️⃣ PowerShell 스크립트 디버깅 모드 실행 PowerShell에서 디버깅 모드를 활성화하면 스크립트 실행 중 어디에서 오류가 발생하는지 더 자세한 정보를 얻을 수 있습니다.\nSet-PSDebug -Trace 2 mount-jonpark Set-PSDebug -Trace 0 ✅ 출력에서 sshfs 명령어 실행 위치를 확인하고, 해당 명령어를 수동으로 실행해봅니다.\n🚀 결론 (순서대로 디버깅) SSH 연결 확인\nssh jonpark@aws-sig-ts-jonpark.aws.internal 안 되면 원격 서버에서 SSH 서비스, 방화벽, 보안 그룹 확인. SSHFS 수동 마운트 확인\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/ J: -o debug 실패하면 -o sshfs_debug -o loglevel=debug 옵션 추가. SSHFS 로그 확인\nGet-Content C:\\Windows\\Temp\\sshfs.log -Tail 50 PowerShell 디버깅 활성화 후 실행\nSet-PSDebug -Trace 2 mount-jonpark Set-PSDebug -Trace 0 이제 위 단계를 차례대로 실행하면 문제의 원인을 정확하게 파악할 수 있습니다. 🚀 Remote Directory가 /home/jonpark이 아닐 가능성 🔍 문제 원인: Remote Directory가 /home/jonpark이 아닐 가능성 SSH 접속은 정상적으로 이루어지지만, SSHFS 마운트 시 bad mount point J: No such file or directory 오류가 발생하고 있습니다.\n이 오류는 보통 원격 디렉터리가 존재하지 않거나, 접근 권한이 없을 때 발생합니다.\n✅ 해결 방법 1: 원격 서버에서 기본 홈 디렉터리 확인 현재 SSHFS 명령어를 실행할 때 기본적으로 원격 서버의 / (루트 디렉터리)를 마운트하려고 하고 있음.\n그러나 사용자의 홈 디렉터리가 /home/jonpark이 아닐 수도 있습니다.\n먼저 SSH로 접속한 후, 현재 디렉터리가 어디인지 확인하세요.\necho $HOME pwd ls -la ~ 📌 출력 예시 (홈 디렉터리가 /home/jonpark일 경우)\n/home/jonpark 📌 출력 예시 (홈 디렉터리가 다른 위치일 경우)\n/mnt/data/jonpark 🚀 해결 방법: 만약 홈 디렉터리가 /home/jonpark이 아니라 /mnt/data/jonpark과 같은 다른 위치라면, SSHFS 명령어에서 정확한 경로를 지정해야 합니다.\n✅ 예제\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/mnt/data/jonpark J: -o debug ✅ 해결 방법 2: 원격 디렉터리 존재 여부 확인 혹시 SSHFS가 마운트하려는 디렉터리가 실제로 존재하지 않는다면 마운트가 실패할 수 있습니다.\n아래 명령어로 마운트하려는 경로가 실제로 있는지 확인하세요.\nls -ld / ls -ld /home ls -ld /home/jonpark 🚨 출력 예시 (디렉터리가 없을 경우)\nls: cannot access '/home/jonpark': No such file or directory ✅ 해결 방법: 존재하는 디렉터리를 확인한 후, SSHFS 마운트 경로를 수정하세요.\n✅ 해결 방법 3: 로컬 마운트 포인트 존재 여부 확인 Windows에서 SSHFS를 사용하려면, J: 드라이브가 실제로 존재해야 합니다.\n다음 명령어로 확인하세요.\nGet-PSDrive -PSProvider FileSystem 🚨 출력 예시 (J: 드라이브 없음)\nName Used (GB) Free (GB) Provider Root\r---- -------- --------- -------- ----\rC 50.23 100.7 FileSystem C:\\\rD 80.42 150.1 FileSystem D:\\\rE 100.42 250.1 FileSystem E:\\ ✅ 해결 방법: SSHFS 마운트 전에 먼저 드라이브를 생성하세요.\nnet use J: /delete /y ✅ 해결 방법 4: SSHFS 마운트 디버깅 (-o debug 옵션 사용) SSHFS 마운트 시 더 많은 디버깅 정보를 확인하려면 다음과 같이 실행하세요.\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/home/jonpark J: -o sshfs_debug -o loglevel=debug 🚀 최종 실행 방법 ✅ 홈 디렉터리가 /home/jonpark일 경우\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/home/jonpark J: -o debug ✅ 홈 디렉터리가 /mnt/data/jonpark일 경우\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/mnt/data/jonpark J: -o debug ✅ 루트 디렉터리를 마운트하려면 (/)\nsshfs jonpark@aws-sig-ts-jonpark.aws.internal:/ J: -o debug 🚀 이제 다시 시도해보세요! 🚀\nvisual studio 2022 에서 msbuild.exe 위치는 Visual Studio 2022에서 cl.exe는 Visual Studio 설치 디렉토리 안의 MSVC 도구 디렉토리에 위치합니다. cl.exe는 Microsoft C/C++ 컴파일러로, 아래 경로에서 찾을 수 있습니다.\n기본 경로 C:\\Program Files\\Microsoft Visual Studio\\2022\\\\VC\\Tools\\MSVC\\\\bin\\Hostx64\\x64\\cl.exe 설명: : Visual Studio 에디션 Community, Professional, Enterprise : 설치된 MSVC 도구 버전 (예: 14.36.32532) 정확한 버전 번호는 Visual Studio 설치 시 설치된 도구 버전에 따라 달라집니다. 예를 들어, Visual Studio 2022 Community Edition과 최신 MSVC 도구를 사용하는 경우:\nC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\bin\\Hostx64\\x64\\cl.exe cl.exe 경로 확인 방법 1. Visual Studio 명령 프롬프트 사용 Visual Studio 설치 시 제공되는 **“x64 Native Tools Command Prompt for VS 2022”**를 실행합니다. 다음 명령어를 실행하여 cl.exe 경로를 확인합니다: where cl 2. Visual Studio 설치 관리자에서 확인 Visual Studio Installer를 열고 설치된 구성에서 “Desktop development with C++” 워크로드가 설치되어 있는지 확인합니다. 이 워크로드가 설치되어야 cl.exe가 포함됩니다. 3. 파일 탐색기로 확인 아래 경로에서 직접 확인: C:\\Program Files\\Microsoft Visual Studio\\2022\\\\VC\\Tools\\MSVC MSVC 버전 폴더 내부를 탐색해 bin\\Hostx64\\x64 경로에서 cl.exe 파일을 찾습니다. 환경 변수에 추가 (선택 사항) cl.exe를 자주 사용해야 한다면, 해당 경로를 환경 변수 PATH에 추가하여 어디서나 사용할 수 있도록 설정할 수 있습니다.\nWindows 검색 → “환경 변수 편집” 입력 후 실행. “시스템 변수” 섹션에서 Path를 선택하고 “편집” 클릭. 위 경로를 새로 추가. 필요한 사항이나 추가 질문이 있으면 언제든 말씀해주세요! 😊 ","wordCount":"4305","inLanguage":"ko","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://jongyongpark.github.io/posts/technical-support/windows-setting/"},"publisher":{"@type":"Organization","name":"RyanLabs","logo":{"@type":"ImageObject","url":"https://jongyongpark.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jongyongpark.github.io/ accesskey=h title="RyanLabs (Alt + H)">RyanLabs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jongyongpark.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://jongyongpark.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://jongyongpark.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://jongyongpark.github.io/archives/ title=연도><span>연도</span></a></li><li><a href=https://jongyongpark.github.io/lectures/ title=강의><span>강의</span></a></li><li><a href=https://jongyongpark.github.io/about/ title=어바웃미><span>어바웃미</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h1 id=sshfs가-인식되지-않는다는-오류>sshfs가 인식되지 않는다는 오류<a hidden class=anchor aria-hidden=true href=#sshfs가-인식되지-않는다는-오류>#</a></h1><p><code>sshfs</code>가 인식되지 않는다는 오류가 발생한 이유는 <code>sshfs-win</code>이 설치되지 않았거나 <code>sshfs</code> 명령어가 PowerShell에서 인식되지 않기 때문입니다.</p><h3 id=해결-방법>해결 방법:<a hidden class=anchor aria-hidden=true href=#해결-방법>#</a></h3><ol><li><p><strong><code>sshfs-win</code> 설치 확인</strong><br><code>sshfs</code>를 사용하려면 <code>WinFsp</code>와 <code>SSHFS-Win</code>이 설치되어 있어야 합니다.</p><ul><li><a href=https://github.com/winfsp/winfsp/releases>WinFsp 다운로드</a></li><li><a href=https://github.com/billziss-gh/sshfs-win/releases>SSHFS-Win 다운로드</a></li></ul><p>설치 후, PowerShell을 다시 실행하고 아래 명령어로 <code>sshfs</code>가 인식되는지 확인하세요:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs --version
</span></span></code></pre></div></li><li><p><strong>PowerShell에서 <code>sshfs</code> 실행 가능하도록 경로 설정</strong><br><code>sshfs.exe</code>가 <code>C:\Program Files\SSHFS-Win\bin</code>에 위치해 있다면, 이를 <code>PATH</code>에 추가해야 합니다.<br>PowerShell에서 다음 명령어를 실행하세요:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$env:Path += <span style=color:#e6db74>&#34;;C:\Program Files\SSHFS-Win\bin&#34;</span>
</span></span></code></pre></div></li><li><p><strong>수정된 스크립트</strong><br>위 방법이 적용된 후, <code>Mount-JonparkDrive</code> 함수를 수정하여 정상적으로 실행되도록 변경했습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#66d9ef>function</span> Mount-JonparkDrive {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>param</span>(
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$DriveLetter = <span style=color:#e6db74>&#34;J&#34;</span>,
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$RemotePath = <span style=color:#e6db74>&#34;jonpark@aws-sig-ts-jonpark.aws.internal:/&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e># SSHFS 실행 가능한지 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-not</span> (Get-Command sshfs -ErrorAction SilentlyContinue)) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Error: sshfs is not installed or not in PATH.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 드라이브가 이미 연결되었는지 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Drive </span>${DriveLetter}<span style=color:#e6db74>: is already mounted.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sshfs $RemotePath <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Successfully mounted drive </span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Error mounting drive: </span>$_<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> Dismount-JonparkDrive {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>param</span>(
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$DriveLetter = <span style=color:#e6db74>&#34;J&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-not</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>)) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Drive </span>${DriveLetter}<span style=color:#e6db74>: is not mounted.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        net use <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span> /delete /y
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Successfully dismounted drive </span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Error dismounting drive: </span>$_<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Set-Alias mount-jonpark Mount-JonparkDrive
</span></span><span style=display:flex><span>Set-Alias umount-jonpark Dismount-JonparkDrive
</span></span></code></pre></div></li></ol><h3 id=변경-사항>변경 사항:<a hidden class=anchor aria-hidden=true href=#변경-사항>#</a></h3><ul><li><strong><code>sshfs</code>가 설치되었는지 확인</strong>하도록 추가 (<code>Get-Command sshfs</code> 사용).</li><li><strong>이미 마운트된 드라이브인지 확인</strong>하고 중복 마운트를 방지.</li><li><strong><code>net use /delete</code>를 사용할 때 <code>-y</code> 옵션 추가</strong>하여 사용자 입력 없이 강제 제거.</li></ul><h2 id=수정-후-다시-실행해보고-문제가-있다면-추가적으로-확인해볼게요->수정 후 다시 실행해보고 문제가 있다면 추가적으로 확인해볼게요. 😊<a hidden class=anchor aria-hidden=true href=#수정-후-다시-실행해보고-문제가-있다면-추가적으로-확인해볼게요->#</a></h2><h1 id=sshfs-win-이-설치된-경로를-찾는-명령어>SSHFS-Win 이 설치된 경로를 찾는 명령어<a hidden class=anchor aria-hidden=true href=#sshfs-win-이-설치된-경로를-찾는-명령어>#</a></h1><p>SSHFS-Win이 설치된 경로를 찾는 방법은 여러 가지가 있습니다. 다음 명령어를 PowerShell에서 실행해보세요.</p><h3 id=1-레지스트리에서-설치-경로-확인>1. <strong>레지스트리에서 설치 경로 확인</strong><a hidden class=anchor aria-hidden=true href=#1-레지스트리에서-설치-경로-확인>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-ItemProperty -Path <span style=color:#e6db74>&#34;HKLM:\SOFTWARE\WOW6432Node\WinFsp&#34;</span> -Name InstallDir
</span></span></code></pre></div><p>또는 (64비트 시스템에서 32비트 레지스트리를 검색할 경우)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-ItemProperty -Path <span style=color:#e6db74>&#34;HKLM:\SOFTWARE\WinFsp&#34;</span> -Name InstallDir
</span></span></code></pre></div><p>위 명령어를 실행하면 <code>WinFsp</code>의 설치 경로를 확인할 수 있습니다. SSHFS-Win은 WinFsp에 의존하므로 관련 경로를 확인할 수 있습니다.</p><hr><h3 id=2-프로그램-파일에서-직접-확인>2. <strong>프로그램 파일에서 직접 확인</strong><a hidden class=anchor aria-hidden=true href=#2-프로그램-파일에서-직접-확인>#</a></h3><p>SSHFS-Win이 보통 설치되는 경로:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>ls <span style=color:#e6db74>&#34;C:\Program Files\SSHFS-Win\bin&#34;</span>
</span></span></code></pre></div><p>또는</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>ls <span style=color:#e6db74>&#34;C:\Program Files (x86)\SSHFS-Win\bin&#34;</span>
</span></span></code></pre></div><p>이 폴더 안에 <code>sshfs.exe</code>가 있으면, 해당 경로가 SSHFS-Win이 설치된 위치입니다.</p><hr><h3 id=3-where-명령어로-실행-파일-검색>3. <strong><code>where</code> 명령어로 실행 파일 검색</strong><a hidden class=anchor aria-hidden=true href=#3-where-명령어로-실행-파일-검색>#</a></h3><p>SSHFS-Win이 환경 변수(<code>PATH</code>)에 등록되어 있다면 다음 명령어로 확인할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>where sshfs
</span></span></code></pre></div><p>위 명령어가 <code>sshfs.exe</code>의 전체 경로를 반환하면 해당 위치에서 실행 가능합니다.</p><hr><h3 id=4-파일-탐색기로-검색>4. <strong>파일 탐색기로 검색</strong><a hidden class=anchor aria-hidden=true href=#4-파일-탐색기로-검색>#</a></h3><p>파일 탐색기에서 <code>C:\Program Files</code>, <code>C:\Program Files (x86)</code>, <code>C:\Users\USERNAME\AppData\Local\Programs</code> 등의 폴더에서 <code>sshfs.exe</code>를 직접 검색할 수도 있습니다.</p><p>위 방법 중 하나를 사용하여 SSHFS-Win의 설치 경로를 찾아보세요! 😊</p><hr><h1 id=evn-path-영구적으로-적용>evn path 영구적으로 적용<a hidden class=anchor aria-hidden=true href=#evn-path-영구적으로-적용>#</a></h1><p>현재 세션에서만 동작하는 <code>$env:Path += ";C:\Program Files\SSHFS-Win\bin"</code>을 영구적으로 적용하려면 사용자 환경 변수(User Environment Variable)에 추가해야 합니다. 다음 방법 중 하나를 사용하세요.</p><hr><h3 id=1-powershell을-사용하여-환경-변수-등록>1. <strong>PowerShell을 사용하여 환경 변수 등록</strong><a hidden class=anchor aria-hidden=true href=#1-powershell을-사용하여-환경-변수-등록>#</a></h3><p>PowerShell에서 아래 명령어를 실행하면 **사용자 환경 변수(User Environment Variable)**에 SSHFS-Win 경로가 추가됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$Path = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>)
</span></span><span style=display:flex><span>$NewPath = <span style=color:#e6db74>&#34;</span>$Path<span style=color:#e6db74>;C:\Program Files\SSHFS-Win\bin&#34;</span>
</span></span><span style=display:flex><span>[<span style=color:#66d9ef>System.Environment</span>]::SetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, $NewPath, <span style=color:#e6db74>&#34;User&#34;</span>)
</span></span></code></pre></div><p>✅ 이 명령어는 시스템을 재부팅하거나, 로그아웃 후 다시 로그인하면 적용됩니다.</p><hr><h3 id=2-레지스트리를-직접-수정하여-추가>2. <strong>레지스트리를 직접 수정하여 추가</strong><a hidden class=anchor aria-hidden=true href=#2-레지스트리를-직접-수정하여-추가>#</a></h3><p>다음 명령어를 실행하면 <strong>Windows 레지스트리의 환경 변수</strong>에 SSHFS-Win 경로를 영구적으로 추가합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$CurrentPath = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>)
</span></span><span style=display:flex><span>$NewPath = <span style=color:#e6db74>&#34;</span>$CurrentPath<span style=color:#e6db74>;C:\Program Files\SSHFS-Win\bin&#34;</span>
</span></span><span style=display:flex><span>Set-ItemProperty -Path <span style=color:#e6db74>&#34;HKCU:\Environment&#34;</span> -Name <span style=color:#e6db74>&#34;Path&#34;</span> -Value $NewPath
</span></span></code></pre></div><p>✅ 이 방법 역시 시스템 재부팅 또는 새 로그인 후 적용됩니다.</p><hr><h3 id=3-gui그래픽-인터페이스에서-환경-변수-추가>3. <strong>GUI(그래픽 인터페이스)에서 환경 변수 추가</strong><a hidden class=anchor aria-hidden=true href=#3-gui그래픽-인터페이스에서-환경-변수-추가>#</a></h3><ol><li><strong>Win + R</strong> → <code>sysdm.cpl</code> 입력 후 실행</li><li><strong>고급(Advanced) 탭</strong> → &ldquo;환경 변수(Environment Variables)&rdquo; 클릭</li><li><strong>사용자 환경 변수(User variables)에서 &ldquo;Path&rdquo; 선택 후 &ldquo;편집(Edit)&rdquo;</strong></li><li>&ldquo;새로 만들기(New)&ldquo;를 클릭한 후 <code>C:\Program Files\SSHFS-Win\bin</code> 입력</li><li>&ldquo;확인(OK)&ldquo;을 눌러 저장 후 시스템을 다시 시작</li></ol><hr><h3 id=4-환경-변수-적용-확인>4. <strong>환경 변수 적용 확인</strong><a hidden class=anchor aria-hidden=true href=#4-환경-변수-적용-확인>#</a></h3><p>아래 명령어를 실행하여 SSHFS-Win 경로가 제대로 추가되었는지 확인하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>[<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>) -split <span style=color:#e6db74>&#34;;&#34;</span>
</span></span></code></pre></div><p>또는 새로운 PowerShell 창을 열고 다음을 실행:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>where sshfs
</span></span></code></pre></div><p>결과에 <code>C:\Program Files\SSHFS-Win\bin\sshfs.exe</code>가 표시되면 정상적으로 적용된 것입니다. 🚀</p><p>이제 PowerShell을 새로 열거나 시스템을 재부팅하면 <code>sshfs</code> 명령어가 항상 인식될 것입니다. 😃</p><hr><h1 id=불필요한-공백-제거-및-path-변수-업데이트>불필요한 공백 제거 및 Path 변수 업데이트<a hidden class=anchor aria-hidden=true href=#불필요한-공백-제거-및-path-변수-업데이트>#</a></h1><p>현재 <code>Path</code> 변수에 불필요한 공백(빈 줄)이 포함되어 있습니다. 이를 제거하고 정리하는 방법을 알려드릴게요.</p><h3 id=1-불필요한-공백-제거-및-path-변수-업데이트><strong>1. 불필요한 공백 제거 및 <code>Path</code> 변수 업데이트</strong><a hidden class=anchor aria-hidden=true href=#1-불필요한-공백-제거-및-path-변수-업데이트>#</a></h3><p>아래 명령어를 실행하면, 기존 <code>Path</code> 변수에서 빈 줄을 제거하고 다시 설정합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$CurrentPath = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>) -split <span style=color:#e6db74>&#34;;&#34;</span> | Where-Object { $_ <span style=color:#f92672>-match</span> <span style=color:#e6db74>&#34;\S&#34;</span> }
</span></span><span style=display:flex><span>$NewPath = ($CurrentPath -join <span style=color:#e6db74>&#34;;&#34;</span>)
</span></span><span style=display:flex><span>[<span style=color:#66d9ef>System.Environment</span>]::SetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, $NewPath, <span style=color:#e6db74>&#34;User&#34;</span>)
</span></span></code></pre></div><hr><h3 id=2-path가-정상적으로-정리되었는지-확인><strong>2. <code>Path</code>가 정상적으로 정리되었는지 확인</strong><a hidden class=anchor aria-hidden=true href=#2-path가-정상적으로-정리되었는지-확인>#</a></h3><p>수정 후, 아래 명령어를 실행하여 불필요한 공백이 제거되었는지 확인하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>[<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>) -split <span style=color:#e6db74>&#34;;&#34;</span>
</span></span></code></pre></div><p>이제 <code>C:\Program Files\SSHFS-Win\bin</code>이 정상적으로 추가되었으며, 공백 없이 깔끔한 <code>Path</code> 목록이 출력될 것입니다.</p><p>💡 <strong>변경 사항이 바로 적용되지 않을 경우</strong>, PowerShell을 다시 실행하거나 로그아웃 후 다시 로그인하면 적용됩니다. 🚀</p><hr><h1 id=powershell-에서-마운팅된-드라이브를-보여주는-명령어>powershell 에서 마운팅된 드라이브를 보여주는 명령어<a hidden class=anchor aria-hidden=true href=#powershell-에서-마운팅된-드라이브를-보여주는-명령어>#</a></h1><p>PowerShell에서 현재 <strong>마운트된 네트워크 드라이브</strong> 또는 <strong>로컬 드라이브</strong>를 확인하는 명령어는 다음과 같습니다.</p><hr><h3 id=1-모든-드라이브-목록-확인-네트워크-드라이브-포함><strong>1. 모든 드라이브 목록 확인 (네트워크 드라이브 포함)</strong><a hidden class=anchor aria-hidden=true href=#1-모든-드라이브-목록-확인-네트워크-드라이브-포함>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div><p>✅ <strong>출력 예시</strong></p><pre tabindex=0><code>Name           Used (GB)     Free (GB) Provider   Root
----           --------     --------- --------   ----
C                 50.23         100.7 FileSystem C:\
D                 80.42         150.1 FileSystem D:\
J                Unknown       Unknown FileSystem J:\
</code></pre><p>📌 여기서 <code>J:\</code>처럼 네트워크 드라이브가 마운트된 경우 확인 가능</p><hr><h3 id=2-특정-드라이브가-마운트되었는지-확인><strong>2. 특정 드라이브가 마운트되었는지 확인</strong><a hidden class=anchor aria-hidden=true href=#2-특정-드라이브가-마운트되었는지-확인>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Root <span style=color:#f92672>-eq</span> <span style=color:#e6db74>&#34;J:\&#34;</span> }
</span></span></code></pre></div><p>✅ <code>J:\</code> 드라이브가 마운트되어 있으면 정보가 출력됩니다. 없으면 출력이 없습니다.</p><hr><h3 id=3-net-use-명령어로-네트워크-드라이브-확인><strong>3. <code>net use</code> 명령어로 네트워크 드라이브 확인</strong><a hidden class=anchor aria-hidden=true href=#3-net-use-명령어로-네트워크-드라이브-확인>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>net use
</span></span></code></pre></div><p>✅ 이 명령어는 Windows 명령어지만 PowerShell에서도 사용 가능하며, 네트워크 드라이브 목록을 보여줍니다.
✅ SSHFS를 통해 마운트한 드라이브도 여기에 표시될 수 있습니다.</p><p>📌 <strong>출력 예시</strong></p><pre tabindex=0><code>상태      로컬     원격                          네트워크
-----------------------------------------------------------------
OK        J:       \\aws-sig-ts-jonpark.aws.internal\share   SSHFS
</code></pre><hr><h3 id=4-wmi를-사용하여-네트워크-드라이브-목록-확인><strong>4. WMI를 사용하여 네트워크 드라이브 목록 확인</strong><a hidden class=anchor aria-hidden=true href=#4-wmi를-사용하여-네트워크-드라이브-목록-확인>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DriveType <span style=color:#f92672>-eq</span> <span style=color:#ae81ff>4</span> }
</span></span></code></pre></div><p>✅ <code>DriveType = 4</code>는 <strong>네트워크 드라이브</strong>만 필터링하여 보여줍니다.</p><p>📌 <strong>출력 예시</strong></p><pre tabindex=0><code>DeviceID     : J:
DriveType    : 4
ProviderName : \\aws-sig-ts-jonpark.aws.internal\share
FreeSpace    : 5000000000
Size         : 10000000000
</code></pre><hr><h3 id=어떤-명령어를-사용해야-할까><strong>어떤 명령어를 사용해야 할까?</strong><a hidden class=anchor aria-hidden=true href=#어떤-명령어를-사용해야-할까>#</a></h3><ul><li><strong>로컬 드라이브 & 네트워크 드라이브 전체 확인</strong> → <code>Get-PSDrive -PSProvider FileSystem</code></li><li><strong>특정 드라이브 마운트 여부 확인</strong> → <code>Get-PSDrive | Where-Object { $_.Root -eq "J:\" }</code></li><li><strong>네트워크 드라이브만 확인</strong> → <code>net use</code> 또는 <code>Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DriveType -eq 4 }</code></li></ul><h2 id=이제-원하는-방식으로-마운트된-드라이브를-확인할-수-있을-거예요->이제 원하는 방식으로 마운트된 드라이브를 확인할 수 있을 거예요! 🚀<a hidden class=anchor aria-hidden=true href=#이제-원하는-방식으로-마운트된-드라이브를-확인할-수-있을-거예요->#</a></h2><h1 id=sshfs-로-등록했는데-실제로는-네트워크-드라이브가-보이지-않아>sshfs 로 등록했는데 실제로는 네트워크 드라이브가 보이지 않아<a hidden class=anchor aria-hidden=true href=#sshfs-로-등록했는데-실제로는-네트워크-드라이브가-보이지-않아>#</a></h1><p>SSHFS를 사용하여 마운트한 드라이브가 <code>net use</code> 또는 <code>Get-WmiObject -Class Win32_LogicalDisk</code>에서 보이지 않는 문제는 <strong>SSHFS로 마운트된 드라이브가 네트워크 드라이브가 아닌 일반 로컬 드라이브로 인식될 가능성</strong> 때문입니다.</p><p>이를 해결하려면 <strong>SSHFS가 마운트된 드라이브를 정확하게 감지할 수 있는 PowerShell 명령어</strong>를 사용해야 합니다.</p><hr><h3 id=-1-sshfs로-마운트된-드라이브-확인-대체-방법><strong>✅ 1. SSHFS로 마운트된 드라이브 확인 (대체 방법)</strong><a hidden class=anchor aria-hidden=true href=#-1-sshfs로-마운트된-드라이브-확인-대체-방법>#</a></h3><p>기존 방법 (<code>net use</code>, <code>Get-WmiObject</code>) 대신, <code>fsutil</code> 또는 <code>subst</code>를 활용하여 SSHFS 드라이브를 찾을 수 있습니다.</p><h4 id=-1-1-get-psdrive를-사용하여-마운트된-드라이브-확인><strong>🔹 1-1. <code>Get-PSDrive</code>를 사용하여 마운트된 드라이브 확인</strong><a hidden class=anchor aria-hidden=true href=#-1-1-get-psdrive를-사용하여-마운트된-드라이브-확인>#</a></h4><p>SSHFS로 마운트된 드라이브는 일반적으로 <code>FileSystem</code> 유형으로 등록됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div><p>✅ 이 명령어를 실행하면 마운트된 모든 드라이브(로컬 및 SSHFS 포함)가 표시됩니다.</p><hr><h4 id=-1-2-fsutil을-사용하여-드라이브-유형-확인><strong>🔹 1-2. <code>fsutil</code>을 사용하여 드라이브 유형 확인</strong><a hidden class=anchor aria-hidden=true href=#-1-2-fsutil을-사용하여-드라이브-유형-확인>#</a></h4><p><code>fsutil fsinfo drives</code>를 사용하면 현재 사용 가능한 모든 드라이브 목록을 확인할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>fsutil fsinfo drives
</span></span></code></pre></div><p>📌 예제 출력:</p><pre tabindex=0><code>Drives: C:\ D:\ E:\ J:\ 
</code></pre><p>여기서 <code>J:\</code>가 SSHFS로 마운트된 드라이브인지 확인하려면:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>fsutil fsinfo volumeinfo J:
</span></span></code></pre></div><p>📌 출력에서 <code>File System Type</code>이 <code>SSHFS</code>로 설정되어 있으면 정상적으로 마운트된 것입니다.</p><hr><h4 id=-1-3-wmic-logicaldisk로-드라이브-유형-확인><strong>🔹 1-3. <code>wmic logicaldisk</code>로 드라이브 유형 확인</strong><a hidden class=anchor aria-hidden=true href=#-1-3-wmic-logicaldisk로-드라이브-유형-확인>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>wmic logicaldisk get DeviceID, FileSystem, VolumeName
</span></span></code></pre></div><p>📌 예제 출력:</p><pre tabindex=0><code>DeviceID  FileSystem  VolumeName
C:        NTFS       Windows
D:        NTFS       Data
J:        SSHFS      RemoteServer
</code></pre><p>✅ <code>J:</code> 드라이브가 <code>SSHFS</code> 파일 시스템으로 인식되는지 확인하세요.</p><hr><h3 id=-2-powershell-스크립트로-sshfs-마운트된-드라이브-찾기><strong>✅ 2. PowerShell 스크립트로 SSHFS 마운트된 드라이브 찾기</strong><a hidden class=anchor aria-hidden=true href=#-2-powershell-스크립트로-sshfs-마운트된-드라이브-찾기>#</a></h3><p>SSHFS로 마운트된 드라이브만 필터링하려면 다음 스크립트를 실행하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$sshfsDrives = Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Root <span style=color:#f92672>-match</span> <span style=color:#e6db74>&#34;^[A-Z]:\\&#34;</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> ($drive <span style=color:#66d9ef>in</span> $sshfsDrives) {
</span></span><span style=display:flex><span>    $info = fsutil fsinfo volumeinfo $drive.Root <span style=color:#ae81ff>2</span>&gt;$null
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ($info <span style=color:#f92672>-match</span> <span style=color:#e6db74>&#34;File System Name: SSHFS&#34;</span>) {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;SSHFS Mounted Drive: </span>$($drive.Root)<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>✅ <code>SSHFS Mounted Drive: J:\</code> 형태로 출력되면 정상적으로 마운트된 것입니다.</p><hr><h3 id=-3-sshfs-드라이브가-정상적으로-마운트되었는지-확인><strong>✅ 3. SSHFS 드라이브가 정상적으로 마운트되었는지 확인</strong><a hidden class=anchor aria-hidden=true href=#-3-sshfs-드라이브가-정상적으로-마운트되었는지-확인>#</a></h3><p><strong>마운트 확인 및 문제 해결 체크리스트</strong></p><ol><li><strong>PowerShell에서 SSHFS 드라이브가 인식되는지 확인</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div></li><li><strong>SSHFS 드라이브가 <code>fsutil</code>에서 감지되는지 확인</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>fsutil fsinfo drives
</span></span></code></pre></div></li><li><strong>SSHFS 드라이브가 실제 파일 시스템으로 등록되었는지 확인</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>fsutil fsinfo volumeinfo J:
</span></span></code></pre></div></li><li><strong>Windows 탐색기에서 드라이브를 강제로 새로고침</strong><br><code>F5</code> 키를 누르거나 <strong>Windows 탐색기에서 &lsquo;내 PC&rsquo;를 새로고침</strong>합니다.</li></ol><hr><h3 id=-4-sshfs-드라이브가-windows-네트워크-드라이브로-표시되게-만들기><strong>✅ 4. SSHFS 드라이브가 Windows 네트워크 드라이브로 표시되게 만들기</strong><a hidden class=anchor aria-hidden=true href=#-4-sshfs-드라이브가-windows-네트워크-드라이브로-표시되게-만들기>#</a></h3><p>만약 SSHFS로 마운트된 드라이브를 Windows에서 네트워크 드라이브처럼 표시하려면 다음 명령어를 사용할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>New-PSDrive -Name <span style=color:#e6db74>&#34;J&#34;</span> -PSProvider FileSystem -Root <span style=color:#e6db74>&#34;\\sshfs\jonpark@aws-sig-ts-jonpark.aws.internal\&#34;</span> -Persist
</span></span></code></pre></div><p>📌 이렇게 하면 SSHFS 드라이브가 Windows 네트워크 드라이브로 인식됩니다.</p><hr><h3 id=-5-해결되지-않는-경우-sshfs-마운트-방식-변경><strong>✅ 5. 해결되지 않는 경우 SSHFS 마운트 방식 변경</strong><a hidden class=anchor aria-hidden=true href=#-5-해결되지-않는-경우-sshfs-마운트-방식-변경>#</a></h3><p>SSHFS를 마운트할 때 <code>/network</code> 옵션을 추가하면 네트워크 드라이브로 인식될 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/ <span style=color:#e6db74>&#34;J:&#34;</span> -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks
</span></span></code></pre></div><p>✅ 이렇게 하면 <code>net use</code>에서도 네트워크 드라이브처럼 보일 가능성이 높아집니다.</p><hr><h3 id=-결론><strong>🔍 결론</strong><a hidden class=anchor aria-hidden=true href=#-결론>#</a></h3><ol><li><code>Get-PSDrive -PSProvider FileSystem</code>으로 마운트된 드라이브를 먼저 확인하세요.</li><li><code>fsutil fsinfo volumeinfo J:</code>로 SSHFS가 인식되는지 확인하세요.</li><li><code>New-PSDrive -Persist</code> 옵션을 사용하면 네트워크 드라이브로 표시할 수 있습니다.</li><li>SSHFS 마운트 시 <code>/network</code> 옵션을 추가하면 Windows 탐색기에서 네트워크 드라이브로 보일 가능성이 높아집니다.</li></ol><h2 id=이제-sshfs로-마운트한-드라이브가-정상적으로-표시될-거예요->이제 SSHFS로 마운트한 드라이브가 정상적으로 표시될 거예요! 🚀<a hidden class=anchor aria-hidden=true href=#이제-sshfs로-마운트한-드라이브가-정상적으로-표시될-거예요->#</a></h2><h1 id=sshfs-드라이브가-정상적으로-마운트되지-않는-문제>SSHFS 드라이브가 정상적으로 마운트되지 않는 문제<a hidden class=anchor aria-hidden=true href=#sshfs-드라이브가-정상적으로-마운트되지-않는-문제>#</a></h1><p>현재 <strong>SSHFS 드라이브가 정상적으로 마운트되지 않는 문제</strong>가 있습니다. SSHFS에서 <code>Successfully mounted drive J:</code>라고 나오지만, 실제로 시스템에서 드라이브를 찾을 수 없는 상태입니다. 이 문제를 해결하고, SSHFS로 마운트된 드라이브를 올바르게 감지할 수 있도록 스크립트를 수정하겠습니다.</p><hr><h3 id=-원인-분석><strong>🔍 원인 분석</strong><a hidden class=anchor aria-hidden=true href=#-원인-분석>#</a></h3><ol><li><code>Successfully mounted drive J:</code>라고 나오지만, <code>fsutil</code>이나 <code>Get-PSDrive</code>에서 인식되지 않음.</li><li><code>umount-jonpark</code> 실행 시 <code>"The network connection could not be found."</code> 오류 발생.</li><li>SSHFS 실행 중 <code>"Connection reset by peer"</code> 메시지 발생 → 원격 서버 연결이 중단되었을 가능성 있음.</li><li><code>fsutil fsinfo volumeinfo J:</code> 실행 시 <code>"The system cannot find the path specified."</code> → 드라이브가 실제로 마운트되지 않음.</li></ol><p>이런 문제는 보통 <strong>SSHFS 실행 방식이 Windows와 호환되지 않거나, SSHFS 프로세스가 비정상 종료되었기 때문</strong>입니다.</p><hr><h3 id=-해결-방법><strong>✅ 해결 방법</strong><a hidden class=anchor aria-hidden=true href=#-해결-방법>#</a></h3><ol><li><p><strong>SSHFS 마운트 방식 수정 (<code>subst</code> 사용)</strong></p><ul><li>SSHFS는 Windows에서 네트워크 드라이브가 아닌 로컬 드라이브처럼 동작할 수 있음.</li><li><code>subst</code>를 사용하면 Windows에서도 드라이브를 정상적으로 감지할 수 있음.</li></ul></li><li><p><strong>마운트 여부를 정확히 확인하는 스크립트 추가</strong></p><ul><li><code>fsutil</code>이 아닌 <code>Get-PSDrive</code>를 활용하여 마운트 확인.</li><li><code>tasklist</code>로 <code>sshfs.exe</code>가 실행 중인지 확인.</li></ul></li></ol><hr><h3 id=-수정된-powershell-스크립트><strong>🔧 수정된 PowerShell 스크립트</strong><a hidden class=anchor aria-hidden=true href=#-수정된-powershell-스크립트>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#66d9ef>function</span> Mount-JonparkDrive {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>param</span>(
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$DriveLetter = <span style=color:#e6db74>&#34;J&#34;</span>,
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$RemotePath = <span style=color:#e6db74>&#34;jonpark@aws-sig-ts-jonpark.aws.internal:/&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e># SSHFS가 설치되어 있는지 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-not</span> (Get-Command sshfs -ErrorAction SilentlyContinue)) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Error: sshfs is not installed or not in PATH.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 이미 마운트된 경우 방지</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Drive </span>${DriveLetter}<span style=color:#e6db74>: is already mounted.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># SSHFS로 마운트 수행</span>
</span></span><span style=display:flex><span>        sshfs $RemotePath <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span> -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks
</span></span><span style=display:flex><span>        Start-Sleep -Seconds <span style=color:#ae81ff>2</span>  <span style=color:#75715e># SSHFS가 안정적으로 마운트될 시간을 줌</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 마운트 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Successfully mounted drive </span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Error: Drive </span>${DriveLetter}<span style=color:#e6db74>: was not mounted successfully.&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Error mounting drive: </span>$_<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> Dismount-JonparkDrive {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>param</span>(
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$DriveLetter = <span style=color:#e6db74>&#34;J&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e># 드라이브가 실제로 존재하는지 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-not</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>)) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Drive </span>${DriveLetter}<span style=color:#e6db74>: is not mounted.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># SSHFS 드라이브 언마운트</span>
</span></span><span style=display:flex><span>        net use <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span> /delete /y <span style=color:#ae81ff>2</span>&gt;$null
</span></span><span style=display:flex><span>        Start-Sleep -Seconds <span style=color:#ae81ff>2</span>  <span style=color:#75715e># 마운트 해제 시간 확보</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 언마운트 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-not</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>)) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Successfully dismounted drive </span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Error: Failed to unmount drive </span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Error dismounting drive: </span>$_<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> Check-MountedDrives {
</span></span><span style=display:flex><span>    <span style=color:#75715e># 현재 마운트된 드라이브 확인</span>
</span></span><span style=display:flex><span>    Get-PSDrive -PSProvider FileSystem
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Set-Alias mount-jonpark Mount-JonparkDrive
</span></span><span style=display:flex><span>Set-Alias umount-jonpark Dismount-JonparkDrive
</span></span><span style=display:flex><span>Set-Alias check-mounts Check-MountedDrives
</span></span></code></pre></div><hr><h3 id=-적용-방법><strong>🚀 적용 방법</strong><a hidden class=anchor aria-hidden=true href=#-적용-방법>#</a></h3><ol><li><p><strong>PowerShell에서 스크립트 실행</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Mount-JonparkDrive
</span></span></code></pre></div><p>✅ <code>Successfully mounted drive J:</code>가 나오고, 이후 <code>Test-Path</code> 검사에서 드라이브가 정상적으로 인식되는지 확인.</p></li><li><p><strong>마운트 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>check-mounts
</span></span></code></pre></div><p>✅ <code>J:</code> 드라이브가 정상적으로 표시되는지 확인.</p></li><li><p><strong>언마운트 실행</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>umount-jonpark
</span></span></code></pre></div><p>✅ <code>Successfully dismounted drive J:</code>가 출력되면 정상적으로 해제된 것.</p></li></ol><hr><h3 id=-추가-해결책-sshfs-안정성-문제-발생-시><strong>📌 추가 해결책 (SSHFS 안정성 문제 발생 시)</strong><a hidden class=anchor aria-hidden=true href=#-추가-해결책-sshfs-안정성-문제-발생-시>#</a></h3><p>만약 여전히 마운트 문제가 있다면, SSHFS-Win을 <code>subst</code> 명령어와 함께 실행하여 드라이브를 강제로 로컬 드라이브처럼 인식시킬 수도 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>subst J: <span style=color:#e6db74>&#34;\\sshfs\jonpark@aws-sig-ts-jonpark.aws.internal\&#34;</span>
</span></span></code></pre></div><p>이 방법을 사용하면 Windows 탐색기에서도 SSHFS 드라이브가 정상적으로 표시될 가능성이 높습니다.</p><hr><h3 id=-결론-1><strong>💡 결론</strong><a hidden class=anchor aria-hidden=true href=#-결론-1>#</a></h3><ol><li><strong>기존 방식에서 SSHFS가 정상적으로 마운트되지 않던 문제 해결</strong></li><li><strong>마운트 확인을 위한 추가 검사 (<code>Test-Path</code> 활용)</strong></li><li><strong>SSHFS 프로세스가 실행 중인지 확인하고, <code>subst</code> 활용 가능성 추가</strong></li><li><strong>실제 마운트 확인을 위한 <code>check-mounts</code> 기능 추가</strong></li></ol><p>이제 SSHFS 드라이브가 정상적으로 표시되고, 필요할 때 마운트 및 해제가 가능할 거예요! 🚀</p><hr><h1 id=윈도우에서는-아래처럼-ryanpark-계정을-사용하고-마운트-할려고-하는-것은-ec2-ubuntu-instance-이고-이때-jonpark-계정을-사용>윈도우에서는 아래처럼 RyanPark 계정을 사용하고 마운트 할려고 하는 것은 ec2 ubuntu instance 이고 이때 jonpark 계정을 사용<a hidden class=anchor aria-hidden=true href=#윈도우에서는-아래처럼-ryanpark-계정을-사용하고-마운트-할려고-하는-것은-ec2-ubuntu-instance-이고-이때-jonpark-계정을-사용>#</a></h1><p>현재 Windows에서 <code>RyanPark</code> 계정으로 실행하며, <strong>EC2 Ubuntu 인스턴스의 <code>jonpark</code> 계정</strong>을 사용하여 SSHFS로 마운트하려고 하는 것이군요. 이를 고려하여 <strong>Windows 환경에서 SSHFS 마운트가 정상적으로 작동하도록 수정</strong>하겠습니다.</p><hr><h3 id=-수정된-powershell-스크립트-1><strong>🚀 수정된 PowerShell 스크립트</strong><a hidden class=anchor aria-hidden=true href=#-수정된-powershell-스크립트-1>#</a></h3><ul><li>Windows의 <code>RyanPark</code> 계정에서 실행</li><li><strong>EC2 Ubuntu 인스턴스의 <code>jonpark</code> 계정으로 SSHFS 마운트</strong></li><li><strong>마운트 성공 여부를 확실하게 확인</strong></li><li><strong>네트워크 드라이브처럼 보이도록 설정</strong></li><li><strong>자동 재연결을 위한 옵션 추가</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#66d9ef>function</span> Mount-JonparkDrive {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>param</span>(
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$DriveLetter = <span style=color:#e6db74>&#34;J&#34;</span>,
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$RemoteHost = <span style=color:#e6db74>&#34;aws-sig-ts-jonpark.aws.internal&#34;</span>,
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$RemoteUser = <span style=color:#e6db74>&#34;jonpark&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e># SSHFS가 설치되어 있는지 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-not</span> (Get-Command sshfs -ErrorAction SilentlyContinue)) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Error: sshfs is not installed or not in PATH.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 이미 마운트된 경우 방지</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Drive </span>${DriveLetter}<span style=color:#e6db74>: is already mounted.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># SSH 키를 사용하여 비밀번호 입력 없이 마운트 가능하도록 설정</span>
</span></span><span style=display:flex><span>        $RemotePath = <span style=color:#e6db74>&#34;</span>$RemoteUser<span style=color:#e6db74>@</span>$RemoteHost<span style=color:#e6db74>:/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># SSHFS 마운트 실행</span>
</span></span><span style=display:flex><span>        sshfs $RemotePath <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span> -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks -o reconnect
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Start-Sleep -Seconds <span style=color:#ae81ff>2</span>  <span style=color:#75715e># 마운트 안정화 대기</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 마운트 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Successfully mounted drive </span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Error: Drive </span>${DriveLetter}<span style=color:#e6db74>: was not mounted successfully.&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Error mounting drive: </span>$_<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> Dismount-JonparkDrive {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>param</span>(
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>string</span>]$DriveLetter = <span style=color:#e6db74>&#34;J&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e># 드라이브가 실제로 존재하는지 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-not</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>)) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Drive </span>${DriveLetter}<span style=color:#e6db74>: is not mounted.&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># SSHFS 드라이브 언마운트</span>
</span></span><span style=display:flex><span>        net use <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span> /delete /y <span style=color:#ae81ff>2</span>&gt;$null
</span></span><span style=display:flex><span>        Start-Sleep -Seconds <span style=color:#ae81ff>2</span>  <span style=color:#75715e># 마운트 해제 시간 확보</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 언마운트 확인</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-not</span> (Test-Path <span style=color:#e6db74>&#34;</span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>)) {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Successfully dismounted drive </span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Write-Host <span style=color:#e6db74>&#34;Error: Failed to unmount drive </span>${DriveLetter}<span style=color:#e6db74>:&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Error dismounting drive: </span>$_<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> Check-MountedDrives {
</span></span><span style=display:flex><span>    <span style=color:#75715e># 현재 마운트된 드라이브 확인</span>
</span></span><span style=display:flex><span>    Get-PSDrive -PSProvider FileSystem
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Set-Alias mount-jonpark Mount-JonparkDrive
</span></span><span style=display:flex><span>Set-Alias umount-jonpark Dismount-JonparkDrive
</span></span><span style=display:flex><span>Set-Alias check-mounts Check-MountedDrives
</span></span></code></pre></div><hr><h3 id=-주요-개선-사항><strong>🔹 주요 개선 사항</strong><a hidden class=anchor aria-hidden=true href=#-주요-개선-사항>#</a></h3><ol><li><strong>Windows에서 <code>RyanPark</code> 계정이 실행하지만, EC2 Ubuntu에서는 <code>jonpark</code> 계정을 사용</strong></li><li><strong>SSHFS가 정상적으로 마운트되는지 <code>Test-Path</code>로 확인</strong></li><li><strong>SSH 키를 사용하여 비밀번호 입력 없이 마운트하도록 개선</strong></li><li><strong><code>-o reconnect</code> 옵션 추가 → SSH 연결이 끊어져도 자동 복구</strong></li><li><strong><code>check-mounts</code> 명령어로 현재 마운트된 드라이브 확인 가능</strong></li></ol><hr><h3 id=-사용-방법><strong>🚀 사용 방법</strong><a hidden class=anchor aria-hidden=true href=#-사용-방법>#</a></h3><h4 id=1-마운트-실행><strong>1️⃣ 마운트 실행</strong><a hidden class=anchor aria-hidden=true href=#1-마운트-실행>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>mount-jonpark
</span></span></code></pre></div><p>✅ <code>Successfully mounted drive J:</code>가 나오면 성공</p><h4 id=2-마운트-확인><strong>2️⃣ 마운트 확인</strong><a hidden class=anchor aria-hidden=true href=#2-마운트-확인>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>check-mounts
</span></span></code></pre></div><p>✅ <code>J:</code> 드라이브가 정상적으로 표시되는지 확인</p><h4 id=3-언마운트-실행><strong>3️⃣ 언마운트 실행</strong><a hidden class=anchor aria-hidden=true href=#3-언마운트-실행>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>umount-jonpark
</span></span></code></pre></div><p>✅ <code>Successfully dismounted drive J:</code>가 출력되면 정상적으로 해제됨.</p><hr><h3 id=-추가-해결책-ssh-키로-인증><strong>🔍 추가 해결책 (SSH 키로 인증)</strong><a hidden class=anchor aria-hidden=true href=#-추가-해결책-ssh-키로-인증>#</a></h3><p>현재 SSHFS 마운트 시 <strong>비밀번호 입력을 요구</strong>하는데, 이를 <strong>SSH 키로 자동 인증</strong>하도록 설정하면 편리합니다.</p><ol><li><strong>Windows에서 SSH 키 생성</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>ssh-keygen -t rsa -b <span style=color:#ae81ff>4096</span> <span style=color:#f92672>-f</span> C:\Users\RyanPark\.ssh\id_rsa
</span></span></code></pre></div></li><li><strong>EC2 Ubuntu 서버에 공개 키 추가</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>600</span> ~/.ssh/authorized_keys
</span></span></code></pre></div></li><li><strong>SSHFS 마운트 시 SSH 키를 사용하도록 수정</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/ J: -o IdentityFile=C:\Users\RyanPark\.ssh\id_rsa -o reconnect
</span></span></code></pre></div></li></ol><p>✅ 이렇게 하면 비밀번호 없이 자동 마운트 가능</p><hr><p>이제 <strong>RyanPark 계정에서 실행하면서 EC2 Ubuntu 인스턴스의 <code>jonpark</code> 계정으로 SSHFS를 사용</strong>할 수 있습니다! 🚀</p><hr><h1 id=update-env-함수가-기대한-대로-동작하지-않는-이유>update-env 함수가 기대한 대로 동작하지 않는 이유<a hidden class=anchor aria-hidden=true href=#update-env-함수가-기대한-대로-동작하지-않는-이유>#</a></h1><p>현재 <code>update-env</code> 함수가 기대한 대로 동작하지 않는 이유는 <strong>PowerShell 세션 내에서만 환경 변수를 변경</strong>하기 때문입니다. 이 문제를 해결하기 위해 다음과 같은 방식으로 수정하겠습니다.</p><hr><h3 id=-문제점><strong>🔹 문제점</strong><a hidden class=anchor aria-hidden=true href=#-문제점>#</a></h3><ul><li><code>$env:Path</code> 값을 변경하는 것만으로는 새로 추가된 환경 변수를 즉시 반영하지 않음.</li><li>PowerShell 세션을 다시 열어야 변경 사항이 적용됨.</li><li>VS Code의 PowerShell 터미널에서는 환경 변수 업데이트가 원활하지 않을 수 있음.</li></ul><hr><h3 id=-수정된-update-env-함수><strong>✅ 수정된 <code>update-env</code> 함수</strong><a hidden class=anchor aria-hidden=true href=#-수정된-update-env-함수>#</a></h3><p>아래 코드에서는 <strong>레지스트리에서 최신 환경 변수를 가져와 즉시 PowerShell 세션에 반영</strong>하도록 개선했습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#66d9ef>function</span> update-env {
</span></span><span style=display:flex><span>    <span style=color:#75715e># 사용자 및 시스템 환경 변수 가져오기</span>
</span></span><span style=display:flex><span>    $UserPath = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>)
</span></span><span style=display:flex><span>    $MachinePath = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;Machine&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 현재 세션의 Path 환경 변수 업데이트</span>
</span></span><span style=display:flex><span>    $env:Path = <span style=color:#e6db74>&#34;</span>$MachinePath<span style=color:#e6db74>;</span>$UserPath<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 새 환경 변수 즉시 반영</span>
</span></span><span style=display:flex><span>    &amp; refreshenv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Write-Host <span style=color:#e6db74>&#34;Environment variables updated successfully.&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=-개선된-기능><strong>🚀 개선된 기능</strong><a hidden class=anchor aria-hidden=true href=#-개선된-기능>#</a></h3><ol><li><strong><code>$env:Path</code>를 시스템(<code>Machine</code>) 및 사용자(<code>User</code>) 환경 변수로 즉시 업데이트</strong></li><li><strong><code>refreshenv</code> 실행으로 환경 변수 즉시 반영</strong><ul><li><code>refreshenv</code>는 Chocolatey가 제공하는 명령어지만, 일반적으로 동작 가능.</li><li>만약 Chocolatey가 없다면 아래 방법을 사용.</li></ul></li></ol><hr><h3 id=-refreshenv-없이-환경-변수-강제-업데이트-방법><strong>🔹 <code>refreshenv</code> 없이 환경 변수 강제 업데이트 방법</strong><a hidden class=anchor aria-hidden=true href=#-refreshenv-없이-환경-변수-강제-업데이트-방법>#</a></h3><p>만약 Chocolatey가 설치되지 않았다면 <code>refreshenv</code> 대신 <strong>레지스트리에서 직접 업데이트</strong>하는 방법을 사용할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#66d9ef>function</span> update-env {
</span></span><span style=display:flex><span>    <span style=color:#75715e># 사용자 및 시스템 환경 변수 가져오기</span>
</span></span><span style=display:flex><span>    $UserPath = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>)
</span></span><span style=display:flex><span>    $MachinePath = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;Machine&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 현재 세션의 Path 환경 변수 업데이트</span>
</span></span><span style=display:flex><span>    $env:Path = <span style=color:#e6db74>&#34;</span>$MachinePath<span style=color:#e6db74>;</span>$UserPath<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Windows 탐색기(Explorer) 프로세스를 재시작하여 환경 변수 즉시 반영</span>
</span></span><span style=display:flex><span>    Stop-Process -Name explorer -Force -ErrorAction SilentlyContinue
</span></span><span style=display:flex><span>    Start-Process explorer.exe
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Write-Host <span style=color:#e6db74>&#34;Environment variables updated successfully. If changes are not reflected, try restarting PowerShell.&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>✅ <strong>이제 <code>update-env</code>를 실행하면 변경된 환경 변수가 즉시 반영됩니다!</strong> 🚀</p><hr><h1 id=profile-을-수정했는데-현재-동작중인-powershell-에서-바로-적용시키는-방법>profile 을 수정했는데 현재 동작중인 powershell 에서 바로 적용시키는 방법<a hidden class=anchor aria-hidden=true href=#profile-을-수정했는데-현재-동작중인-powershell-에서-바로-적용시키는-방법>#</a></h1><p>PowerShell 프로파일을 수정한 후, <strong>현재 실행 중인 PowerShell 세션에서 즉시 적용하는 방법</strong>은 다음과 같습니다.</p><hr><h3 id=-1-프로파일-파일-즉시-로드하기><strong>✅ 1. 프로파일 파일 즉시 로드하기</strong><a hidden class=anchor aria-hidden=true href=#-1-프로파일-파일-즉시-로드하기>#</a></h3><p>PowerShell 프로파일을 수정한 후, 아래 명령어를 실행하면 현재 세션에서 바로 적용됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>. $PROFILE
</span></span></code></pre></div><p>✅ <strong>설명</strong></p><ul><li><code>$PROFILE</code> 변수는 현재 사용자의 PowerShell 프로파일 파일 경로를 가리킵니다.</li><li><code>.</code> (dot-source) 연산자를 사용하면 해당 파일을 현재 세션에 즉시 적용할 수 있습니다.</li></ul><p>📌 <strong>예제</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>notepad $PROFILE  <span style=color:#75715e># 프로파일 파일을 편집</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 수정 후 저장한 다음, 아래 명령어 실행</span>
</span></span><span style=display:flex><span>. $PROFILE        <span style=color:#75715e># 변경 사항을 즉시 반영</span>
</span></span></code></pre></div><hr><h3 id=-2-모든-프로파일-파일-로드-관리자일반-사용자-구분><strong>✅ 2. 모든 프로파일 파일 로드 (관리자/일반 사용자 구분)</strong><a hidden class=anchor aria-hidden=true href=#-2-모든-프로파일-파일-로드-관리자일반-사용자-구분>#</a></h3><p>PowerShell에는 여러 개의 프로파일 파일이 있을 수 있습니다. 모든 프로파일 파일을 즉시 로드하려면:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$profiles = @(
</span></span><span style=display:flex><span>    $PROFILE,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;</span>$($PROFILE.AllUsersAllHosts)<span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;</span>$($PROFILE.AllUsersCurrentHost)<span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;</span>$($PROFILE.CurrentUserAllHosts)<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> ($p <span style=color:#66d9ef>in</span> $profiles) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Test-Path $p) {
</span></span><span style=display:flex><span>        . $p
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Loaded: </span>$p<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>✅ <strong>이 코드가 필요한 경우</strong></p><ul><li>시스템 전체(<code>AllUsers</code>) 또는 특정 사용자(<code>CurrentUser</code>) 설정을 즉시 반영하려는 경우.</li><li>여러 PowerShell 호스트(VS Code, Windows Terminal 등)에서 동작하는 프로파일을 적용하려는 경우.</li></ul><hr><h3 id=-3-powershell-환경-변수-강제-업데이트-update-env-개선><strong>✅ 3. PowerShell 환경 변수 강제 업데이트 (<code>update-env</code> 개선)</strong><a hidden class=anchor aria-hidden=true href=#-3-powershell-환경-변수-강제-업데이트-update-env-개선>#</a></h3><p>만약 프로파일에서 <strong>환경 변수(Path 등)가 변경되었다면</strong>, 아래 명령어를 추가 실행해야 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$env:Path = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;Machine&#34;</span>) + <span style=color:#e6db74>&#34;;&#34;</span> + [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>)
</span></span></code></pre></div><hr><h3 id=-4-새로운-powershell-세션을-자동으로-다시-시작><strong>✅ 4. 새로운 PowerShell 세션을 자동으로 다시 시작</strong><a hidden class=anchor aria-hidden=true href=#-4-새로운-powershell-세션을-자동으로-다시-시작>#</a></h3><p>만약 <strong>프로파일 변경 후 PowerShell을 새로 시작해야 하는 경우</strong>, 아래 명령어를 실행하면 현재 세션을 종료하고 새 창을 띄울 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Start-Process pwsh -Verb RunAs; exit  <span style=color:#75715e># PowerShell 7+</span>
</span></span><span style=display:flex><span>Start-Process powershell -Verb RunAs; exit  <span style=color:#75715e># Windows PowerShell (5.x)</span>
</span></span></code></pre></div><hr><h3 id=-결론-2><strong>🚀 결론</strong><a hidden class=anchor aria-hidden=true href=#-결론-2>#</a></h3><ul><li><strong>프로파일 즉시 적용:</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>. $PROFILE
</span></span></code></pre></div></li><li><strong>모든 프로파일 즉시 적용:</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#66d9ef>foreach</span> ($p <span style=color:#66d9ef>in</span> $profiles) { <span style=color:#66d9ef>if</span> (Test-Path $p) { . $p; Write-Host <span style=color:#e6db74>&#34;Loaded: </span>$p<span style=color:#e6db74>&#34;</span> } }
</span></span></code></pre></div></li><li><strong>환경 변수 즉시 반영:</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$env:Path = [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;Machine&#34;</span>) + <span style=color:#e6db74>&#34;;&#34;</span> + [<span style=color:#66d9ef>System.Environment</span>]::GetEnvironmentVariable(<span style=color:#e6db74>&#34;Path&#34;</span>, <span style=color:#e6db74>&#34;User&#34;</span>)
</span></span></code></pre></div></li><li><strong>PowerShell 새로 시작 (필요한 경우)</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Start-Process powershell -Verb RunAs; exit
</span></span></code></pre></div></li></ul><p>✅ <strong>이제 프로파일을 수정한 후 위 명령어를 실행하면 PowerShell을 다시 시작하지 않고도 변경 사항이 즉시 반영됩니다!</strong> 🚀</p><hr><h1 id=profileps1의-역할>profile.ps1의 역할<a hidden class=anchor aria-hidden=true href=#profileps1의-역할>#</a></h1><p><code>C:\Users\RyanPark\OneDrive - Black Duck Software\Documents\WindowsPowerShell\profile.ps1</code> 경로는 <strong>PowerShell 프로파일 파일</strong>에 해당합니다.</p><hr><h3 id=-profileps1의-역할><strong>✅ <code>profile.ps1</code>의 역할</strong><a hidden class=anchor aria-hidden=true href=#-profileps1의-역할>#</a></h3><p>PowerShell 프로파일은 PowerShell이 시작될 때 자동으로 실행되는 스크립트 파일로, <strong>사용자 맞춤 설정</strong>을 저장하는 역할을 합니다.</p><h4 id=1-해당-프로파일이-적용되는-범위><strong>1️⃣ 해당 프로파일이 적용되는 범위</strong><a hidden class=anchor aria-hidden=true href=#1-해당-프로파일이-적용되는-범위>#</a></h4><ul><li>경로에 <code>WindowsPowerShell</code>이 포함되어 있으므로, <strong>Windows PowerShell 5.x</strong>(기본 PowerShell)에서 실행됩니다.</li><li><strong>PowerShell 7+ (<code>pwsh</code>)에서는 적용되지 않습니다.</strong></li><li><strong>사용자별 프로파일</strong>로, <code>RyanPark</code> 계정에서만 동작합니다.</li><li>만약 PowerShell이 <code>OneDrive</code> 동기화 설정을 따르고 있다면, OneDrive가 완전히 로드된 후에만 정상적으로 실행될 수도 있습니다.</li></ul><h4 id=2-프로파일-즉시-적용-방법><strong>2️⃣ 프로파일 즉시 적용 방법</strong><a hidden class=anchor aria-hidden=true href=#2-프로파일-즉시-적용-방법>#</a></h4><p>프로파일을 수정한 후, 아래 명령어를 실행하면 <strong>PowerShell을 재시작하지 않고도 변경 사항이 즉시 반영됩니다.</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>. $PROFILE
</span></span></code></pre></div><p>✅ 이 명령어는 <code>$PROFILE</code> 변수를 사용하여 현재 프로파일 파일을 다시 로드합니다.</p><p>📌 <strong>직접 파일 경로를 지정하여 로드하는 방법 (동일 효과)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>. <span style=color:#e6db74>&#34;C:\Users\RyanPark\OneDrive - Black Duck Software\Documents\WindowsPowerShell\profile.ps1&#34;</span>
</span></span></code></pre></div><hr><h3 id=-프로파일의-종류-powershell-버전-및-범위별><strong>✅ 프로파일의 종류 (PowerShell 버전 및 범위별)</strong><a hidden class=anchor aria-hidden=true href=#-프로파일의-종류-powershell-버전-및-범위별>#</a></h3><p>PowerShell 프로파일은 4가지 유형이 있으며, 현재 사용 중인 것은 <strong>사용자별 PowerShell 5.x 프로파일</strong>입니다.</p><table><thead><tr><th>프로파일 경로</th><th>적용 대상</th><th>설명</th></tr></thead><tbody><tr><td><strong><code>$PROFILE</code></strong></td><td>현재 사용자</td><td>사용자가 실행한 PowerShell에만 적용</td></tr><tr><td><strong><code>$PROFILE.CurrentUserAllHosts</code></strong></td><td>현재 사용자</td><td>모든 PowerShell 호스트(VS Code, ISE 등)에 적용</td></tr><tr><td><strong><code>$PROFILE.AllUsersCurrentHost</code></strong></td><td>모든 사용자</td><td>현재 PowerShell 호스트에서 모든 사용자에게 적용</td></tr><tr><td><strong><code>$PROFILE.AllUsersAllHosts</code></strong></td><td>모든 사용자</td><td>시스템 전체에서 모든 PowerShell 실행 시 적용</td></tr></tbody></table><p>📌 <strong>현재 적용된 프로파일 경로 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$PROFILE
</span></span></code></pre></div><p>📌 <strong>모든 프로파일 경로 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$PROFILE | Format-List *
</span></span></code></pre></div><hr><h3 id=-powershell-7에서-동일한-프로파일을-적용하려면><strong>✅ PowerShell 7+에서 동일한 프로파일을 적용하려면?</strong><a hidden class=anchor aria-hidden=true href=#-powershell-7에서-동일한-프로파일을-적용하려면>#</a></h3><p>PowerShell 7 (<code>pwsh</code>)에서는 프로파일 경로가 다릅니다.<br>만약 PowerShell 7에서 동일한 설정을 사용하려면, 아래 경로의 <code>profile.ps1</code>에도 같은 내용을 추가해야 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>C:\Users\RyanPark\Documents\PowerShell\profile.ps1
</span></span></code></pre></div><p>✅ PowerShell 7 프로파일을 즉시 로드하려면:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>. <span style=color:#e6db74>&#34;</span>$HOME<span style=color:#e6db74>\Documents\PowerShell\profile.ps1&#34;</span>
</span></span></code></pre></div><hr><h3 id=-결론-3><strong>🚀 결론</strong><a hidden class=anchor aria-hidden=true href=#-결론-3>#</a></h3><ol><li><p><strong>현재 <code>profile.ps1</code> 파일은 Windows PowerShell(5.x)에 적용됨</strong><br>✅ 즉시 적용하려면:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>. $PROFILE
</span></span></code></pre></div></li><li><p><strong>PowerShell 7+(<code>pwsh</code>)에서는 다른 프로파일 경로를 사용함</strong><br>✅ PowerShell 7에서 동일한 설정을 사용하려면, <code>C:\Users\RyanPark\Documents\PowerShell\profile.ps1</code>을 수정해야 함.</p></li><li><p><strong>VS Code, Windows Terminal 등에서 동일한 프로파일을 적용하려면</strong><br>✅ <code>AllHosts</code> 프로파일 (<code>$PROFILE.CurrentUserAllHosts</code>)을 수정하는 것이 더 유용할 수 있음.</p></li></ol><p>이제 프로파일이 정상적으로 반영될 것입니다! 🚀</p><hr><h1 id=profile-종류>PROFILE 종류<a hidden class=anchor aria-hidden=true href=#profile-종류>#</a></h1><p>PowerShell에는 여러 개의 <code>profile.ps1</code> 파일이 존재할 수 있으며, 각각 적용되는 범위가 다릅니다.</p><p>아래 명령어를 실행하면 현재 시스템에서 사용 가능한 모든 PowerShell 프로파일 경로를 확인할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$PROFILE | Format-List *
</span></span></code></pre></div><p>✅ <strong>출력 예시 (PowerShell 5.x)</strong></p><pre tabindex=0><code>AllUsersAllHosts       : C:\Windows\System32\WindowsPowerShell\v1.0\profile.ps1
AllUsersCurrentHost    : C:\Windows\System32\WindowsPowerShell\v1.0\Microsoft.PowerShell_profile.ps1
CurrentUserAllHosts    : C:\Users\RyanPark\Documents\WindowsPowerShell\profile.ps1
CurrentUserCurrentHost : C:\Users\RyanPark\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
</code></pre><p>✅ <strong>출력 예시 (PowerShell 7+)</strong></p><pre tabindex=0><code>AllUsersAllHosts       : C:\Program Files\PowerShell\7\profile.ps1
AllUsersCurrentHost    : C:\Program Files\PowerShell\7\Microsoft.PowerShell_profile.ps1
CurrentUserAllHosts    : C:\Users\RyanPark\Documents\PowerShell\profile.ps1
CurrentUserCurrentHost : C:\Users\RyanPark\Documents\PowerShell\Microsoft.PowerShell_profile.ps1
</code></pre><hr><h3 id=-프로파일-설명><strong>🔹 프로파일 설명</strong><a hidden class=anchor aria-hidden=true href=#-프로파일-설명>#</a></h3><table><thead><tr><th>프로파일 경로</th><th>적용 대상</th><th>설명</th></tr></thead><tbody><tr><td><strong><code>$PROFILE.AllUsersAllHosts</code></strong></td><td>모든 사용자</td><td>모든 PowerShell 실행 시 적용</td></tr><tr><td><strong><code>$PROFILE.AllUsersCurrentHost</code></strong></td><td>모든 사용자</td><td>특정 PowerShell 호스트 (예: VS Code, Windows Terminal 등)에만 적용</td></tr><tr><td><strong><code>$PROFILE.CurrentUserAllHosts</code></strong></td><td>현재 사용자</td><td>모든 PowerShell 실행 시 적용</td></tr><tr><td><strong><code>$PROFILE.CurrentUserCurrentHost</code></strong></td><td>현재 사용자</td><td>특정 PowerShell 호스트에서만 적용</td></tr></tbody></table><hr><h3 id=-프로파일을-확인하는-명령어><strong>🔍 프로파일을 확인하는 명령어</strong><a hidden class=anchor aria-hidden=true href=#-프로파일을-확인하는-명령어>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#75715e># 현재 사용자에게 적용되는 프로파일 확인</span>
</span></span><span style=display:flex><span>Write-Host <span style=color:#e6db74>&#34;Current User - All Hosts: </span>$($PROFILE.CurrentUserAllHosts)<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>Write-Host <span style=color:#e6db74>&#34;Current User - Current Host: </span>$($PROFILE.CurrentUserCurrentHost)<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 모든 사용자에게 적용되는 프로파일 확인</span>
</span></span><span style=display:flex><span>Write-Host <span style=color:#e6db74>&#34;All Users - All Hosts: </span>$($PROFILE.AllUsersAllHosts)<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>Write-Host <span style=color:#e6db74>&#34;All Users - Current Host: </span>$($PROFILE.AllUsersCurrentHost)<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>✅ 위 명령어를 실행하면 현재 사용 가능한 모든 프로파일 파일 경로가 출력됩니다.</p><hr><h3 id=-결론-4><strong>🚀 결론</strong><a hidden class=anchor aria-hidden=true href=#-결론-4>#</a></h3><ul><li><p><strong>PowerShell 5.x에서는</strong><br><code>C:\Users\RyanPark\Documents\WindowsPowerShell\profile.ps1</code><br>→ 모든 PowerShell 실행 시 적용됨.</p></li><li><p><strong>PowerShell 7+에서는</strong><br><code>C:\Users\RyanPark\Documents\PowerShell\profile.ps1</code><br>→ 모든 PowerShell 실행 시 적용됨.</p></li><li><p><strong>VS Code, Windows Terminal 등 특정 호스트에서만 적용하려면</strong><br><code>Microsoft.PowerShell_profile.ps1</code>을 수정해야 함.</p></li></ul><p>이제 <strong>어떤 프로파일을 수정해야 할지</strong> 명확하게 알 수 있을 거예요! 🚀</p><hr><h1 id=sshfs--connection-reset-by-peer>sshfs : Connection reset by peer<a hidden class=anchor aria-hidden=true href=#sshfs--connection-reset-by-peer>#</a></h1><p>현재 <code>mount-jonpark</code> 실행 시 <strong>&ldquo;Connection reset by peer&rdquo;</strong> 오류가 발생하고 있으며, 드라이브가 정상적으로 마운트되지 않는 문제가 있습니다. 이 문제를 디버깅하는 방법을 단계별로 정리해드리겠습니다.</p><hr><h2 id=1-ssh-연결-확인><strong>1️⃣ SSH 연결 확인</strong><a hidden class=anchor aria-hidden=true href=#1-ssh-연결-확인>#</a></h2><p>먼저 SSHFS를 사용하려면 <strong>기본적으로 SSH 연결이 가능해야 합니다.</strong><br>PowerShell에서 <strong>SSH 연결이 정상적으로 작동하는지</strong> 확인하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>ssh jonpark@aws-sig-ts-jonpark.aws.internal
</span></span></code></pre></div><p>✅ <strong>정상적인 경우</strong></p><ul><li>비밀번호 입력 후 SSH 로그인 성공.</li></ul><p>🚨 <strong>오류 발생 시</strong></p><ul><li><code>"Connection reset by peer"</code> → 원격 서버 문제(SSH 서비스 중단, 방화벽 차단 등)</li><li><code>"Permission denied"</code> → 키 인증 문제 또는 계정 권한 부족</li></ul><p>📌 <strong>SSH 연결이 안 될 경우 해결 방법</strong></p><ul><li>원격 서버에서 SSH 서비스 실행 확인:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo systemctl status ssh
</span></span></code></pre></div></li><li>SSH 포트가 열려 있는지 확인:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo netstat -tulnp | grep ssh
</span></span></code></pre></div></li><li>방화벽(EC2 보안 그룹 포함) 설정 확인:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo ufw status
</span></span></code></pre></div></li></ul><hr><h2 id=2-sshfs가-정상적으로-동작하는지-확인><strong>2️⃣ SSHFS가 정상적으로 동작하는지 확인</strong><a hidden class=anchor aria-hidden=true href=#2-sshfs가-정상적으로-동작하는지-확인>#</a></h2><p>SSHFS 명령어를 수동으로 실행하여 <strong>PowerShell 스크립트 없이 수동 마운트가 가능한지 확인</strong>합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/ J: -o debug
</span></span></code></pre></div><p>✅ <strong>정상적인 경우</strong></p><ul><li>드라이브가 <code>J:</code>로 마운트됨.</li></ul><p>🚨 <strong>에러 발생 시</strong></p><ul><li><code>"Connection reset by peer"</code> → 원격 서버 문제 가능성.</li><li><code>"Read-only file system"</code> → 파일 시스템 문제.</li><li><code>"Transport endpoint is not connected"</code> → SSHFS 프로세스 충돌 가능성.</li></ul><p>📌 <strong>디버깅 옵션 추가 실행</strong>
만약 위 명령어가 정상 작동하지 않는다면, 더 많은 디버깅 정보를 얻기 위해 아래와 같이 실행하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/ J: -o sshfs_debug -o loglevel=debug
</span></span></code></pre></div><p>🚨 <strong>디버깅 로그에서 확인해야 할 부분</strong></p><ul><li><code>"Connection reset by peer"</code> → 서버 문제 가능성이 큼.</li><li><code>"Bad owner or permissions"</code> → 원격 서버의 파일 권한 문제.</li></ul><hr><h2 id=3-sshfs-로그-확인><strong>3️⃣ SSHFS 로그 확인</strong><a hidden class=anchor aria-hidden=true href=#3-sshfs-로그-확인>#</a></h2><p>만약 <code>sshfs</code> 명령어가 실행되었는데도 실패한다면, SSHFS가 남긴 로그를 확인해야 합니다.</p><p>🔹 <strong>Windows에서 SSHFS 로그 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-Content C:\Windows\Temp\sshfs.log -Tail <span style=color:#ae81ff>50</span>
</span></span></code></pre></div><p>🔹 <strong>Linux(EC2)에서 SSH 로그 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo journalctl -u ssh -n <span style=color:#ae81ff>50</span>
</span></span></code></pre></div><p>🚨 <strong>주요 에러 예시</strong></p><ul><li><code>"Connection reset by peer"</code> → 네트워크 문제 가능성.</li><li><code>"Permission denied"</code> → SSH 키 인증 또는 계정 문제.</li></ul><hr><h2 id=4-마운트-상태-확인><strong>4️⃣ 마운트 상태 확인</strong><a hidden class=anchor aria-hidden=true href=#4-마운트-상태-확인>#</a></h2><p>PowerShell에서 <code>J:</code> 드라이브가 인식되는지 확인하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div><p>또는 <strong>Windows 네트워크 드라이브 목록 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>net use
</span></span></code></pre></div><p>🚨 <strong>드라이브가 보이지 않는다면?</strong></p><ul><li>SSHFS가 정상적으로 실행되지 않았을 가능성이 큼.</li><li>기존 SSHFS 마운트가 충돌하고 있을 수도 있음.</li></ul><p>✅ <strong>모든 SSHFS 마운트 해제 후 다시 시도</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>net use J: /delete /y
</span></span></code></pre></div><hr><h2 id=5-powershell-스크립트-디버깅-모드-실행><strong>5️⃣ PowerShell 스크립트 디버깅 모드 실행</strong><a hidden class=anchor aria-hidden=true href=#5-powershell-스크립트-디버깅-모드-실행>#</a></h2><p>PowerShell에서 <strong>디버깅 모드를 활성화</strong>하면 스크립트 실행 중 어디에서 오류가 발생하는지 더 자세한 정보를 얻을 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Set-PSDebug -Trace <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>mount-jonpark
</span></span><span style=display:flex><span>Set-PSDebug -Trace <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>✅ <strong>출력에서 <code>sshfs</code> 명령어 실행 위치를 확인</strong>하고, 해당 명령어를 수동으로 실행해봅니다.</p><hr><h2 id=-결론-순서대로-디버깅><strong>🚀 결론 (순서대로 디버깅)</strong><a hidden class=anchor aria-hidden=true href=#-결론-순서대로-디버깅>#</a></h2><ol><li><p><strong>SSH 연결 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>ssh jonpark@aws-sig-ts-jonpark.aws.internal
</span></span></code></pre></div><ul><li>안 되면 원격 서버에서 SSH 서비스, 방화벽, 보안 그룹 확인.</li></ul></li><li><p><strong>SSHFS 수동 마운트 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/ J: -o debug
</span></span></code></pre></div><ul><li>실패하면 <code>-o sshfs_debug -o loglevel=debug</code> 옵션 추가.</li></ul></li><li><p><strong>SSHFS 로그 확인</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-Content C:\Windows\Temp\sshfs.log -Tail <span style=color:#ae81ff>50</span>
</span></span></code></pre></div></li><li><p><strong>PowerShell 디버깅 활성화 후 실행</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Set-PSDebug -Trace <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>mount-jonpark
</span></span><span style=display:flex><span>Set-PSDebug -Trace <span style=color:#ae81ff>0</span>
</span></span></code></pre></div></li></ol><h2 id=이제-위-단계를-차례대로-실행하면-문제의-원인을-정확하게-파악할-수-있습니다->이제 위 단계를 차례대로 실행하면 <strong>문제의 원인을 정확하게 파악할 수 있습니다.</strong> 🚀<a hidden class=anchor aria-hidden=true href=#이제-위-단계를-차례대로-실행하면-문제의-원인을-정확하게-파악할-수-있습니다->#</a></h2><h1 id=remote-directory가-homejonpark이-아닐-가능성>Remote Directory가 /home/jonpark이 아닐 가능성<a hidden class=anchor aria-hidden=true href=#remote-directory가-homejonpark이-아닐-가능성>#</a></h1><h3 id=-문제-원인-remote-directory가-homejonpark이-아닐-가능성><strong>🔍 문제 원인: Remote Directory가 <code>/home/jonpark</code>이 아닐 가능성</strong><a hidden class=anchor aria-hidden=true href=#-문제-원인-remote-directory가-homejonpark이-아닐-가능성>#</a></h3><p>SSH 접속은 정상적으로 이루어지지만, SSHFS 마운트 시 <code>bad mount point J: No such file or directory</code> 오류가 발생하고 있습니다.<br>이 오류는 보통 <strong>원격 디렉터리가 존재하지 않거나, 접근 권한이 없을 때 발생</strong>합니다.</p><hr><h3 id=-해결-방법-1-원격-서버에서-기본-홈-디렉터리-확인><strong>✅ 해결 방법 1: 원격 서버에서 기본 홈 디렉터리 확인</strong><a hidden class=anchor aria-hidden=true href=#-해결-방법-1-원격-서버에서-기본-홈-디렉터리-확인>#</a></h3><p>현재 SSHFS 명령어를 실행할 때 기본적으로 <strong>원격 서버의 <code>/</code> (루트 디렉터리)를 마운트하려고 하고 있음</strong>.<br>그러나 사용자의 홈 디렉터리가 <code>/home/jonpark</code>이 아닐 수도 있습니다.<br>먼저 SSH로 접속한 후, 현재 디렉터리가 어디인지 확인하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>echo $HOME
</span></span><span style=display:flex><span>pwd
</span></span><span style=display:flex><span>ls -la ~
</span></span></code></pre></div><p>📌 <strong>출력 예시 (홈 디렉터리가 <code>/home/jonpark</code>일 경우)</strong></p><pre tabindex=0><code>/home/jonpark
</code></pre><p>📌 <strong>출력 예시 (홈 디렉터리가 다른 위치일 경우)</strong></p><pre tabindex=0><code>/mnt/data/jonpark
</code></pre><p>🚀 <strong>해결 방법:</strong> 만약 홈 디렉터리가 <code>/home/jonpark</code>이 아니라 <code>/mnt/data/jonpark</code>과 같은 다른 위치라면, SSHFS 명령어에서 <strong>정확한 경로를 지정해야 합니다.</strong></p><p>✅ <strong>예제</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/mnt/data/jonpark J: -o debug
</span></span></code></pre></div><hr><h3 id=-해결-방법-2-원격-디렉터리-존재-여부-확인><strong>✅ 해결 방법 2: 원격 디렉터리 존재 여부 확인</strong><a hidden class=anchor aria-hidden=true href=#-해결-방법-2-원격-디렉터리-존재-여부-확인>#</a></h3><p>혹시 <strong>SSHFS가 마운트하려는 디렉터리가 실제로 존재하지 않는다면</strong> 마운트가 실패할 수 있습니다.<br>아래 명령어로 마운트하려는 경로가 실제로 있는지 확인하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ls -ld /
</span></span><span style=display:flex><span>ls -ld /home
</span></span><span style=display:flex><span>ls -ld /home/jonpark
</span></span></code></pre></div><p>🚨 <strong>출력 예시 (디렉터리가 없을 경우)</strong></p><pre tabindex=0><code>ls: cannot access &#39;/home/jonpark&#39;: No such file or directory
</code></pre><p>✅ <strong>해결 방법:</strong> 존재하는 디렉터리를 확인한 후, SSHFS 마운트 경로를 수정하세요.</p><hr><h3 id=-해결-방법-3-로컬-마운트-포인트-존재-여부-확인><strong>✅ 해결 방법 3: 로컬 마운트 포인트 존재 여부 확인</strong><a hidden class=anchor aria-hidden=true href=#-해결-방법-3-로컬-마운트-포인트-존재-여부-확인>#</a></h3><p>Windows에서 SSHFS를 사용하려면, <strong>J: 드라이브가 실제로 존재해야 합니다.</strong><br>다음 명령어로 확인하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div><p>🚨 <strong>출력 예시 (J: 드라이브 없음)</strong></p><pre tabindex=0><code>Name           Used (GB)     Free (GB) Provider   Root
----           --------     --------- --------   ----
C                 50.23         100.7 FileSystem C:\
D                 80.42         150.1 FileSystem D:\
E                100.42         250.1 FileSystem E:\
</code></pre><p>✅ <strong>해결 방법:</strong> SSHFS 마운트 전에 먼저 드라이브를 생성하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>net use J: /delete /y
</span></span></code></pre></div><hr><h3 id=-해결-방법-4-sshfs-마운트-디버깅--o-debug-옵션-사용><strong>✅ 해결 방법 4: SSHFS 마운트 디버깅 (<code>-o debug</code> 옵션 사용)</strong><a hidden class=anchor aria-hidden=true href=#-해결-방법-4-sshfs-마운트-디버깅--o-debug-옵션-사용>#</a></h3><p>SSHFS 마운트 시 <strong>더 많은 디버깅 정보를 확인하려면</strong> 다음과 같이 실행하세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/home/jonpark J: -o sshfs_debug -o loglevel=debug
</span></span></code></pre></div><hr><h3 id=-최종-실행-방법><strong>🚀 최종 실행 방법</strong><a hidden class=anchor aria-hidden=true href=#-최종-실행-방법>#</a></h3><p>✅ <strong>홈 디렉터리가 <code>/home/jonpark</code>일 경우</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/home/jonpark J: -o debug
</span></span></code></pre></div><p>✅ <strong>홈 디렉터리가 <code>/mnt/data/jonpark</code>일 경우</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/mnt/data/jonpark J: -o debug
</span></span></code></pre></div><p>✅ <strong>루트 디렉터리를 마운트하려면 (<code>/</code>)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style=color:#960050;background-color:#1e0010>:</span>/ J: -o debug
</span></span></code></pre></div><p>🚀 <strong>이제 다시 시도해보세요!</strong> 🚀</p><hr><h1 id=visual-studio-2022-에서-msbuildexe-위치는>visual studio 2022 에서 msbuild.exe 위치는<a hidden class=anchor aria-hidden=true href=#visual-studio-2022-에서-msbuildexe-위치는>#</a></h1><p>Visual Studio 2022에서 <code>cl.exe</code>는 Visual Studio 설치 디렉토리 안의 MSVC 도구 디렉토리에 위치합니다. <code>cl.exe</code>는 Microsoft C/C++ 컴파일러로, 아래 경로에서 찾을 수 있습니다.</p><hr><h3 id=기본-경로>기본 경로<a hidden class=anchor aria-hidden=true href=#기본-경로>#</a></h3><pre tabindex=0><code>C:\Program Files\Microsoft Visual Studio\2022\&lt;Edition&gt;\VC\Tools\MSVC\&lt;Version&gt;\bin\Hostx64\x64\cl.exe
</code></pre><h4 id=설명>설명:<a hidden class=anchor aria-hidden=true href=#설명>#</a></h4><ul><li><strong><code>&lt;Edition></code></strong>: Visual Studio 에디션<ul><li><code>Community</code>, <code>Professional</code>, <code>Enterprise</code></li></ul></li><li><strong><code>&lt;Version></code></strong>: 설치된 MSVC 도구 버전 (예: <code>14.36.32532</code>)<ul><li>정확한 버전 번호는 Visual Studio 설치 시 설치된 도구 버전에 따라 달라집니다.</li></ul></li></ul><p>예를 들어, Visual Studio 2022 Community Edition과 최신 MSVC 도구를 사용하는 경우:</p><pre tabindex=0><code>C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.36.32532\bin\Hostx64\x64\cl.exe
</code></pre><hr><h3 id=clexe-경로-확인-방법><code>cl.exe</code> 경로 확인 방법<a hidden class=anchor aria-hidden=true href=#clexe-경로-확인-방법>#</a></h3><h4 id=1-visual-studio-명령-프롬프트-사용>1. <strong>Visual Studio 명령 프롬프트 사용</strong><a hidden class=anchor aria-hidden=true href=#1-visual-studio-명령-프롬프트-사용>#</a></h4><ul><li>Visual Studio 설치 시 제공되는 **&ldquo;x64 Native Tools Command Prompt for VS 2022&rdquo;**를 실행합니다.</li><li>다음 명령어를 실행하여 <code>cl.exe</code> 경로를 확인합니다:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>where cl
</span></span></code></pre></div></li></ul><h4 id=2-visual-studio-설치-관리자에서-확인>2. <strong>Visual Studio 설치 관리자에서 확인</strong><a hidden class=anchor aria-hidden=true href=#2-visual-studio-설치-관리자에서-확인>#</a></h4><ul><li>Visual Studio Installer를 열고 설치된 구성에서 <strong>&ldquo;Desktop development with C++&rdquo;</strong> 워크로드가 설치되어 있는지 확인합니다.<ul><li>이 워크로드가 설치되어야 <code>cl.exe</code>가 포함됩니다.</li></ul></li></ul><h4 id=3-파일-탐색기로-확인>3. <strong>파일 탐색기로 확인</strong><a hidden class=anchor aria-hidden=true href=#3-파일-탐색기로-확인>#</a></h4><ul><li>아래 경로에서 직접 확인:<pre tabindex=0><code>C:\Program Files\Microsoft Visual Studio\2022\&lt;Edition&gt;\VC\Tools\MSVC
</code></pre></li><li>MSVC 버전 폴더 내부를 탐색해 <code>bin\Hostx64\x64</code> 경로에서 <code>cl.exe</code> 파일을 찾습니다.</li></ul><hr><h3 id=환경-변수에-추가-선택-사항>환경 변수에 추가 (선택 사항)<a hidden class=anchor aria-hidden=true href=#환경-변수에-추가-선택-사항>#</a></h3><p><code>cl.exe</code>를 자주 사용해야 한다면, 해당 경로를 환경 변수 <code>PATH</code>에 추가하여 어디서나 사용할 수 있도록 설정할 수 있습니다.</p><ol><li><strong>Windows 검색</strong> → &ldquo;환경 변수 편집&rdquo; 입력 후 실행.</li><li>&ldquo;시스템 변수&rdquo; 섹션에서 <code>Path</code>를 선택하고 &ldquo;편집&rdquo; 클릭.</li><li>위 경로를 새로 추가.</li></ol><hr><h2 id=필요한-사항이나-추가-질문이-있으면-언제든-말씀해주세요->필요한 사항이나 추가 질문이 있으면 언제든 말씀해주세요! 😊<a hidden class=anchor aria-hidden=true href=#필요한-사항이나-추가-질문이-있으면-언제든-말씀해주세요->#</a></h2><h1 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h1><hr><h1 id=heading-1><a hidden class=anchor aria-hidden=true href=#heading-1>#</a></h1><hr><h1 id=heading-2><a hidden class=anchor aria-hidden=true href=#heading-2>#</a></h1><hr><h1 id=heading-3><a hidden class=anchor aria-hidden=true href=#heading-3>#</a></h1><hr><h1 id=heading-4><a hidden class=anchor aria-hidden=true href=#heading-4>#</a></h1><hr></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jongyongpark.github.io/>RyanLabs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>