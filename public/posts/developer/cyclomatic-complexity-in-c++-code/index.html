<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cyclomatic Complexity in C++ Code | RyanLabs</title>
<meta name=keywords content="C++,CCM"><meta name=description content='Cyclomatic Complexity in C++ Code
Cyclomatic Complexity (CCM) is a software metric used to indicate the complexity of a program. It directly measures the number of linearly independent paths through a program&rsquo;s source code. Higher CCM values suggest more complex and potentially less maintainable code.
CCM Calculation Rules
Cyclomatic Complexity is calculated based on the control flow graph of the program using the following rules:

Basic Complexity: The simplest program has a CCM of 1.
Control Flow Branches: Each if, for, while, case, and other control flow statements add to the CCM.
Logical Operators: Logical operators like && and || can also increase CCM by introducing additional paths.

Example C++ Code with CCM Calculation
#include <iostream>

using namespace std;

// Function declaration
int calculate(int a, int b, int c);

int main() {
    int x = 10;
    int y = 20;
    int z = 30;
    int result = calculate(x, y, z);
    cout << "Result: " << result << endl;
    return 0;
}

// Function with high Cyclomatic Complexity
int calculate(int a, int b, int c) {
    int CCM = 1; // Basic complexity

    // If statement 1: CCM += 1
    if (a > b) {
        CCM++;
        cout << "a is greater than b" << endl;
    }

    // If-else statement: CCM += 1
    if (b > c) {
        CCM++;
        cout << "b is greater than c" << endl;
    } else {
        CCM++;
        cout << "c is greater than or equal to b" << endl;
    }

    // For loop: CCM += 1
    for(int i = 0; i < 5; ++i) {
        CCM++;
        cout << "Iteration: " << i << endl;
    }

    // While loop: CCM += 1
    int count = 0;
    while(count < 3) {
        CCM++;
        cout << "Count: " << count << endl;
        count++;
    }

    // Switch-case statement: Each case adds to CCM
    int option = 2;
    switch(option) {
        case 1:
            CCM++;
            cout << "Option 1 selected" << endl;
            break;
        case 2:
            CCM++;
            cout << "Option 2 selected" << endl;
            break;
        case 3:
            CCM++;
            cout << "Option 3 selected" << endl;
            break;
        default:
            CCM++;
            cout << "Default option selected" << endl;
            break;
    }

    // Logical operators: Each &#39;&&&#39; or &#39;||&#39; adds to CCM
    if (a > 0 && b > 0) { // &#39;&&&#39; adds 1
        CCM++;
        cout << "Both a and b are positive" << endl;
    }

    if (a > 0 || c > 0) { // &#39;||&#39; adds 1
        CCM++;
        cout << "Either a or c is positive" << endl;
    }

    return CCM;
}
Code Explanation and CCM Calculation


Basic Complexity:'><meta name=author content><link rel=canonical href=https://jongyongpark.github.io/posts/developer/cyclomatic-complexity-in-c++-code/><link crossorigin=anonymous href=/assets/css/stylesheet.9de45e225101e4f99701d2b68fc6b8a1ef6027928be6391fa15bf7f56326c909.css integrity="sha256-neReIlEB5PmXAdK2j8a4oe9gJ5KL5jkfoVv39WMmyQk=" rel="preload stylesheet" as=style><link rel=icon href=https://jongyongpark.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jongyongpark.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jongyongpark.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jongyongpark.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jongyongpark.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jongyongpark.github.io/posts/developer/cyclomatic-complexity-in-c++-code/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://jongyongpark.github.io/posts/developer/cyclomatic-complexity-in-c++-code/"><meta property="og:site_name" content="RyanLabs"><meta property="og:title" content="Cyclomatic Complexity in C++ Code"><meta property="og:description" content='Cyclomatic Complexity in C++ Code Cyclomatic Complexity (CCM) is a software metric used to indicate the complexity of a program. It directly measures the number of linearly independent paths through a program’s source code. Higher CCM values suggest more complex and potentially less maintainable code.
CCM Calculation Rules Cyclomatic Complexity is calculated based on the control flow graph of the program using the following rules:
Basic Complexity: The simplest program has a CCM of 1. Control Flow Branches: Each if, for, while, case, and other control flow statements add to the CCM. Logical Operators: Logical operators like && and || can also increase CCM by introducing additional paths. Example C++ Code with CCM Calculation #include <iostream> using namespace std; // Function declaration int calculate(int a, int b, int c); int main() { int x = 10; int y = 20; int z = 30; int result = calculate(x, y, z); cout << "Result: " << result << endl; return 0; } // Function with high Cyclomatic Complexity int calculate(int a, int b, int c) { int CCM = 1; // Basic complexity // If statement 1: CCM += 1 if (a > b) { CCM++; cout << "a is greater than b" << endl; } // If-else statement: CCM += 1 if (b > c) { CCM++; cout << "b is greater than c" << endl; } else { CCM++; cout << "c is greater than or equal to b" << endl; } // For loop: CCM += 1 for(int i = 0; i < 5; ++i) { CCM++; cout << "Iteration: " << i << endl; } // While loop: CCM += 1 int count = 0; while(count < 3) { CCM++; cout << "Count: " << count << endl; count++; } // Switch-case statement: Each case adds to CCM int option = 2; switch(option) { case 1: CCM++; cout << "Option 1 selected" << endl; break; case 2: CCM++; cout << "Option 2 selected" << endl; break; case 3: CCM++; cout << "Option 3 selected" << endl; break; default: CCM++; cout << "Default option selected" << endl; break; } // Logical operators: Each &#39;&&&#39; or &#39;||&#39; adds to CCM if (a > 0 && b > 0) { // &#39;&&&#39; adds 1 CCM++; cout << "Both a and b are positive" << endl; } if (a > 0 || c > 0) { // &#39;||&#39; adds 1 CCM++; cout << "Either a or c is positive" << endl; } return CCM; } Code Explanation and CCM Calculation Basic Complexity:'><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-31T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-31T00:00:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="CCM"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cyclomatic Complexity in C++ Code"><meta name=twitter:description content='Cyclomatic Complexity in C++ Code
Cyclomatic Complexity (CCM) is a software metric used to indicate the complexity of a program. It directly measures the number of linearly independent paths through a program&rsquo;s source code. Higher CCM values suggest more complex and potentially less maintainable code.
CCM Calculation Rules
Cyclomatic Complexity is calculated based on the control flow graph of the program using the following rules:

Basic Complexity: The simplest program has a CCM of 1.
Control Flow Branches: Each if, for, while, case, and other control flow statements add to the CCM.
Logical Operators: Logical operators like && and || can also increase CCM by introducing additional paths.

Example C++ Code with CCM Calculation
#include <iostream>

using namespace std;

// Function declaration
int calculate(int a, int b, int c);

int main() {
    int x = 10;
    int y = 20;
    int z = 30;
    int result = calculate(x, y, z);
    cout << "Result: " << result << endl;
    return 0;
}

// Function with high Cyclomatic Complexity
int calculate(int a, int b, int c) {
    int CCM = 1; // Basic complexity

    // If statement 1: CCM += 1
    if (a > b) {
        CCM++;
        cout << "a is greater than b" << endl;
    }

    // If-else statement: CCM += 1
    if (b > c) {
        CCM++;
        cout << "b is greater than c" << endl;
    } else {
        CCM++;
        cout << "c is greater than or equal to b" << endl;
    }

    // For loop: CCM += 1
    for(int i = 0; i < 5; ++i) {
        CCM++;
        cout << "Iteration: " << i << endl;
    }

    // While loop: CCM += 1
    int count = 0;
    while(count < 3) {
        CCM++;
        cout << "Count: " << count << endl;
        count++;
    }

    // Switch-case statement: Each case adds to CCM
    int option = 2;
    switch(option) {
        case 1:
            CCM++;
            cout << "Option 1 selected" << endl;
            break;
        case 2:
            CCM++;
            cout << "Option 2 selected" << endl;
            break;
        case 3:
            CCM++;
            cout << "Option 3 selected" << endl;
            break;
        default:
            CCM++;
            cout << "Default option selected" << endl;
            break;
    }

    // Logical operators: Each &#39;&&&#39; or &#39;||&#39; adds to CCM
    if (a > 0 && b > 0) { // &#39;&&&#39; adds 1
        CCM++;
        cout << "Both a and b are positive" << endl;
    }

    if (a > 0 || c > 0) { // &#39;||&#39; adds 1
        CCM++;
        cout << "Either a or c is positive" << endl;
    }

    return CCM;
}
Code Explanation and CCM Calculation


Basic Complexity:'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jongyongpark.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Cyclomatic Complexity in C++ Code","item":"https://jongyongpark.github.io/posts/developer/cyclomatic-complexity-in-c++-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cyclomatic Complexity in C++ Code","name":"Cyclomatic Complexity in C\u002b\u002b Code","description":"Cyclomatic Complexity in C++ Code Cyclomatic Complexity (CCM) is a software metric used to indicate the complexity of a program. It directly measures the number of linearly independent paths through a program\u0026rsquo;s source code. Higher CCM values suggest more complex and potentially less maintainable code.\nCCM Calculation Rules Cyclomatic Complexity is calculated based on the control flow graph of the program using the following rules:\nBasic Complexity: The simplest program has a CCM of 1. Control Flow Branches: Each if, for, while, case, and other control flow statements add to the CCM. Logical Operators: Logical operators like \u0026amp;\u0026amp; and || can also increase CCM by introducing additional paths. Example C++ Code with CCM Calculation #include \u0026lt;iostream\u0026gt; using namespace std; // Function declaration int calculate(int a, int b, int c); int main() { int x = 10; int y = 20; int z = 30; int result = calculate(x, y, z); cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; return 0; } // Function with high Cyclomatic Complexity int calculate(int a, int b, int c) { int CCM = 1; // Basic complexity // If statement 1: CCM += 1 if (a \u0026gt; b) { CCM++; cout \u0026lt;\u0026lt; \u0026#34;a is greater than b\u0026#34; \u0026lt;\u0026lt; endl; } // If-else statement: CCM += 1 if (b \u0026gt; c) { CCM++; cout \u0026lt;\u0026lt; \u0026#34;b is greater than c\u0026#34; \u0026lt;\u0026lt; endl; } else { CCM++; cout \u0026lt;\u0026lt; \u0026#34;c is greater than or equal to b\u0026#34; \u0026lt;\u0026lt; endl; } // For loop: CCM += 1 for(int i = 0; i \u0026lt; 5; ++i) { CCM++; cout \u0026lt;\u0026lt; \u0026#34;Iteration: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } // While loop: CCM += 1 int count = 0; while(count \u0026lt; 3) { CCM++; cout \u0026lt;\u0026lt; \u0026#34;Count: \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; endl; count++; } // Switch-case statement: Each case adds to CCM int option = 2; switch(option) { case 1: CCM++; cout \u0026lt;\u0026lt; \u0026#34;Option 1 selected\u0026#34; \u0026lt;\u0026lt; endl; break; case 2: CCM++; cout \u0026lt;\u0026lt; \u0026#34;Option 2 selected\u0026#34; \u0026lt;\u0026lt; endl; break; case 3: CCM++; cout \u0026lt;\u0026lt; \u0026#34;Option 3 selected\u0026#34; \u0026lt;\u0026lt; endl; break; default: CCM++; cout \u0026lt;\u0026lt; \u0026#34;Default option selected\u0026#34; \u0026lt;\u0026lt; endl; break; } // Logical operators: Each \u0026#39;\u0026amp;\u0026amp;\u0026#39; or \u0026#39;||\u0026#39; adds to CCM if (a \u0026gt; 0 \u0026amp;\u0026amp; b \u0026gt; 0) { // \u0026#39;\u0026amp;\u0026amp;\u0026#39; adds 1 CCM++; cout \u0026lt;\u0026lt; \u0026#34;Both a and b are positive\u0026#34; \u0026lt;\u0026lt; endl; } if (a \u0026gt; 0 || c \u0026gt; 0) { // \u0026#39;||\u0026#39; adds 1 CCM++; cout \u0026lt;\u0026lt; \u0026#34;Either a or c is positive\u0026#34; \u0026lt;\u0026lt; endl; } return CCM; } Code Explanation and CCM Calculation Basic Complexity:\n","keywords":["C++","CCM"],"articleBody":"Cyclomatic Complexity in C++ Code Cyclomatic Complexity (CCM) is a software metric used to indicate the complexity of a program. It directly measures the number of linearly independent paths through a program’s source code. Higher CCM values suggest more complex and potentially less maintainable code.\nCCM Calculation Rules Cyclomatic Complexity is calculated based on the control flow graph of the program using the following rules:\nBasic Complexity: The simplest program has a CCM of 1. Control Flow Branches: Each if, for, while, case, and other control flow statements add to the CCM. Logical Operators: Logical operators like \u0026\u0026 and || can also increase CCM by introducing additional paths. Example C++ Code with CCM Calculation #include using namespace std; // Function declaration int calculate(int a, int b, int c); int main() { int x = 10; int y = 20; int z = 30; int result = calculate(x, y, z); cout \u003c\u003c \"Result: \" \u003c\u003c result \u003c\u003c endl; return 0; } // Function with high Cyclomatic Complexity int calculate(int a, int b, int c) { int CCM = 1; // Basic complexity // If statement 1: CCM += 1 if (a \u003e b) { CCM++; cout \u003c\u003c \"a is greater than b\" \u003c\u003c endl; } // If-else statement: CCM += 1 if (b \u003e c) { CCM++; cout \u003c\u003c \"b is greater than c\" \u003c\u003c endl; } else { CCM++; cout \u003c\u003c \"c is greater than or equal to b\" \u003c\u003c endl; } // For loop: CCM += 1 for(int i = 0; i \u003c 5; ++i) { CCM++; cout \u003c\u003c \"Iteration: \" \u003c\u003c i \u003c\u003c endl; } // While loop: CCM += 1 int count = 0; while(count \u003c 3) { CCM++; cout \u003c\u003c \"Count: \" \u003c\u003c count \u003c\u003c endl; count++; } // Switch-case statement: Each case adds to CCM int option = 2; switch(option) { case 1: CCM++; cout \u003c\u003c \"Option 1 selected\" \u003c\u003c endl; break; case 2: CCM++; cout \u003c\u003c \"Option 2 selected\" \u003c\u003c endl; break; case 3: CCM++; cout \u003c\u003c \"Option 3 selected\" \u003c\u003c endl; break; default: CCM++; cout \u003c\u003c \"Default option selected\" \u003c\u003c endl; break; } // Logical operators: Each '\u0026\u0026' or '||' adds to CCM if (a \u003e 0 \u0026\u0026 b \u003e 0) { // '\u0026\u0026' adds 1 CCM++; cout \u003c\u003c \"Both a and b are positive\" \u003c\u003c endl; } if (a \u003e 0 || c \u003e 0) { // '||' adds 1 CCM++; cout \u003c\u003c \"Either a or c is positive\" \u003c\u003c endl; } return CCM; } Code Explanation and CCM Calculation Basic Complexity:\nCCM = 1 Every function starts with a CCM of 1. First if Statement:\nCondition: if (a \u003e b) CCM increases by 1. Current CCM: 2 Second if-else Statement:\nCondition: if (b \u003e c) ... else ... if and else constitute a single decision point, increasing CCM by 1. Current CCM: 3 for Loop:\nCondition: for(int i = 0; i \u003c 5; ++i) Loops introduce a new path, increasing CCM by 1. Current CCM: 4 while Loop:\nCondition: while(count \u003c 3) Another loop adds to CCM by 1. Current CCM: 5 switch-case Statement:\nEach case and default adds to CCM. 4 cases (1, 2, 3, default) increase CCM by 4. Current CCM: 9 Logical Operators (\u0026\u0026 and ||):\nif (a \u003e 0 \u0026\u0026 b \u003e 0) \u0026\u0026 adds 1 to CCM. Current CCM: 10 if (a \u003e 0 || c \u003e 0) || adds 1 to CCM. Final CCM: 11 Final Cyclomatic Complexity The calculate function has a final CCM value of 11.\nCCM Increase Summary Code Structure CCM Increase Description Basic Complexity 1 Function starts with CCM = 1 if (a \u003e b) +1 Conditional branch if (b \u003e c) else +1 Conditional branch with else for Loop +1 Loop introduces a new path while Loop +1 Loop introduces a new path switch-case (4 cases) +4 Each case and default adds a branch if (a \u003e 0 \u0026\u0026 b \u003e 0) +1 Logical AND operator adds a branch if (a \u003e 0 || c \u003e 0) +1 Logical OR operator adds a branch Total Cyclomatic Complexity 11 Importance of Cyclomatic Complexity Cyclomatic Complexity is crucial for several reasons:\nMaintainability: High CCM indicates complex code that is harder to understand and maintain. Testability: Higher CCM requires more test cases to achieve adequate test coverage. Bug Risk: Complex code is more prone to bugs and errors. Optimizing Cyclomatic Complexity To keep CCM manageable, consider the following practices:\nSimplify Conditional Statements: Reduce the number of nested conditions and use simpler logic. Refactor Functions: Break down large functions into smaller, single-responsibility functions. Minimize switch-case Statements: Use polymorphism or other design patterns to handle multiple cases. Limit Logical Operators: Avoid excessive use of \u0026\u0026 and || in conditional statements. Conclusion Cyclomatic Complexity Metric (CCM) is a valuable tool for assessing and managing the complexity of your code. By understanding how different C++ structures affect CCM, you can write cleaner, more maintainable, and less error-prone code.\nCCM Calculation from compiled code g++ ccm.cpp ./a.out c is greater than or equal to b Iteration: 0 Iteration: 1 Iteration: 2 Iteration: 3 Iteration: 4 Count: 0 Count: 1 Count: 2 Option 2 selected Both a and b are positive Either a or c is positive Result: 13 CCM Calculation from Coverity CCM https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-cyclomatic-complexity?view=vs-2022\nhttps://www.mathworks.com/help/matlab/matlab_prog/measure-code-complexity-using-cyclomatic-complexity.html\nhttps://www.sonarsource.com/learn/cyclomatic-complexity/\nMinimizing Cyclomatic Complexity with Pattern Matching https://www.danylkoweb.com/Blog/minimizing-cyclomatic-complexity-with-pattern-matching-SR\nhttps://www.rhyous.com/2017/10/19/eliminating-cylclomatic-complexity-by-replacing-switchcase-with-a-method-or-a-dictionary/\nC++ 코드에서 여러 식과 문에서 변수 CCM의 값이 어떻게 변하는지 보여주는 예제 C++ 코드에서 여러 식과 문에서 변수 CCM의 값이 어떻게 변하는지 보여주는 예제를 작성해보겠습니다. 특히 switch-case 문 내에서 CCM의 변화도 포함하겠습니다. 이 예제에서는 CCM을 정수형 변수로 가정하고, 다양한 연산과 제어 구조를 통해 CCM의 값을 변경하며 그 변화를 출력합니다.\n#include using namespace std; int main() { int CCM = 0; // 초기값 설정 cout \u003c\u003c \"초기 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; // 1. 단순 대입 연산 CCM = 5; cout \u003c\u003c \"대입 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; // 2. 덧셈 연산 CCM += 10; cout \u003c\u003c \"덧셈 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; // 3. 뺄셈 연산 CCM -= 3; cout \u003c\u003c \"뺄셈 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; // 4. 곱셈 연산 CCM *= 2; cout \u003c\u003c \"곱셈 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; // 5. 나눗셈 연산 if (CCM != 0) { // 0으로 나누는 것을 방지 CCM /= 4; cout \u003c\u003c \"나눗셈 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; } // 6. 조건부 연산 (삼항 연산자) CCM = (CCM \u003e 3) ? CCM + 1 : CCM - 1; cout \u003c\u003c \"조건부 연산 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; // 7. 증감 연산 CCM++; cout \u003c\u003c \"증가 연산 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; CCM--; cout \u003c\u003c \"감소 연산 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; // 8. 비트 연산 CCM = CCM \u003c\u003c 1; // 왼쪽 시프트 cout \u003c\u003c \"비트 시프트 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; CCM = CCM \u0026 0xF; // 비트 AND cout \u003c\u003c \"비트 AND 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; // 9. 논리 연산 bool flag = (CCM != 0); cout \u003c\u003c \"논리 연산 후 flag 값: \" \u003c\u003c flag \u003c\u003c endl; // 10. switch-case 문에서 CCM 값 변경 int option = 2; switch(option) { case 1: CCM += 100; cout \u003c\u003c \"switch-case 1 실행 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; break; case 2: CCM += 200; cout \u003c\u003c \"switch-case 2 실행 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; break; case 3: CCM += 300; cout \u003c\u003c \"switch-case 3 실행 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; break; default: CCM += 400; cout \u003c\u003c \"switch-case default 실행 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; break; } // 11. 반복문 내에서 CCM 값 변경 for(int i = 0; i \u003c 3; ++i) { CCM += i; cout \u003c\u003c \"for 루프 \" \u003c\u003c i+1 \u003c\u003c \"회차 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; } // 12. 함수 호출을 통한 CCM 값 변경 auto modifyCCM = [\u0026](int value) { CCM += value; cout \u003c\u003c \"함수 호출 후 CCM 값: \" \u003c\u003c CCM \u003c\u003c endl; }; modifyCCM(50); modifyCCM(-20); return 0; } 코드 설명 초기화 및 단순 대입:\nCCM을 0으로 초기화한 후, 5로 대입합니다. 산술 연산:\nCCM에 10을 더하고, 3을 빼고, 2를 곱하고, 4로 나눕니다. 조건부 연산:\nCCM이 3보다 크면 1을 더하고, 그렇지 않으면 1을 뺍니다. 증감 연산:\nCCM을 증가시키고, 다시 감소시킵니다. 비트 연산:\nCCM을 왼쪽으로 시프트하고, 0xF(15)과 비트 AND 연산을 수행합니다. 논리 연산:\nCCM이 0이 아닌지 확인하여 flag에 저장합니다. switch-case 문:\noption 변수의 값에 따라 CCM을 다르게 변경합니다. 여기서는 option이 2이므로 CCM += 200이 실행됩니다. 반복문:\nfor 루프를 통해 3번 반복하면서 CCM에 반복 변수 i를 더합니다. 함수 호출:\n람다 함수를 사용하여 CCM을 변경하는 함수를 정의하고, 이를 호출하여 CCM을 더하고 빼는 연산을 수행합니다. 실행 결과 예시 초기 CCM 값: 0\r대입 후 CCM 값: 5\r덧셈 후 CCM 값: 15\r뺄셈 후 CCM 값: 12\r곱셈 후 CCM 값: 24\r나눗셈 후 CCM 값: 6\r조건부 연산 후 CCM 값: 7\r증가 연산 후 CCM 값: 8\r감소 연산 후 CCM 값: 7\r비트 시프트 후 CCM 값: 14\r비트 AND 후 CCM 값: 14\r논리 연산 후 flag 값: 1\rswitch-case 2 실행 후 CCM 값: 214\rfor 루프 1회차 후 CCM 값: 214\rfor 루프 2회차 후 CCM 값: 215\rfor 루프 3회차 후 CCM 값: 217\r함수 호출 후 CCM 값: 267\r함수 호출 후 CCM 값: 247 추가 설명 switch-case 문:\nswitch(option)에서 option이 2이므로 case 2 블록이 실행되어 CCM에 200이 더해집니다. 다른 option 값을 설정하면 해당 케이스가 실행됩니다. 예를 들어, option = 1로 설정하면 case 1이 실행됩니다. 람다 함수:\nmodifyCCM 람다 함수는 CCM을 인자로 받은 값을 더하거나 빼서 변경합니다. 함수 호출 시 CCM의 현재 값에 따라 변경된 값을 출력합니다. 이 예제는 다양한 C++ 연산과 제어 구조에서 변수 CCM의 값이 어떻게 변화하는지를 보여줍니다. 특히 switch-case 문 내에서의 CCM 값 변경을 포함하여, 여러 상황에서 CCM이 어떻게 변하는지를 쉽게 이해할 수 있습니다.\n다양한 C++ 문과 식에서 CCM 값이 어떻게 변하는지를 보여주는 예제 코드 알겠습니다. Cyclomatic Complexity Metric(CCM, 사이클로매틱 복잡도 지표)은 코드의 복잡성을 측정하는 데 사용되는 지표로, 주로 제어 흐름의 복잡성을 평가합니다. CCM은 프로그램 내의 독립적인 경로의 수를 나타내며, 유지보수성과 테스트 용이성을 평가하는 데 유용합니다.\n아래는 다양한 C++ 문과 식에서 CCM 값이 어떻게 변하는지를 보여주는 예제 코드입니다. 특히 switch-case 문이 CCM에 미치는 영향도 포함하였습니다.\nCyclomatic Complexity 계산 규칙 Cyclomatic Complexity는 다음과 같은 규칙에 따라 계산됩니다:\n기본 복잡도: 시작점과 종료점 사이의 선형 경로는 기본적으로 1의 복잡도를 가집니다. 제어 흐름 분기: if, while, for, case 등 제어 흐름을 분기시키는 각 구조는 복잡도를 1씩 증가시킵니다. 논리 연산자: \u0026\u0026, || 같은 논리 연산자는 추가적인 분기를 생성하여 복잡도를 증가시킬 수 있습니다. 예제 코드 및 CCM 설명 #include using namespace std; // 함수 선언 int calculate(int a, int b, int c); int main() { int x = 10; int y = 20; int z = 30; int result = calculate(x, y, z); cout \u003c\u003c \"결과: \" \u003c\u003c result \u003c\u003c endl; return 0; } // Cyclomatic Complexity가 높은 함수 int calculate(int a, int b, int c) { int CCM = 1; // 기본 복잡도 // if 문 1: CCM += 1 if (a \u003e b) { CCM++; cout \u003c\u003c \"a가 b보다 큼\" \u003c\u003c endl; } // if-else 문 1: CCM += 1 if (b \u003e c) { CCM++; cout \u003c\u003c \"b가 c보다 큼\" \u003c\u003c endl; } else { CCM++; cout \u003c\u003c \"c가 b보다 크거나 같음\" \u003c\u003c endl; } // for 루프 1: CCM += 1 for(int i = 0; i \u003c 5; ++i) { CCM++; cout \u003c\u003c \"반복 횟수: \" \u003c\u003c i \u003c\u003c endl; } // while 루프 1: CCM += 1 int count = 0; while(count \u003c 3) { CCM++; cout \u003c\u003c \"카운트: \" \u003c\u003c count \u003c\u003c endl; count++; } // switch-case 문: 각 case마다 CCM += 1 int option = 2; switch(option) { case 1: CCM++; cout \u003c\u003c \"옵션 1 선택\" \u003c\u003c endl; break; case 2: CCM++; cout \u003c\u003c \"옵션 2 선택\" \u003c\u003c endl; break; case 3: CCM++; cout \u003c\u003c \"옵션 3 선택\" \u003c\u003c endl; break; default: CCM++; cout \u003c\u003c \"기본 옵션 선택\" \u003c\u003c endl; break; } // 논리 연산자 사용: \u0026\u0026 또는 || 사용 시 CCM += 1 if (a \u003e 0 \u0026\u0026 b \u003e 0) { // \u0026\u0026 연산자 하나로 CCM += 1 CCM++; cout \u003c\u003c \"a와 b가 모두 양수임\" \u003c\u003c endl; } if (a \u003e 0 || c \u003e 0) { // || 연산자 하나로 CCM += 1 CCM++; cout \u003c\u003c \"a 또는 c가 양수임\" \u003c\u003c endl; } return CCM; } 코드 설명 및 CCM 계산 기본 복잡도: CCM = 1\n첫 번째 if 문:\n조건문: if (a \u003e b) CCM 증가: +1 현재 CCM: 2 두 번째 if-else 문:\n조건문: if (b \u003e c) ... else ... if와 else는 동일한 조건 분기이므로 CCM 증가: +1 현재 CCM: 3 for 루프:\n조건문: for(int i = 0; i \u003c 5; ++i) 반복문은 하나의 독립적인 경로를 추가하므로 CCM 증가: +1 현재 CCM: 4 while 루프:\n조건문: while(count \u003c 3) 반복문은 하나의 독립적인 경로를 추가하므로 CCM 증가: +1 현재 CCM: 5 switch-case 문:\n각 case와 default는 별도의 분기를 생성 총 4개의 case (1, 2, 3, default) CCM 증가: +4 현재 CCM: 9 논리 연산자 \u0026\u0026 사용:\n조건문: if (a \u003e 0 \u0026\u0026 b \u003e 0) \u0026\u0026는 하나의 추가 분기를 생성 CCM 증가: +1 현재 CCM: 10 논리 연산자 || 사용:\n조건문: if (a \u003e 0 || c \u003e 0) ||는 하나의 추가 분기를 생성 CCM 증가: +1 최종 CCM: 11 최종 Cyclomatic Complexity 함수 calculate의 최종 CCM 값은 11입니다.\nCCM 증가 요약 코드 구성 요소 CCM 증가 설명 기본 복잡도 1 함수 시작 시 기본값 if (a \u003e b) +1 조건 분기 if (b \u003e c) else +1 if와 else는 하나의 조건 분기 for 루프 +1 반복문 분기 while 루프 +1 반복문 분기 switch-case (4 cases) +4 각 case와 default가 별도의 분기 생성 if (a \u003e 0 \u0026\u0026 b \u003e 0) +1 논리 연산자 \u0026\u0026에 의한 분기 `if (a \u003e 0 c \u003e 0)` 총합 11 Cyclomatic Complexity의 중요성 CCM은 코드의 복잡성을 정량적으로 측정하여 다음과 같은 이점을 제공합니다:\n유지보수성 향상: 높은 CCM은 코드가 복잡하고 이해하기 어려움을 나타내며, 이는 유지보수를 어렵게 만들 수 있습니다. 테스트 용이성: 높은 CCM은 테스트 커버리지를 높이기 위해 더 많은 테스트 케이스가 필요함을 의미합니다. 버그 가능성: 복잡한 코드일수록 버그가 발생할 가능성이 높아집니다. 따라서, 가능한 한 낮은 CCM을 유지하는 것이 코드의 품질과 유지보수성을 향상시키는 데 도움이 됩니다.\nCCM 최적화 방안 조건문 단순화: 복잡한 조건문을 단순화하거나 논리 연산자를 줄입니다. 함수 분할: 하나의 함수에 너무 많은 로직을 포함하지 않고, 기능별로 작은 함수로 분할합니다. 스위치 케이스 최소화: 가능한 경우 switch-case 대신 다른 구조를 사용하거나, 각 case를 별도의 함수로 분리합니다. 반복문 최소화: 반복문 내의 복잡한 로직을 단순화합니다. 결론 Cyclomatic Complexity Metric(CCM)은 코드의 복잡성을 측정하고 관리하는 데 중요한 도구입니다. 위의 예제와 설명을 통해 다양한 C++ 구조에서 CCM이 어떻게 변하는지 이해할 수 있었기를 바랍니다. 코드를 작성할 때 CCM을 고려하여 가능한 한 간결하고 단순한 구조를 유지하는 것이 바람직합니다.\n","wordCount":"2448","inLanguage":"ko","datePublished":"2025-01-31T00:00:00Z","dateModified":"2025-01-31T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://jongyongpark.github.io/posts/developer/cyclomatic-complexity-in-c++-code/"},"publisher":{"@type":"Organization","name":"RyanLabs","logo":{"@type":"ImageObject","url":"https://jongyongpark.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jongyongpark.github.io/ accesskey=h title="RyanLabs (Alt + H)">RyanLabs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jongyongpark.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://jongyongpark.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://jongyongpark.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://jongyongpark.github.io/archives/ title=연도><span>연도</span></a></li><li><a href=https://jongyongpark.github.io/lectures/ title=강의><span>강의</span></a></li><li><a href=https://jongyongpark.github.io/about/ title=어바웃미><span>어바웃미</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Cyclomatic Complexity in C++ Code</h1><div class=post-meta><span title='2025-01-31 00:00:00 +0000 UTC'>1월 31, 2025</span></div></header><div class=post-content><h1 id=cyclomatic-complexity-in-c-code>Cyclomatic Complexity in C++ Code<a hidden class=anchor aria-hidden=true href=#cyclomatic-complexity-in-c-code>#</a></h1><p>Cyclomatic Complexity (CCM) is a software metric used to indicate the complexity of a program. It directly measures the number of linearly independent paths through a program&rsquo;s source code. Higher CCM values suggest more complex and potentially less maintainable code.</p><h2 id=ccm-calculation-rules>CCM Calculation Rules<a hidden class=anchor aria-hidden=true href=#ccm-calculation-rules>#</a></h2><p>Cyclomatic Complexity is calculated based on the control flow graph of the program using the following rules:</p><ol><li>Basic Complexity: The simplest program has a CCM of 1.</li><li>Control Flow Branches: Each if, for, while, case, and other control flow statements add to the CCM.</li><li>Logical Operators: Logical operators like && and || can also increase CCM by introducing additional paths.</li></ol><h2 id=example-c-code-with-ccm-calculation>Example C++ Code with CCM Calculation<a hidden class=anchor aria-hidden=true href=#example-c-code-with-ccm-calculation>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Function declaration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>calculate</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> z <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> calculate(x, y, z);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Result: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Function with high Cyclomatic Complexity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>calculate</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> CCM <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Basic complexity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If statement 1: CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;</span> b) {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a is greater than b&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If-else statement: CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>&gt;</span> c) {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;b is greater than c&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;c is greater than or equal to b&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For loop: CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Iteration: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// While loop: CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(count <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Count: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> count <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Switch-case statement: Each case adds to CCM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> option <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span>(option) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Option 1 selected&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Option 2 selected&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Option 3 selected&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Default option selected&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Logical operators: Each &#39;&amp;&amp;&#39; or &#39;||&#39; adds to CCM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// &#39;&amp;&amp;&#39; adds 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Both a and b are positive&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> c <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// &#39;||&#39; adds 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Either a or c is positive&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> CCM;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=code-explanation-and-ccm-calculation>Code Explanation and CCM Calculation<a hidden class=anchor aria-hidden=true href=#code-explanation-and-ccm-calculation>#</a></h2><ol><li><p>Basic Complexity:</p><ul><li>CCM = 1</li><li>Every function starts with a CCM of 1.</li></ul></li><li><p>First if Statement:</p><ul><li>Condition: <code>if (a > b)</code></li><li>CCM increases by 1.</li><li>Current CCM: 2</li></ul></li><li><p>Second if-else Statement:</p><ul><li>Condition: <code>if (b > c) ... else ...</code></li><li>if and else constitute a single decision point, increasing CCM by 1.</li><li>Current CCM: 3</li></ul></li><li><p>for Loop:</p><ul><li>Condition: <code>for(int i = 0; i &lt; 5; ++i)</code></li><li>Loops introduce a new path, increasing CCM by 1.</li><li>Current CCM: 4</li></ul></li><li><p>while Loop:</p><ul><li>Condition: <code>while(count &lt; 3)</code></li><li>Another loop adds to CCM by 1.</li><li>Current CCM: 5</li></ul></li><li><p>switch-case Statement:</p><ul><li>Each case and default adds to CCM.</li><li>4 cases (1, 2, 3, default) increase CCM by 4.</li><li>Current CCM: 9</li></ul></li><li><p>Logical Operators (&& and ||):</p><ul><li><code>if (a > 0 && b > 0)</code><ul><li>&& adds 1 to CCM.</li><li>Current CCM: 10</li></ul></li><li><code>if (a > 0 || c > 0)</code><ul><li>|| adds 1 to CCM.</li><li>Final CCM: 11</li></ul></li></ul></li></ol><h2 id=final-cyclomatic-complexity>Final Cyclomatic Complexity<a hidden class=anchor aria-hidden=true href=#final-cyclomatic-complexity>#</a></h2><p>The <code>calculate</code> function has a final CCM value of 11.</p><h3 id=ccm-increase-summary>CCM Increase Summary<a hidden class=anchor aria-hidden=true href=#ccm-increase-summary>#</a></h3><table><thead><tr><th>Code Structure</th><th>CCM Increase</th><th>Description</th></tr></thead><tbody><tr><td>Basic Complexity</td><td>1</td><td>Function starts with CCM = 1</td></tr><tr><td>if (a > b)</td><td>+1</td><td>Conditional branch</td></tr><tr><td>if (b > c) else</td><td>+1</td><td>Conditional branch with else</td></tr><tr><td>for Loop</td><td>+1</td><td>Loop introduces a new path</td></tr><tr><td>while Loop</td><td>+1</td><td>Loop introduces a new path</td></tr><tr><td>switch-case (4 cases)</td><td>+4</td><td>Each case and default adds a branch</td></tr><tr><td>if (a > 0 && b > 0)</td><td>+1</td><td>Logical AND operator adds a branch</td></tr><tr><td>if (a > 0 || c > 0)</td><td>+1</td><td>Logical OR operator adds a branch</td></tr><tr><td><strong>Total Cyclomatic Complexity</strong></td><td><strong>11</strong></td><td></td></tr></tbody></table><h2 id=importance-of-cyclomatic-complexity>Importance of Cyclomatic Complexity<a hidden class=anchor aria-hidden=true href=#importance-of-cyclomatic-complexity>#</a></h2><p>Cyclomatic Complexity is crucial for several reasons:</p><ol><li>Maintainability: High CCM indicates complex code that is harder to understand and maintain.</li><li>Testability: Higher CCM requires more test cases to achieve adequate test coverage.</li><li>Bug Risk: Complex code is more prone to bugs and errors.</li></ol><h2 id=optimizing-cyclomatic-complexity>Optimizing Cyclomatic Complexity<a hidden class=anchor aria-hidden=true href=#optimizing-cyclomatic-complexity>#</a></h2><p>To keep CCM manageable, consider the following practices:</p><ol><li>Simplify Conditional Statements: Reduce the number of nested conditions and use simpler logic.</li><li>Refactor Functions: Break down large functions into smaller, single-responsibility functions.</li><li>Minimize switch-case Statements: Use polymorphism or other design patterns to handle multiple cases.</li><li>Limit Logical Operators: Avoid excessive use of && and || in conditional statements.</li></ol><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Cyclomatic Complexity Metric (CCM) is a valuable tool for assessing and managing the complexity of your code. By understanding how different C++ structures affect CCM, you can write cleaner, more maintainable, and less error-prone code.</p><h2 id=ccm-calculation-from-compiled-code>CCM Calculation from compiled code<a hidden class=anchor aria-hidden=true href=#ccm-calculation-from-compiled-code>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>g++ ccm.cpp
</span></span><span style=display:flex><span>./a.out
</span></span><span style=display:flex><span>c is greater than or equal to b
</span></span><span style=display:flex><span>Iteration: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Iteration: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Iteration: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>Iteration: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>Iteration: <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>Count: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Count: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Count: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>Option <span style=color:#ae81ff>2</span> selected
</span></span><span style=display:flex><span>Both a and b are positive
</span></span><span style=display:flex><span>Either a or c is positive
</span></span><span style=display:flex><span>Result: <span style=color:#ae81ff>13</span>
</span></span></code></pre></div><h2 id=ccm-calculation-from-coverity>CCM Calculation from Coverity<a hidden class=anchor aria-hidden=true href=#ccm-calculation-from-coverity>#</a></h2><p><img alt="alt text" loading=lazy src=.md/cyclomatic-complexity-in-c++-code/ccm.png></p><h2 id=ccm>CCM<a hidden class=anchor aria-hidden=true href=#ccm>#</a></h2><p><a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-cyclomatic-complexity?view=vs-2022">https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-cyclomatic-complexity?view=vs-2022</a></p><p><a href=https://www.mathworks.com/help/matlab/matlab_prog/measure-code-complexity-using-cyclomatic-complexity.html>https://www.mathworks.com/help/matlab/matlab_prog/measure-code-complexity-using-cyclomatic-complexity.html</a></p><p><a href=https://www.sonarsource.com/learn/cyclomatic-complexity/>https://www.sonarsource.com/learn/cyclomatic-complexity/</a></p><h2 id=minimizing-cyclomatic-complexity-with-pattern-matching>Minimizing Cyclomatic Complexity with Pattern Matching<a hidden class=anchor aria-hidden=true href=#minimizing-cyclomatic-complexity-with-pattern-matching>#</a></h2><p><a href=https://www.danylkoweb.com/Blog/minimizing-cyclomatic-complexity-with-pattern-matching-SR>https://www.danylkoweb.com/Blog/minimizing-cyclomatic-complexity-with-pattern-matching-SR</a></p><p><a href=https://www.rhyous.com/2017/10/19/eliminating-cylclomatic-complexity-by-replacing-switchcase-with-a-method-or-a-dictionary/>https://www.rhyous.com/2017/10/19/eliminating-cylclomatic-complexity-by-replacing-switchcase-with-a-method-or-a-dictionary/</a></p><hr><h1 id=c-코드에서-여러-식과-문에서-변수-ccm의-값이-어떻게-변하는지-보여주는-예제>C++ 코드에서 여러 식과 문에서 변수 <code>CCM</code>의 값이 어떻게 변하는지 보여주는 예제<a hidden class=anchor aria-hidden=true href=#c-코드에서-여러-식과-문에서-변수-ccm의-값이-어떻게-변하는지-보여주는-예제>#</a></h1><p>C++ 코드에서 여러 식과 문에서 변수 <code>CCM</code>의 값이 어떻게 변하는지 보여주는 예제를 작성해보겠습니다. 특히 <code>switch-case</code> 문 내에서 <code>CCM</code>의 변화도 포함하겠습니다. 이 예제에서는 <code>CCM</code>을 정수형 변수로 가정하고, 다양한 연산과 제어 구조를 통해 <code>CCM</code>의 값을 변경하며 그 변화를 출력합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> CCM <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 초기값 설정
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;초기 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 단순 대입 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CCM <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;대입 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 덧셈 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CCM <span style=color:#f92672>+=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;덧셈 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 뺄셈 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CCM <span style=color:#f92672>-=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;뺄셈 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 곱셈 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CCM <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;곱셈 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 나눗셈 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (CCM <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// 0으로 나누는 것을 방지
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        CCM <span style=color:#f92672>/=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;나눗셈 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 6. 조건부 연산 (삼항 연산자)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CCM <span style=color:#f92672>=</span> (CCM <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>?</span> CCM <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> CCM <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;조건부 연산 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 7. 증감 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;증가 연산 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CCM<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;감소 연산 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 8. 비트 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CCM <span style=color:#f92672>=</span> CCM <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 왼쪽 시프트
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;비트 시프트 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CCM <span style=color:#f92672>=</span> CCM <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xF</span>; <span style=color:#75715e>// 비트 AND
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;비트 AND 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 9. 논리 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> flag <span style=color:#f92672>=</span> (CCM <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;논리 연산 후 flag 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> flag <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 10. switch-case 문에서 CCM 값 변경
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> option <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span>(option) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM <span style=color:#f92672>+=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;switch-case 1 실행 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM <span style=color:#f92672>+=</span> <span style=color:#ae81ff>200</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;switch-case 2 실행 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM <span style=color:#f92672>+=</span> <span style=color:#ae81ff>300</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;switch-case 3 실행 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM <span style=color:#f92672>+=</span> <span style=color:#ae81ff>400</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;switch-case default 실행 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 11. 반복문 내에서 CCM 값 변경
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        CCM <span style=color:#f92672>+=</span> i;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;for 루프 &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;회차 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 12. 함수 호출을 통한 CCM 값 변경
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> modifyCCM <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>](<span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>        CCM <span style=color:#f92672>+=</span> value;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;함수 호출 후 CCM 값: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> CCM <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    modifyCCM(<span style=color:#ae81ff>50</span>);
</span></span><span style=display:flex><span>    modifyCCM(<span style=color:#f92672>-</span><span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=코드-설명>코드 설명<a hidden class=anchor aria-hidden=true href=#코드-설명>#</a></h3><ol><li><p><strong>초기화 및 단순 대입:</strong></p><ul><li><code>CCM</code>을 0으로 초기화한 후, 5로 대입합니다.</li></ul></li><li><p><strong>산술 연산:</strong></p><ul><li><code>CCM</code>에 10을 더하고, 3을 빼고, 2를 곱하고, 4로 나눕니다.</li></ul></li><li><p><strong>조건부 연산:</strong></p><ul><li><code>CCM</code>이 3보다 크면 1을 더하고, 그렇지 않으면 1을 뺍니다.</li></ul></li><li><p><strong>증감 연산:</strong></p><ul><li><code>CCM</code>을 증가시키고, 다시 감소시킵니다.</li></ul></li><li><p><strong>비트 연산:</strong></p><ul><li><code>CCM</code>을 왼쪽으로 시프트하고, 0xF(15)과 비트 AND 연산을 수행합니다.</li></ul></li><li><p><strong>논리 연산:</strong></p><ul><li><code>CCM</code>이 0이 아닌지 확인하여 <code>flag</code>에 저장합니다.</li></ul></li><li><p><strong>switch-case 문:</strong></p><ul><li><code>option</code> 변수의 값에 따라 <code>CCM</code>을 다르게 변경합니다. 여기서는 <code>option</code>이 2이므로 <code>CCM += 200</code>이 실행됩니다.</li></ul></li><li><p><strong>반복문:</strong></p><ul><li><code>for</code> 루프를 통해 3번 반복하면서 <code>CCM</code>에 반복 변수 <code>i</code>를 더합니다.</li></ul></li><li><p><strong>함수 호출:</strong></p><ul><li>람다 함수를 사용하여 <code>CCM</code>을 변경하는 함수를 정의하고, 이를 호출하여 <code>CCM</code>을 더하고 빼는 연산을 수행합니다.</li></ul></li></ol><h3 id=실행-결과-예시>실행 결과 예시<a hidden class=anchor aria-hidden=true href=#실행-결과-예시>#</a></h3><pre tabindex=0><code>초기 CCM 값: 0
대입 후 CCM 값: 5
덧셈 후 CCM 값: 15
뺄셈 후 CCM 값: 12
곱셈 후 CCM 값: 24
나눗셈 후 CCM 값: 6
조건부 연산 후 CCM 값: 7
증가 연산 후 CCM 값: 8
감소 연산 후 CCM 값: 7
비트 시프트 후 CCM 값: 14
비트 AND 후 CCM 값: 14
논리 연산 후 flag 값: 1
switch-case 2 실행 후 CCM 값: 214
for 루프 1회차 후 CCM 값: 214
for 루프 2회차 후 CCM 값: 215
for 루프 3회차 후 CCM 값: 217
함수 호출 후 CCM 값: 267
함수 호출 후 CCM 값: 247
</code></pre><h3 id=추가-설명>추가 설명<a hidden class=anchor aria-hidden=true href=#추가-설명>#</a></h3><ul><li><p><strong>switch-case 문:</strong></p><ul><li><code>switch(option)</code>에서 <code>option</code>이 2이므로 <code>case 2</code> 블록이 실행되어 <code>CCM</code>에 200이 더해집니다.</li><li>다른 <code>option</code> 값을 설정하면 해당 케이스가 실행됩니다. 예를 들어, <code>option = 1</code>로 설정하면 <code>case 1</code>이 실행됩니다.</li></ul></li><li><p><strong>람다 함수:</strong></p><ul><li><code>modifyCCM</code> 람다 함수는 <code>CCM</code>을 인자로 받은 값을 더하거나 빼서 변경합니다.</li><li>함수 호출 시 <code>CCM</code>의 현재 값에 따라 변경된 값을 출력합니다.</li></ul></li></ul><p>이 예제는 다양한 C++ 연산과 제어 구조에서 변수 <code>CCM</code>의 값이 어떻게 변화하는지를 보여줍니다. 특히 <code>switch-case</code> 문 내에서의 <code>CCM</code> 값 변경을 포함하여, 여러 상황에서 <code>CCM</code>이 어떻게 변하는지를 쉽게 이해할 수 있습니다.</p><hr><h1 id=다양한-c-문과-식에서-ccm-값이-어떻게-변하는지를-보여주는-예제-코드>다양한 C++ 문과 식에서 CCM 값이 어떻게 변하는지를 보여주는 예제 코드<a hidden class=anchor aria-hidden=true href=#다양한-c-문과-식에서-ccm-값이-어떻게-변하는지를-보여주는-예제-코드>#</a></h1><p>알겠습니다. Cyclomatic Complexity Metric(CCM, 사이클로매틱 복잡도 지표)은 코드의 복잡성을 측정하는 데 사용되는 지표로, 주로 제어 흐름의 복잡성을 평가합니다. CCM은 프로그램 내의 독립적인 경로의 수를 나타내며, 유지보수성과 테스트 용이성을 평가하는 데 유용합니다.</p><p>아래는 다양한 C++ 문과 식에서 CCM 값이 어떻게 변하는지를 보여주는 예제 코드입니다. 특히 <code>switch-case</code> 문이 CCM에 미치는 영향도 포함하였습니다.</p><h2 id=cyclomatic-complexity-계산-규칙>Cyclomatic Complexity 계산 규칙<a hidden class=anchor aria-hidden=true href=#cyclomatic-complexity-계산-규칙>#</a></h2><p>Cyclomatic Complexity는 다음과 같은 규칙에 따라 계산됩니다:</p><ol><li><strong>기본 복잡도</strong>: 시작점과 종료점 사이의 선형 경로는 기본적으로 1의 복잡도를 가집니다.</li><li><strong>제어 흐름 분기</strong>: <code>if</code>, <code>while</code>, <code>for</code>, <code>case</code> 등 제어 흐름을 분기시키는 각 구조는 복잡도를 1씩 증가시킵니다.</li><li><strong>논리 연산자</strong>: <code>&&</code>, <code>||</code> 같은 논리 연산자는 추가적인 분기를 생성하여 복잡도를 증가시킬 수 있습니다.</li></ol><h2 id=예제-코드-및-ccm-설명>예제 코드 및 CCM 설명<a hidden class=anchor aria-hidden=true href=#예제-코드-및-ccm-설명>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 함수 선언
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>calculate</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> z <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> calculate(x, y, z);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;결과: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Cyclomatic Complexity가 높은 함수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>calculate</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> CCM <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 기본 복잡도
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// if 문 1: CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;</span> b) {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a가 b보다 큼&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// if-else 문 1: CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>&gt;</span> c) {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;b가 c보다 큼&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;c가 b보다 크거나 같음&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// for 루프 1: CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;반복 횟수: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// while 루프 1: CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(count <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;카운트: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> count <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// switch-case 문: 각 case마다 CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> option <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span>(option) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;옵션 1 선택&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;옵션 2 선택&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;옵션 3 선택&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;기본 옵션 선택&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 논리 연산자 사용: &amp;&amp; 또는 || 사용 시 CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// &amp;&amp; 연산자 하나로 CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a와 b가 모두 양수임&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> c <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// || 연산자 하나로 CCM += 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        CCM<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a 또는 c가 양수임&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> CCM;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=코드-설명-및-ccm-계산>코드 설명 및 CCM 계산<a hidden class=anchor aria-hidden=true href=#코드-설명-및-ccm-계산>#</a></h3><ol><li><p><strong>기본 복잡도</strong>: <code>CCM = 1</code></p></li><li><p><strong>첫 번째 <code>if</code> 문</strong>:</p><ul><li>조건문: <code>if (a > b)</code></li><li>CCM 증가: +1</li><li>현재 CCM: 2</li></ul></li><li><p><strong>두 번째 <code>if-else</code> 문</strong>:</p><ul><li>조건문: <code>if (b > c) ... else ...</code></li><li><code>if</code>와 <code>else</code>는 동일한 조건 분기이므로 CCM 증가: +1</li><li>현재 CCM: 3</li></ul></li><li><p><strong><code>for</code> 루프</strong>:</p><ul><li>조건문: <code>for(int i = 0; i &lt; 5; ++i)</code></li><li>반복문은 하나의 독립적인 경로를 추가하므로 CCM 증가: +1</li><li>현재 CCM: 4</li></ul></li><li><p><strong><code>while</code> 루프</strong>:</p><ul><li>조건문: <code>while(count &lt; 3)</code></li><li>반복문은 하나의 독립적인 경로를 추가하므로 CCM 증가: +1</li><li>현재 CCM: 5</li></ul></li><li><p><strong><code>switch-case</code> 문</strong>:</p><ul><li>각 <code>case</code>와 <code>default</code>는 별도의 분기를 생성</li><li>총 4개의 <code>case</code> (1, 2, 3, default)</li><li>CCM 증가: +4</li><li>현재 CCM: 9</li></ul></li><li><p><strong>논리 연산자 <code>&&</code> 사용</strong>:</p><ul><li>조건문: <code>if (a > 0 && b > 0)</code></li><li><code>&&</code>는 하나의 추가 분기를 생성</li><li>CCM 증가: +1</li><li>현재 CCM: 10</li></ul></li><li><p><strong>논리 연산자 <code>||</code> 사용</strong>:</p><ul><li>조건문: <code>if (a > 0 || c > 0)</code></li><li><code>||</code>는 하나의 추가 분기를 생성</li><li>CCM 증가: +1</li><li>최종 CCM: 11</li></ul></li></ol><h3 id=최종-cyclomatic-complexity>최종 Cyclomatic Complexity<a hidden class=anchor aria-hidden=true href=#최종-cyclomatic-complexity>#</a></h3><p>함수 <code>calculate</code>의 최종 CCM 값은 <strong>11</strong>입니다.</p><h3 id=ccm-증가-요약>CCM 증가 요약<a hidden class=anchor aria-hidden=true href=#ccm-증가-요약>#</a></h3><table><thead><tr><th>코드 구성 요소</th><th>CCM 증가</th><th>설명</th></tr></thead><tbody><tr><td>기본 복잡도</td><td>1</td><td>함수 시작 시 기본값</td></tr><tr><td><code>if (a > b)</code></td><td>+1</td><td>조건 분기</td></tr><tr><td><code>if (b > c) else</code></td><td>+1</td><td><code>if</code>와 <code>else</code>는 하나의 조건 분기</td></tr><tr><td><code>for</code> 루프</td><td>+1</td><td>반복문 분기</td></tr><tr><td><code>while</code> 루프</td><td>+1</td><td>반복문 분기</td></tr><tr><td><code>switch-case</code> (4 cases)</td><td>+4</td><td>각 <code>case</code>와 <code>default</code>가 별도의 분기 생성</td></tr><tr><td><code>if (a > 0 && b > 0)</code></td><td>+1</td><td>논리 연산자 <code>&&</code>에 의한 분기</td></tr><tr><td>`if (a > 0</td><td></td><td>c > 0)`</td></tr><tr><td><strong>총합</strong></td><td><strong>11</strong></td><td></td></tr></tbody></table><h2 id=cyclomatic-complexity의-중요성>Cyclomatic Complexity의 중요성<a hidden class=anchor aria-hidden=true href=#cyclomatic-complexity의-중요성>#</a></h2><p>CCM은 코드의 복잡성을 정량적으로 측정하여 다음과 같은 이점을 제공합니다:</p><ol><li><strong>유지보수성 향상</strong>: 높은 CCM은 코드가 복잡하고 이해하기 어려움을 나타내며, 이는 유지보수를 어렵게 만들 수 있습니다.</li><li><strong>테스트 용이성</strong>: 높은 CCM은 테스트 커버리지를 높이기 위해 더 많은 테스트 케이스가 필요함을 의미합니다.</li><li><strong>버그 가능성</strong>: 복잡한 코드일수록 버그가 발생할 가능성이 높아집니다.</li></ol><p>따라서, 가능한 한 낮은 CCM을 유지하는 것이 코드의 품질과 유지보수성을 향상시키는 데 도움이 됩니다.</p><h2 id=ccm-최적화-방안>CCM 최적화 방안<a hidden class=anchor aria-hidden=true href=#ccm-최적화-방안>#</a></h2><ol><li><strong>조건문 단순화</strong>: 복잡한 조건문을 단순화하거나 논리 연산자를 줄입니다.</li><li><strong>함수 분할</strong>: 하나의 함수에 너무 많은 로직을 포함하지 않고, 기능별로 작은 함수로 분할합니다.</li><li><strong>스위치 케이스 최소화</strong>: 가능한 경우 <code>switch-case</code> 대신 다른 구조를 사용하거나, 각 <code>case</code>를 별도의 함수로 분리합니다.</li><li><strong>반복문 최소화</strong>: 반복문 내의 복잡한 로직을 단순화합니다.</li></ol><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>Cyclomatic Complexity Metric(CCM)은 코드의 복잡성을 측정하고 관리하는 데 중요한 도구입니다. 위의 예제와 설명을 통해 다양한 C++ 구조에서 CCM이 어떻게 변하는지 이해할 수 있었기를 바랍니다. 코드를 작성할 때 CCM을 고려하여 가능한 한 간결하고 단순한 구조를 유지하는 것이 바람직합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jongyongpark.github.io/tags/c++/>C++</a></li><li><a href=https://jongyongpark.github.io/tags/ccm/>CCM</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jongyongpark.github.io/>RyanLabs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>