<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RyanLabs</title>
<meta name=keywords content><meta name=description content="
Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 타입과 사용 방식에 따라 결정됩니다.
스택(Stack)


특징:

고정된 크기의 데이터를 저장합니다.
함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다.
메모리 할당과 해제가 빠릅니다.



저장되는 데이터:

정수형(i32, u64 등), 부동소수점형(f32, f64), 불리언(bool), 문자(char) 등 크기가 컴파일 시에 결정되는 기본 타입.
배열([T; N]), 튜플((T1, T2, ...)) 등 고정 크기의 컬렉션 타입.



예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:"><meta name=author content><link rel=canonical href=https://jongyongpark.github.io/posts/developer/rust/rust/><link crossorigin=anonymous href=/assets/css/stylesheet.9de45e225101e4f99701d2b68fc6b8a1ef6027928be6391fa15bf7f56326c909.css integrity="sha256-neReIlEB5PmXAdK2j8a4oe9gJ5KL5jkfoVv39WMmyQk=" rel="preload stylesheet" as=style><link rel=icon href=https://jongyongpark.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jongyongpark.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jongyongpark.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jongyongpark.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jongyongpark.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jongyongpark.github.io/posts/developer/rust/rust/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://jongyongpark.github.io/posts/developer/rust/rust/"><meta property="og:site_name" content="RyanLabs"><meta property="og:title" content="RyanLabs"><meta property="og:description" content=" Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 타입과 사용 방식에 따라 결정됩니다.
스택(Stack) 특징:
고정된 크기의 데이터를 저장합니다. 함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다. 메모리 할당과 해제가 빠릅니다. 저장되는 데이터:
정수형(i32, u64 등), 부동소수점형(f32, f64), 불리언(bool), 문자(char) 등 크기가 컴파일 시에 결정되는 기본 타입. 배열([T; N]), 튜플((T1, T2, ...)) 등 고정 크기의 컬렉션 타입. 예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="
Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 타입과 사용 방식에 따라 결정됩니다.
스택(Stack)


특징:

고정된 크기의 데이터를 저장합니다.
함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다.
메모리 할당과 해제가 빠릅니다.



저장되는 데이터:

정수형(i32, u64 등), 부동소수점형(f32, f64), 불리언(bool), 문자(char) 등 크기가 컴파일 시에 결정되는 기본 타입.
배열([T; N]), 튜플((T1, T2, ...)) 등 고정 크기의 컬렉션 타입.



예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jongyongpark.github.io/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://jongyongpark.github.io/posts/developer/rust/rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":" Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 타입과 사용 방식에 따라 결정됩니다.\n스택(Stack) 특징:\n고정된 크기의 데이터를 저장합니다. 함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다. 메모리 할당과 해제가 빠릅니다. 저장되는 데이터:\n정수형(i32, u64 등), 부동소수점형(f32, f64), 불리언(bool), 문자(char) 등 크기가 컴파일 시에 결정되는 기본 타입. 배열([T; N]), 튜플((T1, T2, ...)) 등 고정 크기의 컬렉션 타입. 예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:\n","keywords":[],"articleBody":" Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 타입과 사용 방식에 따라 결정됩니다.\n스택(Stack) 특징:\n고정된 크기의 데이터를 저장합니다. 함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다. 메모리 할당과 해제가 빠릅니다. 저장되는 데이터:\n정수형(i32, u64 등), 부동소수점형(f32, f64), 불리언(bool), 문자(char) 등 크기가 컴파일 시에 결정되는 기본 타입. 배열([T; N]), 튜플((T1, T2, ...)) 등 고정 크기의 컬렉션 타입. 예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:\nfn main() { let x: i32 = 10; let y: (f64, char) = (3.14, 'A'); let arr: [u8; 3] = [1, 2, 3]; } 위의 x, y, arr 변수들은 모두 스택에 저장됩니다.\n힙(Heap) 특징:\n크기가 동적으로 결정되는 데이터를 저장합니다. 명시적으로 할당하며, 소유권 시스템을 통해 자동으로 해제됩니다. 메모리 할당과 해제가 스택보다 느립니다. 저장되는 데이터:\nString, Vec 등 크기가 동적인 컬렉션 타입. Box를 통한 힙 할당된 데이터. 예를 들어, 다음과 같은 코드는 힙에 데이터를 저장합니다:\nfn main() { let s: String = String::from(\"Hello, Rust!\"); let v: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5]; let b: Box\u003cf64\u003e = Box::new(3.14); } 위의 s, v, b 변수들은 힙에 데이터를 저장하고, 스택에는 해당 데이터에 대한 포인터와 메타데이터를 저장합니다.\n소유권과 메모리 관리 Rust는 소유권(Ownership) 시스템을 통해 메모리를 관리합니다. 각 값은 하나의 소유자만 가질 수 있으며, 소유자가 스코프를 벗어나면 메모리가 자동으로 해제됩니다. 이러한 시스템 덕분에 개발자는 명시적으로 메모리를 해제하지 않아도 메모리 누수 없이 안전한 코드를 작성할 수 있습니다.\n자세한 내용은 Comprehensive Rust의 메모리 관리에서 확인할 수 있습니다.\n요약 스택: 고정 크기의 기본 타입과 컬렉션이 저장되며, 빠른 메모리 할당과 해제를 제공합니다. 힙: 크기가 동적인 데이터가 저장되며, 소유권 시스템을 통해 자동으로 메모리가 관리됩니다. Rust의 이러한 메모리 관리 방식은 성능과 안전성을 동시에 추구하는 데 큰 장점을 제공합니다.\nRust에서 **힙(heap)**과 **스택(stack)**에 저장되는 자료형을 자세히 구분하여 설명하겠습니다. 자료형의 특성에 따라 메모리 할당 방식이 다르며, 이는 주로 크기가 컴파일 타임에 결정되는지 아니면 런타임에 결정되는지에 따라 달라집니다.\n스택(Stack) 스택은 고정 크기의 데이터가 저장되는 영역입니다. 이 영역에 저장되는 자료형은 컴파일 시 크기가 결정되어야 하며, 함수가 끝나면 자동으로 메모리가 해제됩니다. 주로 기본 타입과 크기가 고정된 자료형들이 여기에 저장됩니다.\n스택에 저장되는 자료형 정수형 (Integer Types)\n예: i32, u64, i64, u8, i8, i16, u16 정수형은 고정된 크기를 가지므로 스택에 저장됩니다. let x: i32 = 10; 부동소수점형 (Floating Point Types)\n예: f32, f64 부동소수점형 역시 크기가 고정되어 스택에 저장됩니다. let y: f64 = 3.14; 불리언형 (Boolean Type)\nbool 타입은 true 또는 false 값을 가지며, 크기가 고정되어 스택에 저장됩니다. let is_active: bool = true; 문자형 (Character Type)\nchar 타입은 하나의 유니코드 문자로 4바이트 크기를 가지며, 스택에 저장됩니다. let c: char = 'A'; 고정 크기의 배열 (Fixed-size Arrays)\n예: [i32; 5], [char; 3] 배열의 크기가 컴파일 타임에 결정되면 스택에 저장됩니다. let arr: [i32; 3] = [1, 2, 3]; 고정 크기의 튜플 (Fixed-size Tuples)\n예: (i32, f64, bool) 튜플도 고정 크기의 데이터이므로 스택에 저장됩니다. let tup: (i32, f64, bool) = (10, 3.14, true); 힙(Heap) 힙은 동적 크기의 데이터가 저장되는 영역입니다. 런타임에 크기가 결정되는 자료형이 대부분이며, 소유권 시스템에 따라 메모리가 자동으로 할당 및 해제됩니다. 힙에 저장되는 자료형은 일반적으로 크기가 변할 수 있거나 런타임에 크기를 알 수 없는 자료형입니다.\n힙에 저장되는 자료형 String\nString은 길이가 동적으로 변할 수 있는 문자열을 저장합니다. Rust에서 String은 힙에 저장됩니다. let s: String = String::from(\"Hello, Rust!\"); Vec (벡터)\nVec는 크기가 동적으로 변할 수 있는 배열입니다. 힙에 데이터를 저장하며, 벡터의 크기는 런타임에 결정됩니다. let v: Vec\u003ci32\u003e = vec![1, 2, 3]; Box\nBox는 힙에 데이터를 저장하는 스마트 포인터입니다. 값을 힙에 할당하고, 해당 값을 소유합니다. let b: Box\u003ci32\u003e = Box::new(10); HashMap\nHashMap은 키-값 쌍을 저장하는 컬렉션으로, 데이터는 힙에 저장됩니다. HashMap의 크기와 내용은 런타임에 결정됩니다. use std::collections::HashMap; let mut map = HashMap::new(); map.insert(\"key1\", 10); map.insert(\"key2\", 20); Rc (Reference Counted)\nRc는 참조 카운트를 사용하여 힙에서 값을 공유하는 스마트 포인터입니다. 여러 소유자가 값을 공유할 수 있도록 지원합니다. use std::rc::Rc; let value = Rc::new(10); Arc (Atomic Reference Counted)\nArc는 Rc와 비슷하지만, 멀티스레딩 환경에서 안전하게 사용할 수 있는 스마트 포인터입니다. use std::sync::Arc; let arc_value = Arc::new(20); 스택과 힙 간의 차이점 스택은 고정 크기의 데이터에 적합하고, 빠르게 할당과 해제됩니다. 함수 호출이 끝나면 스택에 저장된 변수들이 자동으로 제거됩니다. 힙은 동적 크기의 데이터에 적합하며, 메모리 할당과 해제가 느리지만, 런타임에 크기가 결정되는 데이터나 크기가 변할 수 있는 데이터에 유용합니다. 스택과 힙의 예시 요약 자료형 메모리 위치 설명 i32 스택 고정된 크기의 정수 타입 f64 스택 고정된 크기의 부동소수점 타입 bool 스택 고정된 크기의 불리언 타입 char 스택 고정된 크기의 문자 타입 [i32; 3] 스택 고정 크기의 배열 (i32, f64) 스택 고정 크기의 튜플 String 힙 동적 크기의 문자열 (힙에 할당) Vec 힙 동적 크기의 벡터 (힙에 할당) Box 힙 힙에 할당된 값 HashMap 힙 동적 크기의 키-값 쌍을 저장하는 컬렉션 Rc 힙 참조 카운트가 있는 스마트 포인터 Arc 힙 멀티스레드 환경에서 안전한 참조 카운트 스마트 포인터 결론 스택은 고정된 크기의 데이터를 빠르게 처리하고, 힙은 크기가 동적이거나 런타임에 할당되는 데이터를 처리합니다. Rust에서는 소유권 시스템을 통해 메모리 관리가 자동으로 이루어지며, 이를 통해 안전하고 효율적인 메모리 관리가 가능합니다. Rust에서 String, str, 그리고 string literal은 메모리 상에서 다르게 취급됩니다. 각자의 메모리 할당 방식과 특성에 대해 자세히 설명드리겠습니다. 또한, 각 자료형들이 어떻게 **참조(Reference)**를 처리하는지도 다루겠습니다.\n1. String **String**은 **힙(heap)**에 동적으로 할당되는 문자열 타입입니다. String은 크기가 동적으로 변할 수 있기 때문에, 데이터가 힙에 저장됩니다. String은 소유권을 가지며, 그 값에 대한 소유권을 이동시키거나 참조할 수 있습니다. 특성: 동적 크기: 문자열의 크기가 런타임에 결정되며, 문자열 길이에 따라 메모리가 할당됩니다. 소유권: String은 해당 값을 소유하므로, 값이 더 이상 필요하지 않으면 자동으로 메모리가 해제됩니다. 예시: fn main() { let s: String = String::from(\"Hello, Rust!\"); println!(\"{}\", s); // `s`는 소유권을 가짐 } 참조: String에 대한 참조는 \u0026String으로 받을 수 있습니다. 참조는 데이터를 읽기 전용으로 다룰 수 있으며, 소유권을 이전하지 않고 접근할 수 있습니다. fn print_string(s: \u0026String) { println!(\"{}\", s); // s는 참조형 변수 } fn main() { let s: String = String::from(\"Hello, Rust!\"); print_string(\u0026s); // s의 참조를 전달 } 2. str **str**은 슬라이스(slice) 타입으로, 문자열의 일부를 참조하는 형태입니다. str은 고정된 크기가 아니기 때문에, 일반적으로 문자열 리터럴이나 String의 일부로 사용됩니다. str 자체는 직접적으로 생성되지 않으며, \u0026str 형태로만 존재합니다. 특성: 불변: str은 불변(immutable) 데이터입니다. 슬라이스: str은 문자열에 대한 슬라이스로, 실제 데이터를 소유하지 않으며 다른 문자열에 대한 참조를 가리킵니다. 주로 사용: 주로 String에서 슬라이스를 얻거나, 문자열 리터럴로 사용됩니다. 예시: fn main() { let hello: \u0026str = \"Hello, Rust!\"; // 문자열 리터럴은 \u0026str 타입 println!(\"{}\", hello); // \u0026str은 참조 타입 } 참조: \u0026str은 String에서 얻은 불변 참조이며, \u0026String에서 슬라이스를 만들어서 사용하거나 문자열 리터럴 자체로 사용됩니다. fn print_str(s: \u0026str) { println!(\"{}\", s); // s는 \u0026str 타입, 문자열의 참조 } fn main() { let s: String = String::from(\"Hello, Rust!\"); print_str(\u0026s); // String에서 \u0026str 참조를 가져와서 전달 } 3. String Literal 문자열 리터럴(String literal)은 \u0026'static str 타입입니다. 이는 Rust에서 코드에 하드코딩된 불변 문자열입니다. 문자열 리터럴은 정적으로 메모리에 저장되며, 프로그램이 실행되는 동안 변경되지 않습니다. 문자열 리터럴은 주로 \u0026str 타입으로 다뤄집니다. 특성: 불변: 문자열 리터럴은 변경할 수 없습니다. 정적 메모리: 컴파일 타임에 메모리에 할당되며, 프로그램이 종료될 때까지 메모리에 유지됩니다. 불변 참조: 문자열 리터럴은 \u0026'static str 타입이며, 프로그램 전반에 걸쳐 참조될 수 있습니다. 예시: fn main() { let greeting: \u0026str = \"Hello, world!\"; // 문자열 리터럴 println!(\"{}\", greeting); } 참조: 문자열 리터럴은 이미 메모리에 고정되어 있기 때문에, 기본적으로 \u0026str 타입의 참조로 사용됩니다. 메모리 저장 위치 비교 자료형 메모리 위치 설명 String 힙 (Heap) 동적으로 크기가 결정되는 문자열. String은 힙에 할당됩니다. \u0026str 스택 (Stack) 문자열 리터럴이나 String의 슬라이스로, 불변 참조로 사용됩니다. 문자열 리터럴 (\"Hello\") 데이터 세그먼트 (Text Segment) 프로그램 실행 시 정적으로 메모리에 저장되며, 'static 수명이 부여됩니다. 참조 시스템 \u0026String: String에 대한 불변 참조입니다. 소유권을 이동시키지 않고 데이터를 참조할 수 있습니다. \u0026str: 문자열의 불변 참조이며, 일반적으로 String에서 얻거나 문자열 리터럴에서 사용됩니다. 예시: \u0026String vs \u0026str fn print_string(s: \u0026String) { println!(\"{}\", s); } fn print_str(s: \u0026str) { println!(\"{}\", s); } fn main() { let my_string = String::from(\"Hello, Rust!\"); // \u0026String 참조를 전달 print_string(\u0026my_string); // \u0026str 참조를 전달 print_str(\u0026my_string); // String에서 \u0026str 참조를 얻음 print_str(\"Hello, world!\"); // 문자열 리터럴은 자동으로 \u0026str 타입 } 정리 String: 힙에 저장되고, 크기가 동적으로 변할 수 있는 문자열 타입. 값에 대한 소유권을 가집니다. str: 슬라이스로, 고정된 크기의 불변 문자열을 참조하는 타입. \u0026str은 대부분 문자열 리터럴이나 String의 슬라이스에서 사용됩니다. 문자열 리터럴: \u0026'static str 타입으로, 컴파일 시 메모리에 정적으로 할당된 불변 문자열입니다. 이들을 적절하게 사용하면 메모리 효율성을 높이고, 성능 최적화에 도움이 될 수 있습니다.\n텍스트로 설명한 내용을 도표와 그림 형식으로 표현할 수 있습니다. 아래는 각 자료형(String, str, 문자열 리터럴 등)들이 메모리 상에서 어떻게 저장되는지에 대한 구조를 보여주는 간단한 다이어그램입니다.\n메모리 구조 도표 +-----------------------------------------------------------+\r| 프로그램 메모리 (프로세스 메모리) |\r+-----------------------------------------------------------+\r| 데이터 세그먼트 (Text Segment) |\r| +--------------------------------------------------------+ |\r| | 문자열 리터럴 \"Hello, world!\" | |\r| | (정적 메모리) | |\r| +--------------------------------------------------------+ |\r+-----------------------------------------------------------+\r| 힙 (Heap) |\r| +--------------------------------------------------------+ |\r| | String | |\r| | \"Hello, Rust!\" -\u003e (힙에 저장되는 동적 메모리) | |\r| +--------------------------------------------------------+ |\r+-----------------------------------------------------------+\r| 스택 (Stack) |\r| +--------------------------------------------------------+ |\r| | \u0026String -\u003e 스택에 저장된 `String`의 참조 | |\r| | \u0026str -\u003e \"Hello, world!\" (문자열 리터럴에 대한 참조) | |\r| | \u0026str -\u003e \"Hello, Rust!\" (String에서 얻은 슬라이스) | |\r| +--------------------------------------------------------+ |\r+-----------------------------------------------------------+ 메모리 구조의 상세 설명 데이터 세그먼트 (Text Segment)\n프로그램 실행 시 문자열 리터럴은 데이터 세그먼트에 정적으로 저장됩니다. 예시: \"Hello, world!\"와 같은 문자열 리터럴은 프로그램이 시작될 때 메모리에 할당되어, 실행 중에 변경되지 않는 데이터로 저장됩니다. 이 영역은 불변입니다. 힙 (Heap)\n**String**은 동적으로 메모리 할당을 받습니다. 즉, 프로그램 실행 중에 문자열의 크기가 변할 수 있기 때문에 **힙(Heap)**에 저장됩니다. 예시: String::from(\"Hello, Rust!\")로 생성된 문자열은 힙에 저장됩니다. 크기와 내용이 런타임에 결정되므로, 힙에 할당되어 관리됩니다. 스택 (Stack)\n**\u0026String**과 **\u0026str**은 참조를 나타냅니다. \u0026String은 String의 참조이고, \u0026str은 슬라이스로서 문자열에 대한 불변 참조를 가리킵니다. 예시: \u0026String은 스택에 저장된 String의 참조를 가리킵니다. \"Hello, world!\"는 리터럴이므로 **\u0026str**은 스택에 있는 \u0026'static str 참조입니다. String에서 .as_str() 메서드를 호출하면 얻은 **\u0026str**은 String의 힙 메모리 데이터를 참조합니다. 다이어그램 상세화 -------------------------------------------------------- | 프로그램 메모리 (프로세스 메모리) | -------------------------------------------------------- | 데이터 세그먼트 (Text Segment) | |------------------------------------------------------| | \"Hello, world!\" -\u003e 메모리 주소: 0x1234 | | (문자열 리터럴, 정적으로 할당된 메모리) | |------------------------------------------------------| | 힙 (Heap) | |------------------------------------------------------| | String -\u003e 0x5678 -\u003e \"Hello, Rust!\" (힙 메모리) | |------------------------------------------------------| | 스택 (Stack) | |------------------------------------------------------| | \u0026String -\u003e 0x5678 (참조, 스택에 위치) | | \u0026str -\u003e \"Hello, world!\" (문자열 리터럴에 대한 참조) | | \u0026str -\u003e \"Hello, Rust!\" (String에서 얻은 슬라이스) | -------------------------------------------------------- 참고 사항 문자열 리터럴은 프로그램이 시작될 때 메모리에 고정적으로 배치됩니다. \"Hello, world!\"와 같은 리터럴은 데이터 세그먼트에 저장되며, 불변 참조로서 스택에서 사용할 수 있습니다. **String**은 동적으로 메모리가 할당되며, 해당 값이 힙에 저장됩니다. 크기가 동적으로 변할 수 있기 때문에 런타임에 메모리가 할당되고 해제됩니다. **\u0026String**과 **\u0026str**은 모두 참조 타입입니다. 이들은 스택에 저장되며, 각각 String과 문자열 리터럴 또는 String의 슬라이스를 참조합니다. 이 그림은 각 자료형이 어떻게 메모리에서 다루어지는지, 그리고 그들 간의 관계를 직관적으로 이해하는 데 도움이 될 것입니다.\nRust의 소유권(Ownership) 시스템은 메모리 안전성을 보장하는 핵심 개념 중 하나입니다. 소유권 시스템은 **힙(Heap)**과 **스택(Stack)**을 어떻게 다루는지에 따라 중요한 특징을 갖습니다. 이 두 메모리 영역에서 소유권과 **대상(값)**이 어떻게 이동하거나 참조되는지 설명하겠습니다.\n1. 스택(Stack)과 힙(Heap) 스택(Stack): 데이터를 빠르게 할당하고 해제하는 LIFO(Last-In-First-Out) 방식의 메모리 영역입니다. 값의 크기가 고정된 타입(예: 정수, 부동 소수점, 고정 크기의 배열 등)을 주로 저장합니다. 힙(Heap): 크기가 동적으로 결정되는 데이터를 저장하는 비순차적 메모리 영역입니다. **Box, Vec, String**과 같은 동적 크기의 타입들은 힙에 저장됩니다. 2. 소유권 시스템 Rust에서 소유권 시스템은 값에 대한 소유권을 추적하여 메모리 안전성을 보장하고, 스택과 힙에 저장되는 값들이 어떻게 관리되는지 결정합니다. 이 시스템은 스택에 저장된 변수의 소유권이 어떻게 힙에 저장된 값에 영향을 미치는지에 대한 규칙을 정의합니다.\n기본 규칙: 소유권 이동 (Ownership Transfer):\n변수는 소유권을 가지며, 그 변수의 소유권이 다른 변수로 이동하면 이전 변수는 더 이상 유효하지 않습니다. 값이 스택에 저장되면 소유권 이동은 스택에 있는 변수에서 다른 변수로 이동합니다. 하지만 힙에 저장된 데이터의 경우, 데이터는 힙에 저장되고 해당 메모리 주소만 스택에 복사됩니다. 소유권 복사 (Copy):\nCopy 트레이트가 구현된 타입들은 소유권 이동 없이 데이터를 복사할 수 있습니다. 예를 들어, 정수형 타입(i32, f64)이나 배열과 같은 크기가 고정된 타입들은 소유권을 이동하지 않고 복사할 수 있습니다. 불변 참조와 가변 참조 (Immutable and Mutable References):\n불변 참조(예: \u0026T)는 데이터를 읽기 전용으로 참조할 수 있고, 가변 참조(예: \u0026mut T)는 데이터를 수정할 수 있습니다. 가변 참조는 한 번에 하나만 존재할 수 있습니다. 따라서 하나의 값에 대해 가변 참조와 불변 참조가 동시에 존재할 수 없습니다. 3. 스택에서의 소유권 스택에 저장된 값은 스코프가 끝날 때 자동으로 해제됩니다. 스택에 있는 변수는 고정 크기여서 메모리에서 쉽게 관리할 수 있습니다. 스택에 저장된 값은 소유권이 함수나 변수 간에 이동할 때, 해당 변수가 끝날 때 자동으로 메모리에서 제거됩니다.\n예시 1: 정수형 타입 (Copy) fn main() { let x = 10; // x는 스택에 저장되고 소유권을 가짐 let y = x; // x의 값을 y로 복사(이 경우는 Copy가 가능) println!(\"x: {}, y: {}\", x, y); // x와 y는 각각 독립된 값 } 이 예제에서 x는 정수 10을 스택에 저장합니다. y = x에서 x의 값은 복사됩니다. 따라서 x와 y는 서로 독립적인 값을 가집니다. 예시 2: 구조체 타입 (Move) struct MyStruct { value: i32, } fn main() { let a = MyStruct { value: 10 }; let b = a; // a의 소유권이 b로 이동 // println!(\"{}\", a.value); // 오류: a는 더 이상 유효하지 않음 } 이 예제에서 a는 MyStruct를 소유합니다. b = a에서 a의 소유권이 b로 이동합니다. a는 더 이상 유효하지 않으며, a를 참조하려고 하면 오류가 발생합니다. 4. 힙에서의 소유권 힙에 저장된 값은 동적 메모리 할당을 통해 관리되며, 스택에 저장된 포인터만이 힙에 저장된 데이터를 가리킵니다. 데이터 자체는 힙에 저장되며, 소유권이 이동하면 힙의 메모리 역시 관리됩니다.\n예시 3: String (힙 메모리 할당) fn main() { let s1 = String::from(\"Hello\"); // String은 힙에 저장 let s2 = s1; // s1의 소유권이 s2로 이동 // println!(\"{}\", s1); // 오류: s1은 더 이상 유효하지 않음 } 이 예제에서 String은 힙에 저장됩니다. s1의 소유권이 s2로 이동하면, 더 이상 s1을 사용할 수 없습니다. 힙에 할당된 메모리는 s2가 끝날 때 자동으로 해제됩니다. 예시 4: Vec (동적 배열) fn main() { let v1 = vec![1, 2, 3]; // v1은 힙에 저장된 동적 배열 let v2 = v1; // v1의 소유권이 v2로 이동 // println!(\"{:?}\", v1); // 오류: v1은 더 이상 유효하지 않음 } Vec은 힙에 저장된 데이터입니다. v1의 소유권이 v2로 이동하면 v1은 더 이상 유효하지 않으며, 힙에 있는 메모리는 v2가 끝날 때 자동으로 해제됩니다. 5. 소유권과 참조의 관계 불변 참조 (\u0026T): 스택에 참조를 저장합니다. 힙에 있는 값을 가리킬 수 있으며, 참조된 값은 변경할 수 없습니다. 가변 참조 (\u0026mut T): 하나의 값에 대해 하나의 가변 참조만 존재할 수 있습니다. 가변 참조는 값의 소유권을 변경하지 않지만, 값을 변경할 수 있습니다. 예시 5: 참조를 사용한 예 fn main() { let s1 = String::from(\"Hello\"); let s2 = \u0026s1; // 불변 참조 println!(\"{}\", s2); // s2는 s1의 불변 참조 // s1의 소유권은 여전히 s1에게 있음 } 이 예제에서 s2는 s1의 불변 참조입니다. s2는 s1의 값을 변경할 수 없으며, s1의 소유권은 여전히 s1이 가지고 있습니다. 정리 스택에 저장되는 값들은 고정 크기의 타입(예: i32, bool, char)이나 참조 타입이며, 함수나 변수의 스코프를 벗어나면 자동으로 해제됩니다. 힙에 저장되는 값들은 동적 크기(예: String, Vec, Box)를 가지며, 값은 힙에 저장되지만, 그 값을 가리키는 스택 포인터가 존재합니다. 소유권은 데이터가 힙에 있을 때, 스택에서의 변수 간에 이동하는 형태로 다루어지며, 참조를 통해 값에 접근하거나, 값을 이동시킬 수 있습니다. ","wordCount":"2397","inLanguage":"ko","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://jongyongpark.github.io/posts/developer/rust/rust/"},"publisher":{"@type":"Organization","name":"RyanLabs","logo":{"@type":"ImageObject","url":"https://jongyongpark.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jongyongpark.github.io/ accesskey=h title="RyanLabs (Alt + H)">RyanLabs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jongyongpark.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://jongyongpark.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://jongyongpark.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://jongyongpark.github.io/archives/ title=연도><span>연도</span></a></li><li><a href=https://jongyongpark.github.io/lectures/ title=강의><span>강의</span></a></li><li><a href=https://jongyongpark.github.io/about/ title=어바웃미><span>어바웃미</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h1 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h1><p>Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 <strong>타입</strong>과 <strong>사용 방식</strong>에 따라 결정됩니다.</p><h3 id=스택stack>스택(Stack)<a hidden class=anchor aria-hidden=true href=#스택stack>#</a></h3><ul><li><p><strong>특징</strong>:</p><ul><li>고정된 크기의 데이터를 저장합니다.</li><li>함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다.</li><li>메모리 할당과 해제가 빠릅니다.</li></ul></li><li><p><strong>저장되는 데이터</strong>:</p><ul><li>정수형(<code>i32</code>, <code>u64</code> 등), 부동소수점형(<code>f32</code>, <code>f64</code>), 불리언(<code>bool</code>), 문자(<code>char</code>) 등 <strong>크기가 컴파일 시에 결정되는 기본 타입</strong>.</li><li>배열(<code>[T; N]</code>), 튜플(<code>(T1, T2, ...)</code>) 등 <strong>고정 크기의 컬렉션 타입</strong>.</li></ul></li></ul><p>예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y: (<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>char</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>3.14</span>, <span style=color:#e6db74>&#39;A&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> arr: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위의 <code>x</code>, <code>y</code>, <code>arr</code> 변수들은 모두 스택에 저장됩니다.</p><h3 id=힙heap>힙(Heap)<a hidden class=anchor aria-hidden=true href=#힙heap>#</a></h3><ul><li><p><strong>특징</strong>:</p><ul><li>크기가 동적으로 결정되는 데이터를 저장합니다.</li><li>명시적으로 할당하며, 소유권 시스템을 통해 자동으로 해제됩니다.</li><li>메모리 할당과 해제가 스택보다 느립니다.</li></ul></li><li><p><strong>저장되는 데이터</strong>:</p><ul><li><code>String</code>, <code>Vec&lt;T></code> 등 <strong>크기가 동적인 컬렉션 타입</strong>.</li><li><code>Box&lt;T></code>를 통한 <strong>힙 할당된 데이터</strong>.</li></ul></li></ul><p>예를 들어, 다음과 같은 코드는 힙에 데이터를 저장합니다:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s: String <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello, Rust!&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b: Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>3.14</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위의 <code>s</code>, <code>v</code>, <code>b</code> 변수들은 힙에 데이터를 저장하고, 스택에는 해당 데이터에 대한 포인터와 메타데이터를 저장합니다.</p><h3 id=소유권과-메모리-관리>소유권과 메모리 관리<a hidden class=anchor aria-hidden=true href=#소유권과-메모리-관리>#</a></h3><p>Rust는 <strong>소유권(Ownership)</strong> 시스템을 통해 메모리를 관리합니다. 각 값은 하나의 소유자만 가질 수 있으며, 소유자가 스코프를 벗어나면 메모리가 자동으로 해제됩니다. 이러한 시스템 덕분에 개발자는 명시적으로 메모리를 해제하지 않아도 메모리 누수 없이 안전한 코드를 작성할 수 있습니다.</p><p>자세한 내용은 <a href=https://google.github.io/comprehensive-rust/ko/memory-management/approaches.html>Comprehensive Rust의 메모리 관리</a>에서 확인할 수 있습니다.</p><h3 id=요약>요약<a hidden class=anchor aria-hidden=true href=#요약>#</a></h3><ul><li><strong>스택</strong>: 고정 크기의 기본 타입과 컬렉션이 저장되며, 빠른 메모리 할당과 해제를 제공합니다.</li><li><strong>힙</strong>: 크기가 동적인 데이터가 저장되며, 소유권 시스템을 통해 자동으로 메모리가 관리됩니다.</li></ul><p>Rust의 이러한 메모리 관리 방식은 성능과 안전성을 동시에 추구하는 데 큰 장점을 제공합니다.</p><h1 id=heading-1><a hidden class=anchor aria-hidden=true href=#heading-1>#</a></h1><p>Rust에서 **힙(heap)**과 **스택(stack)**에 저장되는 자료형을 자세히 구분하여 설명하겠습니다. 자료형의 특성에 따라 메모리 할당 방식이 다르며, 이는 주로 <strong>크기</strong>가 <strong>컴파일 타임에 결정되는지</strong> 아니면 <strong>런타임에 결정되는지</strong>에 따라 달라집니다.</p><h3 id=스택stack-1><strong>스택(Stack)</strong><a hidden class=anchor aria-hidden=true href=#스택stack-1>#</a></h3><p>스택은 <strong>고정 크기</strong>의 데이터가 저장되는 영역입니다. 이 영역에 저장되는 자료형은 컴파일 시 크기가 결정되어야 하며, 함수가 끝나면 자동으로 메모리가 해제됩니다. 주로 기본 타입과 크기가 고정된 자료형들이 여기에 저장됩니다.</p><h4 id=스택에-저장되는-자료형><strong>스택에 저장되는 자료형</strong><a hidden class=anchor aria-hidden=true href=#스택에-저장되는-자료형>#</a></h4><ol><li><p><strong>정수형 (Integer Types)</strong></p><ul><li>예: <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u8</code>, <code>i8</code>, <code>i16</code>, <code>u16</code></li><li>정수형은 고정된 크기를 가지므로 스택에 저장됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> x: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div></li><li><p><strong>부동소수점형 (Floating Point Types)</strong></p><ul><li>예: <code>f32</code>, <code>f64</code></li><li>부동소수점형 역시 크기가 고정되어 스택에 저장됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> y: <span style=color:#66d9ef>f64</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14</span>;
</span></span></code></pre></div></li><li><p><strong>불리언형 (Boolean Type)</strong></p><ul><li><code>bool</code> 타입은 <code>true</code> 또는 <code>false</code> 값을 가지며, 크기가 고정되어 스택에 저장됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> is_active: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span></code></pre></div></li><li><p><strong>문자형 (Character Type)</strong></p><ul><li><code>char</code> 타입은 하나의 유니코드 문자로 4바이트 크기를 가지며, 스택에 저장됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> c: <span style=color:#66d9ef>char</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span>;
</span></span></code></pre></div></li><li><p><strong>고정 크기의 배열 (Fixed-size Arrays)</strong></p><ul><li>예: <code>[i32; 5]</code>, <code>[char; 3]</code></li><li>배열의 크기가 컴파일 타임에 결정되면 스택에 저장됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> arr: [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span></code></pre></div></li><li><p><strong>고정 크기의 튜플 (Fixed-size Tuples)</strong></p><ul><li>예: <code>(i32, f64, bool)</code></li><li>튜플도 고정 크기의 데이터이므로 스택에 저장됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> tup: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>bool</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>3.14</span>, <span style=color:#66d9ef>true</span>);
</span></span></code></pre></div></li></ol><h3 id=힙heap-1><strong>힙(Heap)</strong><a hidden class=anchor aria-hidden=true href=#힙heap-1>#</a></h3><p>힙은 <strong>동적 크기</strong>의 데이터가 저장되는 영역입니다. 런타임에 크기가 결정되는 자료형이 대부분이며, <strong>소유권 시스템</strong>에 따라 메모리가 자동으로 할당 및 해제됩니다. 힙에 저장되는 자료형은 일반적으로 <strong>크기가 변할 수 있거나 런타임에 크기를 알 수 없는</strong> 자료형입니다.</p><h4 id=힙에-저장되는-자료형><strong>힙에 저장되는 자료형</strong><a hidden class=anchor aria-hidden=true href=#힙에-저장되는-자료형>#</a></h4><ol><li><p><strong><code>String</code></strong></p><ul><li><code>String</code>은 길이가 동적으로 변할 수 있는 문자열을 저장합니다. Rust에서 <code>String</code>은 힙에 저장됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> s: String <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello, Rust!&#34;</span>);
</span></span></code></pre></div></li><li><p><strong><code>Vec&lt;T></code> (벡터)</strong></p><ul><li><code>Vec&lt;T></code>는 크기가 동적으로 변할 수 있는 배열입니다. 힙에 데이터를 저장하며, 벡터의 크기는 런타임에 결정됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> v: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span></code></pre></div></li><li><p><strong><code>Box&lt;T></code></strong></p><ul><li><code>Box&lt;T></code>는 힙에 데이터를 저장하는 스마트 포인터입니다. 값을 힙에 할당하고, 해당 값을 소유합니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> b: Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>10</span>);
</span></span></code></pre></div></li><li><p><strong><code>HashMap&lt;K, V></code></strong></p><ul><li><code>HashMap</code>은 키-값 쌍을 저장하는 컬렉션으로, 데이터는 힙에 저장됩니다. <code>HashMap</code>의 크기와 내용은 런타임에 결정됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::collections::HashMap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> map <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>map.insert(<span style=color:#e6db74>&#34;key1&#34;</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>map.insert(<span style=color:#e6db74>&#34;key2&#34;</span>, <span style=color:#ae81ff>20</span>);
</span></span></code></pre></div></li><li><p><strong><code>Rc&lt;T></code> (Reference Counted)</strong></p><ul><li><code>Rc&lt;T></code>는 참조 카운트를 사용하여 힙에서 값을 공유하는 스마트 포인터입니다. 여러 소유자가 값을 공유할 수 있도록 지원합니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::rc::Rc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> Rc::new(<span style=color:#ae81ff>10</span>);
</span></span></code></pre></div></li><li><p><strong><code>Arc&lt;T></code> (Atomic Reference Counted)</strong></p><ul><li><code>Arc&lt;T></code>는 <code>Rc&lt;T></code>와 비슷하지만, 멀티스레딩 환경에서 안전하게 사용할 수 있는 스마트 포인터입니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::Arc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> arc_value <span style=color:#f92672>=</span> Arc::new(<span style=color:#ae81ff>20</span>);
</span></span></code></pre></div></li></ol><h3 id=스택과-힙-간의-차이점><strong>스택과 힙 간의 차이점</strong><a hidden class=anchor aria-hidden=true href=#스택과-힙-간의-차이점>#</a></h3><ul><li><strong>스택</strong>은 <strong>고정 크기</strong>의 데이터에 적합하고, 빠르게 할당과 해제됩니다. 함수 호출이 끝나면 스택에 저장된 변수들이 자동으로 제거됩니다.</li><li><strong>힙</strong>은 <strong>동적 크기</strong>의 데이터에 적합하며, 메모리 할당과 해제가 <strong>느리지만</strong>, 런타임에 크기가 결정되는 데이터나 크기가 변할 수 있는 데이터에 유용합니다.</li></ul><h3 id=스택과-힙의-예시-요약><strong>스택과 힙의 예시 요약</strong><a hidden class=anchor aria-hidden=true href=#스택과-힙의-예시-요약>#</a></h3><table><thead><tr><th>자료형</th><th>메모리 위치</th><th>설명</th></tr></thead><tbody><tr><td><code>i32</code></td><td>스택</td><td>고정된 크기의 정수 타입</td></tr><tr><td><code>f64</code></td><td>스택</td><td>고정된 크기의 부동소수점 타입</td></tr><tr><td><code>bool</code></td><td>스택</td><td>고정된 크기의 불리언 타입</td></tr><tr><td><code>char</code></td><td>스택</td><td>고정된 크기의 문자 타입</td></tr><tr><td><code>[i32; 3]</code></td><td>스택</td><td>고정 크기의 배열</td></tr><tr><td><code>(i32, f64)</code></td><td>스택</td><td>고정 크기의 튜플</td></tr><tr><td><code>String</code></td><td>힙</td><td>동적 크기의 문자열 (힙에 할당)</td></tr><tr><td><code>Vec&lt;i32></code></td><td>힙</td><td>동적 크기의 벡터 (힙에 할당)</td></tr><tr><td><code>Box&lt;i32></code></td><td>힙</td><td>힙에 할당된 값</td></tr><tr><td><code>HashMap</code></td><td>힙</td><td>동적 크기의 키-값 쌍을 저장하는 컬렉션</td></tr><tr><td><code>Rc&lt;T></code></td><td>힙</td><td>참조 카운트가 있는 스마트 포인터</td></tr><tr><td><code>Arc&lt;T></code></td><td>힙</td><td>멀티스레드 환경에서 안전한 참조 카운트 스마트 포인터</td></tr></tbody></table><h3 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h3><ul><li><strong>스택</strong>은 고정된 크기의 데이터를 빠르게 처리하고, <strong>힙</strong>은 크기가 동적이거나 런타임에 할당되는 데이터를 처리합니다.</li><li>Rust에서는 <strong>소유권 시스템</strong>을 통해 메모리 관리가 자동으로 이루어지며, 이를 통해 안전하고 효율적인 메모리 관리가 가능합니다.</li></ul><h1 id=heading-2><a hidden class=anchor aria-hidden=true href=#heading-2>#</a></h1><p>Rust에서 <code>String</code>, <code>str</code>, 그리고 <strong>string literal</strong>은 메모리 상에서 다르게 취급됩니다. 각자의 메모리 할당 방식과 특성에 대해 자세히 설명드리겠습니다. 또한, 각 자료형들이 어떻게 **참조(Reference)**를 처리하는지도 다루겠습니다.</p><h3 id=1-string>1. <strong><code>String</code></strong><a hidden class=anchor aria-hidden=true href=#1-string>#</a></h3><ul><li>**<code>String</code>**은 **힙(heap)**에 동적으로 할당되는 문자열 타입입니다. <code>String</code>은 크기가 동적으로 변할 수 있기 때문에, 데이터가 힙에 저장됩니다. <code>String</code>은 <strong>소유권</strong>을 가지며, 그 값에 대한 소유권을 이동시키거나 참조할 수 있습니다.</li></ul><h4 id=특성>특성:<a hidden class=anchor aria-hidden=true href=#특성>#</a></h4><ul><li><strong>동적 크기</strong>: 문자열의 크기가 런타임에 결정되며, 문자열 길이에 따라 메모리가 할당됩니다.</li><li><strong>소유권</strong>: <code>String</code>은 해당 값을 소유하므로, 값이 더 이상 필요하지 않으면 자동으로 메모리가 해제됩니다.</li></ul><h4 id=예시>예시:<a hidden class=anchor aria-hidden=true href=#예시>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s: String <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello, Rust!&#34;</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s);  <span style=color:#75715e>// `s`는 소유권을 가짐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><strong>참조</strong>: <code>String</code>에 대한 참조는 <code>&amp;String</code>으로 받을 수 있습니다. 참조는 데이터를 <strong>읽기 전용</strong>으로 다룰 수 있으며, 소유권을 이전하지 않고 접근할 수 있습니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_string</span>(s: <span style=color:#66d9ef>&amp;</span>String) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s); <span style=color:#75715e>// s는 참조형 변수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s: String <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello, Rust!&#34;</span>);
</span></span><span style=display:flex><span>    print_string(<span style=color:#f92672>&amp;</span>s); <span style=color:#75715e>// s의 참조를 전달
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=2-str>2. <strong><code>str</code></strong><a hidden class=anchor aria-hidden=true href=#2-str>#</a></h3><ul><li>**<code>str</code>**은 <strong>슬라이스(slice)</strong> 타입으로, 문자열의 일부를 참조하는 형태입니다. <code>str</code>은 <strong>고정된 크기</strong>가 아니기 때문에, 일반적으로 문자열 리터럴이나 <code>String</code>의 일부로 사용됩니다. <code>str</code> 자체는 직접적으로 생성되지 않으며, <strong><code>&amp;str</code></strong> 형태로만 존재합니다.</li></ul><h4 id=특성-1>특성:<a hidden class=anchor aria-hidden=true href=#특성-1>#</a></h4><ul><li><strong>불변</strong>: <code>str</code>은 <strong>불변(immutable)</strong> 데이터입니다.</li><li><strong>슬라이스</strong>: <code>str</code>은 문자열에 대한 슬라이스로, 실제 데이터를 소유하지 않으며 다른 문자열에 대한 참조를 가리킵니다.</li><li><strong>주로 사용</strong>: 주로 <code>String</code>에서 슬라이스를 얻거나, 문자열 리터럴로 사용됩니다.</li></ul><h4 id=예시-1>예시:<a hidden class=anchor aria-hidden=true href=#예시-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> hello: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, Rust!&#34;</span>;  <span style=color:#75715e>// 문자열 리터럴은 &amp;str 타입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, hello);  <span style=color:#75715e>// &amp;str은 참조 타입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><strong>참조</strong>: <code>&amp;str</code>은 <code>String</code>에서 얻은 <strong>불변 참조</strong>이며, <code>&amp;String</code>에서 슬라이스를 만들어서 사용하거나 문자열 리터럴 자체로 사용됩니다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_str</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s);  <span style=color:#75715e>// s는 &amp;str 타입, 문자열의 참조
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s: String <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello, Rust!&#34;</span>);
</span></span><span style=display:flex><span>    print_str(<span style=color:#f92672>&amp;</span>s);  <span style=color:#75715e>// String에서 &amp;str 참조를 가져와서 전달
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=3-string-literal>3. <strong>String Literal</strong><a hidden class=anchor aria-hidden=true href=#3-string-literal>#</a></h3><ul><li><strong>문자열 리터럴</strong>(String literal)은 <strong><code>&'static str</code></strong> 타입입니다. 이는 Rust에서 코드에 하드코딩된 <strong>불변 문자열</strong>입니다. 문자열 리터럴은 <strong>정적으로</strong> 메모리에 저장되며, 프로그램이 실행되는 동안 변경되지 않습니다. 문자열 리터럴은 주로 <code>&amp;str</code> 타입으로 다뤄집니다.</li></ul><h4 id=특성-2>특성:<a hidden class=anchor aria-hidden=true href=#특성-2>#</a></h4><ul><li><strong>불변</strong>: 문자열 리터럴은 변경할 수 없습니다.</li><li><strong>정적 메모리</strong>: 컴파일 타임에 메모리에 할당되며, 프로그램이 종료될 때까지 메모리에 유지됩니다.</li><li><strong>불변 참조</strong>: 문자열 리터럴은 <code>&'static str</code> 타입이며, 프로그램 전반에 걸쳐 참조될 수 있습니다.</li></ul><h4 id=예시-2>예시:<a hidden class=anchor aria-hidden=true href=#예시-2>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> greeting: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, world!&#34;</span>;  <span style=color:#75715e>// 문자열 리터럴
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, greeting);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>참조</strong>: 문자열 리터럴은 이미 메모리에 고정되어 있기 때문에, 기본적으로 <code>&amp;str</code> 타입의 참조로 사용됩니다.</li></ul><hr><h3 id=메모리-저장-위치-비교><strong>메모리 저장 위치 비교</strong><a hidden class=anchor aria-hidden=true href=#메모리-저장-위치-비교>#</a></h3><table><thead><tr><th>자료형</th><th>메모리 위치</th><th>설명</th></tr></thead><tbody><tr><td><code>String</code></td><td>힙 (Heap)</td><td>동적으로 크기가 결정되는 문자열. <code>String</code>은 힙에 할당됩니다.</td></tr><tr><td><code>&amp;str</code></td><td>스택 (Stack)</td><td>문자열 리터럴이나 <code>String</code>의 슬라이스로, 불변 참조로 사용됩니다.</td></tr><tr><td>문자열 리터럴 (<code>"Hello"</code>)</td><td>데이터 세그먼트 (Text Segment)</td><td>프로그램 실행 시 정적으로 메모리에 저장되며, <code>'static</code> 수명이 부여됩니다.</td></tr></tbody></table><h3 id=참조-시스템><strong>참조 시스템</strong><a hidden class=anchor aria-hidden=true href=#참조-시스템>#</a></h3><ul><li><strong><code>&amp;String</code></strong>: <code>String</code>에 대한 <strong>불변 참조</strong>입니다. 소유권을 이동시키지 않고 데이터를 참조할 수 있습니다.</li><li><strong><code>&amp;str</code></strong>: 문자열의 <strong>불변 참조</strong>이며, 일반적으로 <code>String</code>에서 얻거나 문자열 리터럴에서 사용됩니다.</li></ul><h4 id=예시-string-vs-str>예시: <code>&amp;String</code> vs <code>&amp;str</code><a hidden class=anchor aria-hidden=true href=#예시-string-vs-str>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_string</span>(s: <span style=color:#66d9ef>&amp;</span>String) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_str</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> my_string <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello, Rust!&#34;</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &amp;String 참조를 전달
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    print_string(<span style=color:#f92672>&amp;</span>my_string);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &amp;str 참조를 전달
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    print_str(<span style=color:#f92672>&amp;</span>my_string); <span style=color:#75715e>// String에서 &amp;str 참조를 얻음
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    print_str(<span style=color:#e6db74>&#34;Hello, world!&#34;</span>); <span style=color:#75715e>// 문자열 리터럴은 자동으로 &amp;str 타입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><hr><h3 id=정리><strong>정리</strong><a hidden class=anchor aria-hidden=true href=#정리>#</a></h3><ul><li><strong><code>String</code></strong>: 힙에 저장되고, 크기가 동적으로 변할 수 있는 문자열 타입. 값에 대한 소유권을 가집니다.</li><li><strong><code>str</code></strong>: 슬라이스로, 고정된 크기의 불변 문자열을 참조하는 타입. <code>&amp;str</code>은 대부분 문자열 리터럴이나 <code>String</code>의 슬라이스에서 사용됩니다.</li><li><strong>문자열 리터럴</strong>: <code>&'static str</code> 타입으로, 컴파일 시 메모리에 정적으로 할당된 불변 문자열입니다.</li></ul><p>이들을 적절하게 사용하면 메모리 효율성을 높이고, 성능 최적화에 도움이 될 수 있습니다.</p><h1 id=heading-3><a hidden class=anchor aria-hidden=true href=#heading-3>#</a></h1><p>텍스트로 설명한 내용을 도표와 그림 형식으로 표현할 수 있습니다. 아래는 각 자료형(<code>String</code>, <code>str</code>, 문자열 리터럴 등)들이 메모리 상에서 어떻게 저장되는지에 대한 구조를 보여주는 간단한 다이어그램입니다.</p><h3 id=메모리-구조-도표><strong>메모리 구조 도표</strong><a hidden class=anchor aria-hidden=true href=#메모리-구조-도표>#</a></h3><pre tabindex=0><code>+-----------------------------------------------------------+
|                프로그램 메모리 (프로세스 메모리)                 |
+-----------------------------------------------------------+
|               데이터 세그먼트 (Text Segment)                  |
|  +--------------------------------------------------------+  |
|  |                문자열 리터럴 &#34;Hello, world!&#34;              |  |
|  |                (정적 메모리)                              |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
|                힙 (Heap)                                      |
|  +--------------------------------------------------------+  |
|  |                        String                            |  |
|  |    &#34;Hello, Rust!&#34; -&gt; (힙에 저장되는 동적 메모리)             |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
|                스택 (Stack)                                   |
|  +--------------------------------------------------------+  |
|  |    &amp;String -&gt; 스택에 저장된 `String`의 참조               |  |
|  |    &amp;str -&gt; &#34;Hello, world!&#34; (문자열 리터럴에 대한 참조)      |  |
|  |    &amp;str -&gt; &#34;Hello, Rust!&#34; (String에서 얻은 슬라이스)       |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
</code></pre><h3 id=메모리-구조의-상세-설명><strong>메모리 구조의 상세 설명</strong><a hidden class=anchor aria-hidden=true href=#메모리-구조의-상세-설명>#</a></h3><ol><li><p><strong>데이터 세그먼트 (Text Segment)</strong></p><ul><li>프로그램 실행 시 <strong>문자열 리터럴</strong>은 데이터 세그먼트에 <strong>정적으로</strong> 저장됩니다.</li><li>예시: <code>"Hello, world!"</code>와 같은 문자열 리터럴은 프로그램이 시작될 때 메모리에 할당되어, 실행 중에 변경되지 않는 데이터로 저장됩니다. 이 영역은 <strong>불변</strong>입니다.</li></ul></li><li><p><strong>힙 (Heap)</strong></p><ul><li>**<code>String</code>**은 동적으로 메모리 할당을 받습니다. 즉, 프로그램 실행 중에 문자열의 크기가 변할 수 있기 때문에 **힙(Heap)**에 저장됩니다.</li><li>예시: <code>String::from("Hello, Rust!")</code>로 생성된 문자열은 힙에 저장됩니다. 크기와 내용이 런타임에 결정되므로, 힙에 할당되어 관리됩니다.</li></ul></li><li><p><strong>스택 (Stack)</strong></p><ul><li>**<code>&amp;String</code>**과 **<code>&amp;str</code>**은 <strong>참조</strong>를 나타냅니다. <code>&amp;String</code>은 <code>String</code>의 참조이고, <code>&amp;str</code>은 <strong>슬라이스</strong>로서 문자열에 대한 불변 참조를 가리킵니다.</li><li>예시:<ul><li><code>&amp;String</code>은 스택에 저장된 <code>String</code>의 <strong>참조</strong>를 가리킵니다.</li><li><code>"Hello, world!"</code>는 리터럴이므로 **<code>&amp;str</code>**은 스택에 있는 <strong><code>&'static str</code></strong> 참조입니다.</li><li><code>String</code>에서 <code>.as_str()</code> 메서드를 호출하면 얻은 **<code>&amp;str</code>**은 <code>String</code>의 힙 메모리 데이터를 참조합니다.</li></ul></li></ul></li></ol><h3 id=다이어그램-상세화><strong>다이어그램 상세화</strong><a hidden class=anchor aria-hidden=true href=#다이어그램-상세화>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>--------------------------------------------------------
</span></span><span style=display:flex><span>|                프로그램 메모리 (프로세스 메모리)         |
</span></span><span style=display:flex><span>--------------------------------------------------------
</span></span><span style=display:flex><span>| 데이터 세그먼트 (Text Segment)                         |
</span></span><span style=display:flex><span>|------------------------------------------------------|
</span></span><span style=display:flex><span>|   &#34;Hello, world!&#34; -&gt;  메모리 주소: 0x1234             |
</span></span><span style=display:flex><span>|   (문자열 리터럴, 정적으로 할당된 메모리)               |
</span></span><span style=display:flex><span>|------------------------------------------------------|
</span></span><span style=display:flex><span>| 힙 (Heap)                                              |
</span></span><span style=display:flex><span>|------------------------------------------------------|
</span></span><span style=display:flex><span>|   String -&gt; 0x5678 -&gt; &#34;Hello, Rust!&#34; (힙 메모리)       |
</span></span><span style=display:flex><span>|------------------------------------------------------|
</span></span><span style=display:flex><span>| 스택 (Stack)                                           |
</span></span><span style=display:flex><span>|------------------------------------------------------|
</span></span><span style=display:flex><span>|   &amp;String -&gt; 0x5678 (참조, 스택에 위치)                |
</span></span><span style=display:flex><span>|   &amp;str -&gt; &#34;Hello, world!&#34; (문자열 리터럴에 대한 참조)   |
</span></span><span style=display:flex><span>|   &amp;str -&gt; &#34;Hello, Rust!&#34; (String에서 얻은 슬라이스)     |
</span></span><span style=display:flex><span>--------------------------------------------------------
</span></span></code></pre></div><h3 id=참고-사항><strong>참고 사항</strong><a hidden class=anchor aria-hidden=true href=#참고-사항>#</a></h3><ul><li><strong>문자열 리터럴</strong>은 프로그램이 시작될 때 메모리에 고정적으로 배치됩니다. <code>"Hello, world!"</code>와 같은 리터럴은 <strong>데이터 세그먼트</strong>에 저장되며, 불변 참조로서 스택에서 사용할 수 있습니다.</li><li>**<code>String</code>**은 동적으로 메모리가 할당되며, 해당 값이 힙에 저장됩니다. 크기가 동적으로 변할 수 있기 때문에 런타임에 메모리가 할당되고 해제됩니다.</li><li>**<code>&amp;String</code>**과 **<code>&amp;str</code>**은 모두 <strong>참조 타입</strong>입니다. 이들은 스택에 저장되며, 각각 <code>String</code>과 문자열 리터럴 또는 <code>String</code>의 슬라이스를 참조합니다.</li></ul><hr><p>이 그림은 각 자료형이 어떻게 메모리에서 다루어지는지, 그리고 그들 간의 관계를 직관적으로 이해하는 데 도움이 될 것입니다.</p><h1 id=heading-4><a hidden class=anchor aria-hidden=true href=#heading-4>#</a></h1><p>Rust의 <strong>소유권(Ownership)</strong> 시스템은 메모리 안전성을 보장하는 핵심 개념 중 하나입니다. 소유권 시스템은 **힙(Heap)**과 **스택(Stack)**을 어떻게 다루는지에 따라 중요한 특징을 갖습니다. 이 두 메모리 영역에서 <strong>소유권</strong>과 **대상(값)**이 어떻게 이동하거나 참조되는지 설명하겠습니다.</p><h3 id=1-스택stack과-힙heap>1. <strong>스택(Stack)과 힙(Heap)</strong><a hidden class=anchor aria-hidden=true href=#1-스택stack과-힙heap>#</a></h3><ul><li><strong>스택(Stack)</strong>: 데이터를 빠르게 할당하고 해제하는 <strong>LIFO(Last-In-First-Out)</strong> 방식의 메모리 영역입니다. <strong>값의 크기가 고정된 타입</strong>(예: 정수, 부동 소수점, 고정 크기의 배열 등)을 주로 저장합니다.</li><li><strong>힙(Heap)</strong>: 크기가 동적으로 결정되는 데이터를 저장하는 <strong>비순차적</strong> 메모리 영역입니다. **<code>Box</code>, <code>Vec</code>, <code>String</code>**과 같은 동적 크기의 타입들은 힙에 저장됩니다.</li></ul><h3 id=2-소유권-시스템>2. <strong>소유권 시스템</strong><a hidden class=anchor aria-hidden=true href=#2-소유권-시스템>#</a></h3><p>Rust에서 소유권 시스템은 <strong>값에 대한 소유권</strong>을 추적하여 <strong>메모리 안전성</strong>을 보장하고, <strong>스택</strong>과 <strong>힙</strong>에 저장되는 값들이 어떻게 관리되는지 결정합니다. 이 시스템은 <strong>스택에 저장된 변수</strong>의 <strong>소유권</strong>이 어떻게 <strong>힙에 저장된 값</strong>에 영향을 미치는지에 대한 규칙을 정의합니다.</p><h4 id=기본-규칙>기본 규칙:<a hidden class=anchor aria-hidden=true href=#기본-규칙>#</a></h4><ol><li><p><strong>소유권 이동 (Ownership Transfer)</strong>:</p><ul><li>변수는 소유권을 가지며, 그 변수의 소유권이 다른 변수로 이동하면 <strong>이전 변수는 더 이상 유효하지 않</strong>습니다.</li><li>값이 <strong>스택</strong>에 저장되면 <strong>소유권 이동</strong>은 스택에 있는 변수에서 다른 변수로 이동합니다. 하지만 <strong>힙에 저장된 데이터</strong>의 경우, 데이터는 힙에 저장되고 해당 메모리 주소만 스택에 복사됩니다.</li></ul></li><li><p><strong>소유권 복사 (Copy)</strong>:</p><ul><li><strong><code>Copy</code> 트레이트</strong>가 구현된 타입들은 <strong>소유권 이동 없이</strong> 데이터를 복사할 수 있습니다. 예를 들어, 정수형 타입(<code>i32</code>, <code>f64</code>)이나 배열과 같은 크기가 고정된 타입들은 소유권을 이동하지 않고 복사할 수 있습니다.</li></ul></li><li><p><strong>불변 참조와 가변 참조 (Immutable and Mutable References)</strong>:</p><ul><li><strong>불변 참조</strong>(예: <code>&amp;T</code>)는 데이터를 읽기 전용으로 참조할 수 있고, <strong>가변 참조</strong>(예: <code>&amp;mut T</code>)는 데이터를 수정할 수 있습니다.</li><li><strong>가변 참조</strong>는 한 번에 <strong>하나만 존재할 수 있습니다</strong>. 따라서 하나의 값에 대해 가변 참조와 불변 참조가 동시에 존재할 수 없습니다.</li></ul></li></ol><hr><h3 id=3-스택에서의-소유권>3. <strong>스택에서의 소유권</strong><a hidden class=anchor aria-hidden=true href=#3-스택에서의-소유권>#</a></h3><p>스택에 저장된 값은 <strong>스코프가 끝날 때 자동으로 해제</strong>됩니다. 스택에 있는 변수는 <strong>고정 크기</strong>여서 메모리에서 쉽게 관리할 수 있습니다. 스택에 저장된 값은 <strong>소유권이 함수나 변수 간에 이동</strong>할 때, 해당 변수가 끝날 때 자동으로 메모리에서 제거됩니다.</p><h4 id=예시-1-정수형-타입-copy>예시 1: <strong>정수형 타입 (Copy)</strong><a hidden class=anchor aria-hidden=true href=#예시-1-정수형-타입-copy>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;  <span style=color:#75715e>// x는 스택에 저장되고 소유권을 가짐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> x;   <span style=color:#75715e>// x의 값을 y로 복사(이 경우는 Copy가 가능)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;x: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, y: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y);  <span style=color:#75715e>// x와 y는 각각 독립된 값
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>이 예제에서 <code>x</code>는 정수 <code>10</code>을 스택에 저장합니다. <code>y = x</code>에서 <code>x</code>의 값은 복사됩니다. 따라서 <code>x</code>와 <code>y</code>는 서로 독립적인 값을 가집니다.</li></ul><h4 id=예시-2-구조체-타입-move>예시 2: <strong>구조체 타입 (Move)</strong><a hidden class=anchor aria-hidden=true href=#예시-2-구조체-타입-move>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyStruct</span> {
</span></span><span style=display:flex><span>    value: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> MyStruct { value: <span style=color:#ae81ff>10</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> a;  <span style=color:#75715e>// a의 소유권이 b로 이동
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// println!(&#34;{}&#34;, a.value);  // 오류: a는 더 이상 유효하지 않음
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>이 예제에서 <code>a</code>는 <code>MyStruct</code>를 소유합니다. <code>b = a</code>에서 <code>a</code>의 소유권이 <code>b</code>로 이동합니다. <code>a</code>는 더 이상 유효하지 않으며, <code>a</code>를 참조하려고 하면 오류가 발생합니다.</li></ul><hr><h3 id=4-힙에서의-소유권>4. <strong>힙에서의 소유권</strong><a hidden class=anchor aria-hidden=true href=#4-힙에서의-소유권>#</a></h3><p>힙에 저장된 값은 <strong>동적 메모리 할당</strong>을 통해 관리되며, <strong>스택에 저장된 포인터만</strong>이 힙에 저장된 데이터를 가리킵니다. 데이터 자체는 힙에 저장되며, 소유권이 이동하면 힙의 메모리 역시 관리됩니다.</p><h4 id=예시-3-string-힙-메모리-할당>예시 3: <strong>String (힙 메모리 할당)</strong><a hidden class=anchor aria-hidden=true href=#예시-3-string-힙-메모리-할당>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello&#34;</span>);  <span style=color:#75715e>// String은 힙에 저장
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1;  <span style=color:#75715e>// s1의 소유권이 s2로 이동
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// println!(&#34;{}&#34;, s1);  // 오류: s1은 더 이상 유효하지 않음
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>이 예제에서 <code>String</code>은 <strong>힙</strong>에 저장됩니다. <code>s1</code>의 소유권이 <code>s2</code>로 이동하면, 더 이상 <code>s1</code>을 사용할 수 없습니다. <strong>힙에 할당된 메모리</strong>는 <code>s2</code>가 끝날 때 자동으로 해제됩니다.</li></ul><h4 id=예시-4-vec-동적-배열>예시 4: <strong><code>Vec</code> (동적 배열)</strong><a hidden class=anchor aria-hidden=true href=#예시-4-vec-동적-배열>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v1 <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];  <span style=color:#75715e>// v1은 힙에 저장된 동적 배열
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> v2 <span style=color:#f92672>=</span> v1;  <span style=color:#75715e>// v1의 소유권이 v2로 이동
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// println!(&#34;{:?}&#34;, v1);  // 오류: v1은 더 이상 유효하지 않음
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><code>Vec</code>은 힙에 저장된 데이터입니다. <code>v1</code>의 소유권이 <code>v2</code>로 이동하면 <code>v1</code>은 더 이상 유효하지 않으며, 힙에 있는 메모리는 <code>v2</code>가 끝날 때 자동으로 해제됩니다.</li></ul><hr><h3 id=5-소유권과-참조의-관계>5. <strong>소유권과 참조의 관계</strong><a hidden class=anchor aria-hidden=true href=#5-소유권과-참조의-관계>#</a></h3><ul><li><strong>불변 참조 (<code>&amp;T</code>)</strong>: 스택에 <strong>참조를 저장</strong>합니다. 힙에 있는 값을 가리킬 수 있으며, 참조된 값은 <strong>변경할 수 없습니다</strong>.</li><li><strong>가변 참조 (<code>&amp;mut T</code>)</strong>: 하나의 값에 대해 <strong>하나의 가변 참조만</strong> 존재할 수 있습니다. 가변 참조는 값의 소유권을 변경하지 않지만, <strong>값을 변경</strong>할 수 있습니다.</li></ul><h4 id=예시-5-참조를-사용한-예>예시 5: <strong>참조를 사용한 예</strong><a hidden class=anchor aria-hidden=true href=#예시-5-참조를-사용한-예>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s1;  <span style=color:#75715e>// 불변 참조
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s2);  <span style=color:#75715e>// s2는 s1의 불변 참조
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// s1의 소유권은 여전히 s1에게 있음
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>이 예제에서 <code>s2</code>는 <code>s1</code>의 <strong>불변 참조</strong>입니다. <code>s2</code>는 <code>s1</code>의 값을 변경할 수 없으며, <code>s1</code>의 소유권은 여전히 <code>s1</code>이 가지고 있습니다.</li></ul><hr><h3 id=정리-1><strong>정리</strong><a hidden class=anchor aria-hidden=true href=#정리-1>#</a></h3><ul><li><strong>스택</strong>에 저장되는 값들은 고정 크기의 타입(예: <code>i32</code>, <code>bool</code>, <code>char</code>)이나 참조 타입이며, 함수나 변수의 스코프를 벗어나면 자동으로 해제됩니다.</li><li><strong>힙</strong>에 저장되는 값들은 동적 크기(예: <code>String</code>, <code>Vec</code>, <code>Box</code>)를 가지며, 값은 힙에 저장되지만, 그 값을 가리키는 <strong>스택 포인터</strong>가 존재합니다.</li><li><strong>소유권</strong>은 데이터가 <strong>힙에 있을 때</strong>, 스택에서의 변수 간에 <strong>이동</strong>하는 형태로 다루어지며, <strong>참조</strong>를 통해 값에 접근하거나, 값을 <strong>이동</strong>시킬 수 있습니다.</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jongyongpark.github.io/>RyanLabs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>