---
title: "Hyundai Cpp Checker"
date: 2025-02-17
categories: ["Checker"]
tags: ["Hyundai", "Cpp","Checker"]
---

# HYUNDAI MP-OOP-011

HYUNDAI MP-OOP-011 룰은 C++ 프로그래밍에서 **클래스의 멤버 변수를 직접적으로 노출하지 말고, 적절한 접근 제어를 통해 캡슐화(encapsulation)를 유지하라**는 원칙을 강조합니다.

### **1. 룰의 목적**

- **데이터 보호**: 클래스 내부의 데이터가 외부 코드에 의해 직접 수정되는 것을 방지하여 무결성을 유지합니다.
- **유지보수성 향상**: 데이터 접근을 메서드를 통해 제어함으로써 코드 변경 시 영향 범위를 최소화합니다.
- **캡슐화 준수**: 객체 지향 프로그래밍의 기본 원칙인 캡슐화를 통해 데이터와 메서드를 하나의 단위로 묶어 관리합니다.

### **2. 권장 사항**

- **멤버 변수의 접근 제어**: 모든 멤버 변수를 `private` 또는 `protected`로 선언하여 외부에서 직접 접근하지 못하도록 합니다.
- **접근자 메서드 제공**: 필요한 경우, 멤버 변수에 접근하기 위한 `getter` 및 `setter` 메서드를 제공합니다.
- **불필요한 공개 멤버 제거**: 외부에서 직접 접근할 필요가 없는 멤버는 공개하지 않습니다.

### **3. 예시**

**잘못된 예:**

```cpp
class Example {
public:
    int publicData; // 외부에서 직접 접근 가능
};
```

**개선된 예:**

```cpp
class Example {
private:
    int privateData; // 외부에서 직접 접근 불가

public:
    // 접근자 메서드를 통해 데이터 접근 제어
    int getData() const {
        return privateData;
    }

    void setData(int value) {
        privateData = value;
    }
};
```

### **4. 주의 사항**

- **람다 함수 사용 시**: 람다 함수는 캡처한 외부 변수들을 내부적으로 멤버 변수로 저장할 수 있습니다. 이 경우, 컴파일러가 생성한 람다 객체의 멤버 참조로 인해 MP-OOP-011 룰 위반으로 검출될 수 있습니다. 이러한 상황은 False Positive로 간주될 수 있으며, 람다 함수 내에서 멤버 변수의 직접적인 노출을 피하도록 주의해야 합니다.

### **5. 결론**

HYUNDAI MP-OOP-011 룰은 클래스 설계 시 데이터의 캡슐화와 보호를 강조하여 코드의 안정성과 유지보수성을 높이는 데 기여합니다. 특히, 람다 함수 사용 시 컴파일러가 생성하는 내부 구조로 인해 발생할 수 있는 False Positive를 인지하고, 이러한 상황을 피하기 위한 코딩 습관을 갖는 것이 중요합니다. 

