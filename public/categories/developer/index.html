<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Developer | RyanLabs</title>
<meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://jongyongpark.github.io/categories/developer/><link crossorigin=anonymous href=/assets/css/stylesheet.9de45e225101e4f99701d2b68fc6b8a1ef6027928be6391fa15bf7f56326c909.css integrity="sha256-neReIlEB5PmXAdK2j8a4oe9gJ5KL5jkfoVv39WMmyQk=" rel="preload stylesheet" as=style><link rel=icon href=https://jongyongpark.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jongyongpark.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jongyongpark.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jongyongpark.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jongyongpark.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jongyongpark.github.io/categories/developer/index.xml><link rel=alternate hreflang=ko href=https://jongyongpark.github.io/categories/developer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://jongyongpark.github.io/categories/developer/"><meta property="og:site_name" content="RyanLabs"><meta property="og:title" content="Developer"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Developer"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jongyongpark.github.io/ accesskey=h title="RyanLabs (Alt + H)">RyanLabs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jongyongpark.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://jongyongpark.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://jongyongpark.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://jongyongpark.github.io/archives/ title=연도><span>연도</span></a></li><li><a href=https://jongyongpark.github.io/lectures/ title=강의><span>강의</span></a></li><li><a href=https://jongyongpark.github.io/about/ title=어바웃미><span>어바웃미</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Developer</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dart</h2></header><div class=entry-content><p>Dart 와 JavaScript 비교교 Dart와 JavaScript 중 어떤 언어를 배우는 것이 더 좋은지는 Ryan의 목표와 개발하려는 서비스의 방향에 따라 다릅니다.
✅ Dart를 배우는 것이 좋은 경우 Flutter를 활용한 크로스 플랫폼 앱 개발 Ryan이 모바일 앱 개발(특히 iOS & Android) 을 목표로 한다면 Dart + Flutter 조합이 유리합니다. 하나의 코드베이스로 iOS, Android, 웹까지 개발 가능하여 유지보수 비용을 절감할 수 있습니다. 안정적이고 타입 안정성이 중요한 경우 Dart는 정적 타입을 제공하여 코드의 안정성이 높고, 유지보수가 쉬운 편입니다. JavaScript보다 더 안전한 프로그래밍이 가능합니다. Google 생태계에 관심이 있다면 Dart는 Google이 적극적으로 지원하는 언어이므로, Google 관련 기술과 함께 사용하기 좋습니다. ✅ JavaScript를 배우는 것이 좋은 경우 웹 서비스 개발이 목표라면 Ryan이 웹 기반 서비스(프론트엔드 & 백엔드) 를 개발하려면 JavaScript가 훨씬 강력한 선택지입니다. React, Vue, Angular 등 다양한 웹 프레임워크를 활용할 수 있습니다. 서버 개발도 Node.js 를 활용해 JavaScript로 가능하므로 전체 개발이 JavaScript로 통일됩니다. 더 많은 오픈 소스 및 커뮤니티 지원을 원한다면 JavaScript는 웹 개발의 표준이며, 가장 많은 라이브러리와 프레임워크가 존재합니다. Dart에 비해 커뮤니티가 훨씬 크며, 문제 해결이 빠릅니다. 프론트엔드 개발자가 되고 싶다면 JavaScript는 웹 브라우저에서 기본적으로 실행되는 언어이므로, 프론트엔드 개발자 를 목표로 한다면 필수입니다. ⚖️ 결론: Ryan에게 적합한 선택 웹 서비스를 중심으로 개발하려면? → JavaScript 모바일 앱을 중심으로 개발하려면? → Dart + Flutter 웹과 모바일을 모두 고려한다면? 웹이 더 중요하면 JavaScript 모바일이 더 중요하면 Dart Ryan이 만들고 싶은 서비스가 웹 기반이라면 JavaScript가 더 적합할 가능성이 큽니다.
어떤 서비스를 만들고 싶은지 더 구체적으로 이야기해주면 더 적합한 선택을 도와줄 수 있어요!
...</p></div><footer class=entry-footer><span title='2025-02-21 00:00:00 +0000 UTC'>2월 21, 2025</span></footer><a class=entry-link aria-label="post link to Dart" href=https://jongyongpark.github.io/posts/developer/dart/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Nest.js</h2></header><div class=entry-content><p>Next.js 와와 SpringBoot 비교 속도비교 NestJS와 Spring Boot는 각각의 장단점이 있지만, 개발 속도 측면에서 비교할 때는 NestJS가 더 빠를 수 있는 몇 가지 이유가 있습니다. 다만, 최종 선택은 프로젝트의 요구 사항과 팀의 경험에 따라 달라질 수 있습니다. 아래에서 두 프레임워크를 비교해보겠습니다.
1. NestJS의 빠른 개발 속도 JavaScript/TypeScript 기반: NestJS는 TypeScript를 기본으로 사용합니다. TypeScript는 자바스크립트를 확장한 언어로, 컴파일 시 타입 검사를 제공하여 코드 작성 중 버그를 미리 잡을 수 있습니다. 또한, JavaScript와 TypeScript는 웹 프론트엔드 개발에서 널리 사용되기 때문에, 프론트엔드와 백엔드 개발자들이 같은 언어를 사용할 수 있어 통합 개발 속도가 빨라질 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-02-21 00:00:00 +0000 UTC'>2월 21, 2025</span></footer><a class=entry-link aria-label="post link to Nest.js" href=https://jongyongpark.github.io/posts/developer/javascipt/nestjs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rust Web</h2></header><div class=entry-content><p>Rust는 시스템 프로그래밍 언어로 높은 성능과 안전성을 제공하지만, 웹 프레임워크 측면에서는 여전히 상대적으로 적은 선택지가 있습니다. 그럼에도 불구하고 Spring Boot나 NestJS와 비슷한 구조적 접근을 제공하는 Rust 웹 프레임워크들이 있습니다. 이들 프레임워크는 모듈화, 라우팅, 미들웨어 지원 등을 제공하며, 일반적으로 백엔드 API 서버나 웹 애플리케이션을 구축할 수 있습니다.
다음은 Rust에서 Spring Boot나 NestJS처럼 구조적이고 확장 가능한 웹 애플리케이션을 구축할 수 있는 프레임워크들입니다:
1. Actix Web 특징:
Actix Web은 고성능과 비동기 처리를 지원하는 Rust의 가장 인기 있는 웹 프레임워크입니다. Spring Boot와 비슷하게, 매우 높은 성능을 자랑하면서도 유연한 미들웨어 및 라우팅 기능을 제공합니다. 모듈화된 라우팅과 미들웨어를 지원하며, 웹 소켓, API 서버 등 다양한 서버 애플리케이션을 구현할 수 있습니다. Actors 모델을 기반으로 한 Actix 시스템을 제공하여, 복잡한 상태 관리 및 비동기 처리를 유연하게 처리할 수 있습니다. Spring Boot와 비슷한 방식으로 동시성을 처리하며, REST API 서버로 매우 적합합니다. 타입 안전성과 비동기 I/O를 지원하여, 성능과 안정성에서 우수한 결과를 도출할 수 있습니다. 장점:
...</p></div><footer class=entry-footer><span title='2025-02-21 00:00:00 +0000 UTC'>2월 21, 2025</span></footer><a class=entry-link aria-label="post link to Rust Web" href=https://jongyongpark.github.io/posts/developer/rust/rust-web/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OpenCV compile on Windows</h2></header><div class=entry-content><p>Claude 이 오류는 ARM64 플랫폼을 위한 CMake 구성 과정에서 발생한 문제입니다. 주요 오류는 프로젝트 설정이 제대로 되지 않았고, ARM64 플랫폼 구성이 올바르지 않다는 것입니다.
PowerShell 스크립트를 다음과 같이 수정하여 해결할 수 있습니다:
# OpenCV Windows Build Script for x64 and ARM64 # Prerequisites: Visual Studio 2022, CMake, Git # Configuration $OPENCV_VERSION = "4.9.0" $SOURCE_DIR = "C:\workspace\jonpark-work\opencv_source" $BUILD_BASE_DIR = "C:\workspace\jonpark-work\opencv_build" $INSTALL_BASE_DIR = "C:\workspace\jonpark-work\opencv_install" # Common CMake parameters $CMAKE_COMMON_PARAMS = @( "-DCMAKE_MINIMUM_REQUIRED_VERSION=3.10", # 최소 CMake 버전 지정 "-DBUILD_SHARED_LIBS=ON", "-DBUILD_TESTS=OFF", "-DBUILD_PERF_TESTS=OFF", "-DBUILD_EXAMPLES=OFF", "-DWITH_CUDA=OFF", "-DBUILD_opencv_world=ON", "-DBUILD_opencv_python2=OFF", "-DBUILD_opencv_python3=OFF", "-DWITH_IPP=ON", "-DENABLE_CXX11=ON", "-DOPENCV_ENABLE_NONFREE=ON", "-DBUILD_WITH_STATIC_CRT=OFF" ) # Download OpenCV source if (-not (Test-Path $SOURCE_DIR)) { git clone https://github.com/opencv/opencv.git $SOURCE_DIR Push-Location $SOURCE_DIR git checkout $OPENCV_VERSION Pop-Location } # Function to build OpenCV for specific architecture function Build-OpenCV { param ( [string]$arch, [string]$generator, [string]$platform ) $BUILD_DIR = "$BUILD_BASE_DIR\$arch" $INSTALL_DIR = "$INSTALL_BASE_DIR\$arch" # Remove existing build directory to ensure clean build if (Test-Path $BUILD_DIR) { Remove-Item -Path $BUILD_DIR -Recurse -Force } # Create build directory New-Item -ItemType Directory -Force -Path $BUILD_DIR Push-Location $BUILD_DIR # Configure CMake with explicit project name and build type cmake -G $generator -A $platform ` -DCMAKE_INSTALL_PREFIX="$INSTALL_DIR" ` -DCMAKE_BUILD_TYPE=Release ` -DOpenCV_ARCH=$platform ` -DOpenCV_RUNTIME=vc17 ` $CMAKE_COMMON_PARAMS ` -S $SOURCE_DIR -B $BUILD_DIR if ($LASTEXITCODE -ne 0) { Write-Error "CMake configuration failed for $arch" Pop-Location exit 1 } # Build and install cmake --build $BUILD_DIR --config Release --target INSTALL --parallel 8 if ($LASTEXITCODE -ne 0) { Write-Error "Build failed for $arch" Pop-Location exit 1 } Pop-Location } # 빌드 전 Visual Studio 환경 설정 $VS_PATH = "C:\Program Files\Microsoft Visual Studio\2022\Community" $VS_TOOLS = "$VS_PATH\VC\Auxiliary\Build" if (Test-Path "$VS_TOOLS\vcvarsall.bat") { Write-Host "Setting up Visual Studio environment..." # x64 환경 설정 cmd.exe /c "call `"$VS_TOOLS\vcvarsall.bat`" x64 && set > %temp%\vcvars.txt" Get-Content "$env:temp\vcvars.txt" | foreach-object { if ($_ -match "^(.*?)=(.*)$") { Set-Content "env:\$($matches[1])" $matches[2] } } } else { Write-Error "Visual Studio environment setup failed" exit 1 } # Build for x64 Write-Host "Building for x64..." Build-OpenCV -arch "x64" -generator "Visual Studio 17 2022" -platform "x64" # ARM64 빌드 전 환경 재설정 if (Test-Path "$VS_TOOLS\vcvarsall.bat") { Write-Host "Setting up Visual Studio environment for ARM64..." cmd.exe /c "call `"$VS_TOOLS\vcvarsall.bat`" x64_arm64 && set > %temp%\vcvars.txt" Get-Content "$env:temp\vcvars.txt" | foreach-object { if ($_ -match "^(.*?)=(.*)$") { Set-Content "env:\$($matches[1])" $matches[2] } } } # Build for ARM64 Write-Host "Building for ARM64..." Build-OpenCV -arch "arm64" -generator "Visual Studio 17 2022" -platform "ARM64" 주요 변경사항과 해결방법:
...</p></div><footer class=entry-footer><span title='2025-02-20 00:00:00 +0000 UTC'>2월 20, 2025</span></footer><a class=entry-link aria-label="post link to OpenCV compile on Windows" href=https://jongyongpark.github.io/posts/developer/opencv-win/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cpp Lamda</h2></header><div class=entry-content><p>Cpp Lamda Variable is Private C++에서 람다 함수는 외부 변수들을 캡처하여 내부에서 사용할 수 있습니다. 이때, 캡처된 변수들은 람다 객체의 멤버 변수로 저장되며, 이러한 멤버 변수들은 컴파일러에 의해 private 접근 지정자로 선언됩니다. 따라서, 람다 객체 외부에서는 이들 멤버 변수에 직접 접근할 수 없습니다.
예제 코드 #include &lt;iostream> #include &lt;functional> int main() { int x = 10; // x를 값으로 캡처하는 람다 함수 auto lambda = [x]() mutable { std::cout &lt;&lt; "Captured x: " &lt;&lt; x &lt;&lt; std::endl; x++; }; lambda(); // Captured x: 10 lambda(); // Captured x: 11 // 람다 객체의 멤버 변수 x에 직접 접근하려는 시도 // std::cout &lt;&lt; "Internal x: " &lt;&lt; lambda.x &lt;&lt; std::endl; // 오류: 'lambda'의 'x'에 접근할 수 없음 return 0; } 분석 캡처된 변수의 저장: 람다 함수 [x]는 외부 변수 x를 값으로 캡처하여 람다 객체의 멤버 변수로 저장합니다.
...</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to Cpp Lamda" href=https://jongyongpark.github.io/posts/developer/cpp-lamda/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>React Hook</h2></header><div class=entry-content><p>React Hook React의 함수형 컴포넌트는 매 렌더링마다 컴포넌트 함수를 호출합니다. 이때 React는 내부적으로 **hook 체인(혹은 hook 리스트)**를 유지하며, 각 hook 호출마다 고유한 상태(예: useState의 상태, useEffect의 효과 정보 등)를 저장합니다. 이 구조와 재호출 과정을 자세히 설명하면 다음과 같습니다.
1. Hook 체인의 기본 구조 Fiber와 Hook 리스트:
React는 각 컴포넌트 인스턴스(실제로는 Fiber 노드)에 hook 정보를 저장합니다. 이 정보는 hook들이 호출된 순서대로 배열(혹은 연결 리스트)로 관리되며, 각 hook은 해당 컴포넌트의 렌더링 상태와 관련된 데이터를 보관합니다.
...</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to React Hook" href=https://jongyongpark.github.io/posts/developer/javascipt/react-hook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>React Native</h2></header><div class=entry-content><p>React Native 와 React 의 차이 React Native는 React의 개념과 철학을 기반으로 하지만, 주로 모바일 앱 개발(안드로이드와 iOS)을 위해 설계된 프레임워크입니다. 아래에서는 React Native의 주요 특징과 React(Web)와의 차이점을 자세히 설명합니다.
1. React Native란? 목적:
React Native는 JavaScript와 React의 컴포넌트 기반 아키텍처를 활용하여 네이티브 모바일 앱(안드로이드, iOS)을 개발할 수 있도록 해줍니다.
웹 브라우저가 아닌, 모바일 기기의 네이티브 UI 컴포넌트(예: View, Text, Image)를 사용하여 사용자 인터페이스를 구성합니다.
구조 및 실행 방식:
JS 코드와 네이티브 브리지:
React Native 앱은 JavaScript 코드로 작성되며, 이 코드는 JavaScript 엔진(V8, Hermes 등)에서 실행됩니다.
JavaScript와 네이티브 플랫폼 간의 통신은 “브리지(Bridge)“를 통해 이뤄지며, 이로 인해 JavaScript 코드에서 네이티브 UI 컴포넌트나 기능을 호출할 수 있습니다. 플랫폼별 네이티브 컴포넌트:
React Native는 플랫폼에 최적화된 네이티브 UI 컴포넌트를 사용하여, 높은 성능과 원활한 사용자 경험을 제공합니다. 2. React (Web)와 React Native의 차이점 2.1 렌더링 대상 React (Web):
...</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to React Native" href=https://jongyongpark.github.io/posts/developer/javascipt/react-native/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cyclomatic Complexity in C++ Code</h2></header><div class=entry-content><p>Cyclomatic Complexity in C++ Code Cyclomatic Complexity (CCM) is a software metric used to indicate the complexity of a program. It directly measures the number of linearly independent paths through a program’s source code. Higher CCM values suggest more complex and potentially less maintainable code.
CCM Calculation Rules Cyclomatic Complexity is calculated based on the control flow graph of the program using the following rules:
Basic Complexity: The simplest program has a CCM of 1. Control Flow Branches: Each if, for, while, case, and other control flow statements add to the CCM. Logical Operators: Logical operators like && and || can also increase CCM by introducing additional paths. Example C++ Code with CCM Calculation #include &lt;iostream> using namespace std; // Function declaration int calculate(int a, int b, int c); int main() { int x = 10; int y = 20; int z = 30; int result = calculate(x, y, z); cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; endl; return 0; } // Function with high Cyclomatic Complexity int calculate(int a, int b, int c) { int CCM = 1; // Basic complexity // If statement 1: CCM += 1 if (a > b) { CCM++; cout &lt;&lt; "a is greater than b" &lt;&lt; endl; } // If-else statement: CCM += 1 if (b > c) { CCM++; cout &lt;&lt; "b is greater than c" &lt;&lt; endl; } else { CCM++; cout &lt;&lt; "c is greater than or equal to b" &lt;&lt; endl; } // For loop: CCM += 1 for(int i = 0; i &lt; 5; ++i) { CCM++; cout &lt;&lt; "Iteration: " &lt;&lt; i &lt;&lt; endl; } // While loop: CCM += 1 int count = 0; while(count &lt; 3) { CCM++; cout &lt;&lt; "Count: " &lt;&lt; count &lt;&lt; endl; count++; } // Switch-case statement: Each case adds to CCM int option = 2; switch(option) { case 1: CCM++; cout &lt;&lt; "Option 1 selected" &lt;&lt; endl; break; case 2: CCM++; cout &lt;&lt; "Option 2 selected" &lt;&lt; endl; break; case 3: CCM++; cout &lt;&lt; "Option 3 selected" &lt;&lt; endl; break; default: CCM++; cout &lt;&lt; "Default option selected" &lt;&lt; endl; break; } // Logical operators: Each '&&' or '||' adds to CCM if (a > 0 && b > 0) { // '&&' adds 1 CCM++; cout &lt;&lt; "Both a and b are positive" &lt;&lt; endl; } if (a > 0 || c > 0) { // '||' adds 1 CCM++; cout &lt;&lt; "Either a or c is positive" &lt;&lt; endl; } return CCM; } Code Explanation and CCM Calculation Basic Complexity:
...</p></div><footer class=entry-footer><span title='2025-01-31 00:00:00 +0000 UTC'>1월 31, 2025</span></footer><a class=entry-link aria-label="post link to Cyclomatic Complexity in C++ Code" href=https://jongyongpark.github.io/posts/developer/cyclomatic-complexity-in-c++-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Next.js - JWT</h2></header><div class=entry-content><p>Next.js app with JWT-based authentication and a basic security setup Here’s how you can create a simple Next.js app with JWT-based authentication and a basic security setup.
Steps Overview: Initialize a Next.js app Set up authentication with JWT Create login and protected routes Add security features 1. Initialize Next.js App Run the following commands to initialize a Next.js app:
npx create-next-app@latest my-nextjs-jwt-app cd my-nextjs-jwt-app npm install 2. Install Dependencies You need additional packages for handling JWT, user authentication, and securing the app:
...</p></div><footer class=entry-footer><span title='2025-01-31 00:00:00 +0000 UTC'>1월 31, 2025</span></footer><a class=entry-link aria-label="post link to Next.js - JWT" href=https://jongyongpark.github.io/posts/developer/javascipt/nextjs-jwt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Basic Grammar</h2></header><div class=entry-content><p>FastAPI, Flask, Django는 모두 Python으로 개발된 인기 있는 웹 프레임워크입니다. 이들 각각은 사용 사례와 목적이 다르며, 성능, 확장성, 사용 편의성 등에서 차이가 있습니다. 각 프레임워크의 특징과 장단점을 비교하여, 어떤 상황에서 어떤 프레임워크가 적합할지 알아보겠습니다.
1. FastAPI 특징:
비동기 처리와 자동화된 데이터 검증을 기본으로 지원합니다. Python 3.7+ 이상에서 사용하는 type hints를 기반으로, 자동 API 문서화(Swagger, ReDoc)를 제공합니다. 성능이 매우 뛰어나며, 특히 REST API나 GraphQL 서버 구축에 적합합니다. Starlette을 기반으로 하여 높은 성능을 자랑합니다. Pydantic을 사용한 데이터 검증이 매우 강력하고, 코드의 오류를 컴파일 시점에 잡을 수 있습니다. 장점:
...</p></div><footer class=entry-footer><span title='2025-01-31 00:00:00 +0000 UTC'>1월 31, 2025</span></footer><a class=entry-link aria-label="post link to Python Basic Grammar" href=https://jongyongpark.github.io/posts/developer/python-basics/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://jongyongpark.github.io/>RyanLabs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>