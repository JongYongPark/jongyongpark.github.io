<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | RyanLabs</title>
<meta name=keywords content><meta name=description content="Posts - RyanLabs"><meta name=author content><link rel=canonical href=https://jongyongpark.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.9de45e225101e4f99701d2b68fc6b8a1ef6027928be6391fa15bf7f56326c909.css integrity="sha256-neReIlEB5PmXAdK2j8a4oe9gJ5KL5jkfoVv39WMmyQk=" rel="preload stylesheet" as=style><link rel=icon href=https://jongyongpark.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jongyongpark.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jongyongpark.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jongyongpark.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jongyongpark.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jongyongpark.github.io/posts/index.xml><link rel=alternate hreflang=ko href=https://jongyongpark.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://jongyongpark.github.io/posts/"><meta property="og:site_name" content="RyanLabs"><meta property="og:title" content="Posts"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jongyongpark.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jongyongpark.github.io/ accesskey=h title="RyanLabs (Alt + H)">RyanLabs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jongyongpark.github.io/search/ title=검색><span>검색</span></a></li><li><a href=https://jongyongpark.github.io/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://jongyongpark.github.io/tags/ title=태그><span>태그</span></a></li><li><a href=https://jongyongpark.github.io/archives/ title=연도><span>연도</span></a></li><li><a href=https://jongyongpark.github.io/lectures/ title=강의><span>강의</span></a></li><li><a href=https://jongyongpark.github.io/about/ title=어바웃미><span>어바웃미</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Usage</h2></header><div class=entry-content><p>GitHub에서 새로운 Repository(저장소)를 생성하는 방법 GitHub에서 새로운 Repository(저장소)를 생성하는 방법 GitHub에서 새로운 **Repository(저장소)**를 생성하는 방법을 단계별로 설명하겠습니다.
방법 1: GitHub 웹사이트에서 직접 생성하는 방법
방법 2: Git CLI를 사용하여 터미널에서 생성하는 방법
📝 방법 1: GitHub 웹사이트에서 직접 생성하기 1️⃣ GitHub에 로그인 GitHub 홈페이지에 접속 후 로그인합니다. 2️⃣ 새 저장소 생성 페이지 이동 우측 상단의 + 버튼을 클릭한 후 “New repository” 선택 또는 직접 새 저장소 생성 페이지로 이동 3️⃣ 저장소 정보 입력 Repository name (필수): 저장소 이름을 입력합니다. (예: my-new-repo) Description (선택): 저장소에 대한 설명을 입력합니다. Visibility 선택: Public(공개) → 누구나 볼 수 있음. Private(비공개) → 본인과 초대한 사용자만 접근 가능. 4️⃣ 추가 설정 ✅ Initialize this repository with a README (선택) 체크하면 기본적인 README.md 파일이 생성됨. ✅ .gitignore (선택) 특정 파일을 Git에서 무시하도록 설정 (예: Python, Node.js 등). ✅ License (선택) 오픈소스 라이선스를 설정 (예: MIT, Apache 2.0 등). 5️⃣ 저장소 생성 “Create repository” 버튼을 클릭하면 저장소가 생성됩니다. 6️⃣ 로컬 프로젝트와 연결 이제 로컬에서 작업 중인 프로젝트를 GitHub 저장소에 연결할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to Git Usage" href=https://jongyongpark.github.io/posts/sdlc/git/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hyundai Cpp Checker</h2></header><div class=entry-content><p>HYUNDAI MP-OOP-011 HYUNDAI MP-OOP-011 룰은 C++ 프로그래밍에서 클래스의 멤버 변수를 직접적으로 노출하지 말고, 적절한 접근 제어를 통해 캡슐화(encapsulation)를 유지하라는 원칙을 강조합니다.
1. 룰의 목적 데이터 보호: 클래스 내부의 데이터가 외부 코드에 의해 직접 수정되는 것을 방지하여 무결성을 유지합니다. 유지보수성 향상: 데이터 접근을 메서드를 통해 제어함으로써 코드 변경 시 영향 범위를 최소화합니다. 캡슐화 준수: 객체 지향 프로그래밍의 기본 원칙인 캡슐화를 통해 데이터와 메서드를 하나의 단위로 묶어 관리합니다. 2. 권장 사항 멤버 변수의 접근 제어: 모든 멤버 변수를 private 또는 protected로 선언하여 외부에서 직접 접근하지 못하도록 합니다. 접근자 메서드 제공: 필요한 경우, 멤버 변수에 접근하기 위한 getter 및 setter 메서드를 제공합니다. 불필요한 공개 멤버 제거: 외부에서 직접 접근할 필요가 없는 멤버는 공개하지 않습니다. 3. 예시 잘못된 예:
...</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to Hyundai Cpp Checker" href=https://jongyongpark.github.io/posts/checker/hyundai-cpp-checker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hyundai Java Checker</h2></header><div class=entry-content><p>MJ-SER-002 : Do not serialize unencrypted sensitive data. CERT SER03-J 에 매핑됨
https://documentation.blackduck.com/bundle/coverity-docs-2023.12/page/checker-ref/tables/hyundai-java.html
https://documentation.blackduck.com/bundle/coverity-docs/page/checker-ref/tables/sei-cert-java-coding-standard.html</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to Hyundai Java Checker" href=https://jongyongpark.github.io/posts/checker/hyundai-java-checker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kiwoom</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to Kiwoom" href=https://jongyongpark.github.io/posts/ai/kiwoon/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ollama</h2></header><div class=entry-content><p>EC2의 Ubuntu 인스턴스에서 Ollama를 설치하고 사용하는 방법 EC2의 Ubuntu 인스턴스에서 Ollama를 설치하고 사용하는 방법을 안내해드리겠습니다.
1. Ollama 설치 Ollama는 로컬 환경에서 대규모 언어 모델(LLM)을 실행할 수 있게 해주는 오픈 소스 프레임워크입니다. Ubuntu에서 Ollama를 설치하려면 다음 단계를 따르세요.
시스템 업데이트 및 필수 패키지 설치:
sudo apt update && sudo apt upgrade -y sudo apt install -y curl Ollama 설치 스크립트 실행:
curl -fsSL https://ollama.com/install.sh | sh 설치 확인:
ollama --version 위 명령어를 실행하여 Ollama가 정상적으로 설치되었는지 확인합니다.
...</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to Ollama" href=https://jongyongpark.github.io/posts/ai/ollama/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>React Hook</h2></header><div class=entry-content><p>React Hook React의 함수형 컴포넌트는 매 렌더링마다 컴포넌트 함수를 호출합니다. 이때 React는 내부적으로 **hook 체인(혹은 hook 리스트)**를 유지하며, 각 hook 호출마다 고유한 상태(예: useState의 상태, useEffect의 효과 정보 등)를 저장합니다. 이 구조와 재호출 과정을 자세히 설명하면 다음과 같습니다.
1. Hook 체인의 기본 구조 Fiber와 Hook 리스트:
React는 각 컴포넌트 인스턴스(실제로는 Fiber 노드)에 hook 정보를 저장합니다. 이 정보는 hook들이 호출된 순서대로 배열(혹은 연결 리스트)로 관리되며, 각 hook은 해당 컴포넌트의 렌더링 상태와 관련된 데이터를 보관합니다.
...</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to React Hook" href=https://jongyongpark.github.io/posts/developer/javascipt/react-hook/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>React Native</h2></header><div class=entry-content><p>React Native 와 React 의 차이 React Native는 React의 개념과 철학을 기반으로 하지만, 주로 모바일 앱 개발(안드로이드와 iOS)을 위해 설계된 프레임워크입니다. 아래에서는 React Native의 주요 특징과 React(Web)와의 차이점을 자세히 설명합니다.
1. React Native란? 목적:
React Native는 JavaScript와 React의 컴포넌트 기반 아키텍처를 활용하여 네이티브 모바일 앱(안드로이드, iOS)을 개발할 수 있도록 해줍니다.
웹 브라우저가 아닌, 모바일 기기의 네이티브 UI 컴포넌트(예: View, Text, Image)를 사용하여 사용자 인터페이스를 구성합니다.
구조 및 실행 방식:
JS 코드와 네이티브 브리지:
React Native 앱은 JavaScript 코드로 작성되며, 이 코드는 JavaScript 엔진(V8, Hermes 등)에서 실행됩니다.
JavaScript와 네이티브 플랫폼 간의 통신은 “브리지(Bridge)“를 통해 이뤄지며, 이로 인해 JavaScript 코드에서 네이티브 UI 컴포넌트나 기능을 호출할 수 있습니다. 플랫폼별 네이티브 컴포넌트:
React Native는 플랫폼에 최적화된 네이티브 UI 컴포넌트를 사용하여, 높은 성능과 원활한 사용자 경험을 제공합니다. 2. React (Web)와 React Native의 차이점 2.1 렌더링 대상 React (Web):
...</p></div><footer class=entry-footer><span title='2025-02-17 00:00:00 +0000 UTC'>2월 17, 2025</span></footer><a class=entry-link aria-label="post link to React Native" href=https://jongyongpark.github.io/posts/developer/javascipt/react-native/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Different URL Formats for Accessing a Git Repository</h2></header><div class=entry-content><p>🔹 Different URL Formats for Accessing a Git Repository Git supports multiple protocols for accessing repositories, each with its own advantages and disadvantages in terms of authentication, security, and ease of use. Below is a summary of the common URL formats, their corresponding protocols, authentication methods, and a comparison of their pros and cons.
📌 Git Repository URL Formats and Their Characteristics Git URL Format Protocol Used Authentication Method Pros Cons git@host:path/repo.git SSH SSH key authentication (Private/Public key pair) ✅ Secure authentication without storing passwords ✅ Supports read & write access ✅ Works well in automation (CI/CD) ❌ Requires setting up SSH keys ❌ Firewalls may block SSH (port 22) ssh://git@host/path/repo.git SSH SSH key authentication ✅ Same as git@host:path/repo.git, but with explicit protocol ✅ More readable for some users ❌ Identical disadvantages as the git@ format https://host/path/repo.git HTTPS Username + Password, or Personal Access Token (PAT) ✅ Works without additional setup ✅ Usually allowed through firewalls ✅ Supports 2FA via PAT ❌ Requires entering credentials or setting up a credential manager ❌ PATs need to be managed securely git://host/path/repo.git Git Daemon (read-only) No authentication required ✅ Fast and lightweight ✅ Ideal for public repositories ❌ No authentication, security risk ❌ Only supports read access /path/to/repo.git Local File System No authentication needed (local access) ✅ Fastest access (no network latency) ✅ No need for authentication ❌ Only works on the local machine ❌ Cannot be used for remote access 📌 Pros and Cons of Each Git Access Method 1️⃣ SSH (git@host:path/repo.git or ssh://git@host/path/repo.git) ✅ Pros:
...</p></div><footer class=entry-footer><span title='2025-02-14 00:00:00 +0000 UTC'>2월 14, 2025</span></footer><a class=entry-link aria-label="post link to Different URL Formats for Accessing a Git Repository" href=https://jongyongpark.github.io/posts/technical-support/git--repo-access-url-formats/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Github Pages with Hugo</h2></header><div class=entry-content><p>Github Pages GitHub Pages는 GitHub 저장소를 사용하여 정적 웹사이트를 쉽게 배포할 수 있는 기능입니다.
다음은 GitHub Pages를 설정하고 사용하는 방법을 단계별로 설명합니다.
1. GitHub Pages 활성화하기 (1) GitHub 저장소 생성 GitHub에 로그인하고 새로운 저장소(New Repository) 생성
저장소 이름을 설정 (예: my-blog)
Public(공개) 저장소로 설정해야 GitHub Pages에서 무료로 사용할 수 있음
README.md 파일을 추가하는 것이 좋음
저장소 생성 후 git clone으로 로컬에 다운로드
git clone https://github.com/your-username/my-blog.git cd my-blog 2. GitHub Pages 활성화 GitHub 저장소로 이동 Settings > Pages 탭으로 이동 Branch 선택: main 또는 gh-pages 브랜치를 선택하여 배포할 수 있음 저장 후 몇 분 내로 GitHub Pages가 활성화됨 배포된 사이트 URL 확인 (https://your-username.github.io/my-blog/) 3. HTML/CSS 파일 추가하여 웹사이트 배포 로컬 저장소에서 기본 웹페이지 생성: echo "&lt;h1>Welcome to My GitHub Page&lt;/h1>" > index.html 변경 사항을 커밋하고 푸시: git add index.html git commit -m "Add main page" git push origin main GitHub Pages가 자동으로 index.html을 인식하여 배포함 4. Jekyll을 이용한 블로그 만들기 GitHub Pages는 Jekyll을 지원하므로, Jekyll을 활용하여 정적 블로그를 쉽게 만들 수 있음.
...</p></div><footer class=entry-footer><span title='2025-02-14 00:00:00 +0000 UTC'>2월 14, 2025</span></footer><a class=entry-link aria-label="post link to Github Pages with Hugo" href=https://jongyongpark.github.io/posts/creator/github-page-with-hugo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KinD for k8s</h2></header><div class=entry-content><p>KinD로 3개의 worker node를 포함한 클러스터를 만드는 Bash 스크립트 다음은 KinD(Kubernetes in Docker)를 사용하여 프라이빗 클라우드를 생성하고, 3개의 worker node를 포함한 클러스터를 만드는 Bash 스크립트입니다. 이 스크립트는 필요한 유틸리티를 다운로드하고 설치하며, kind 클러스터를 구성합니다.
Bash Script: setup_kind_cluster.sh #!/bin/bash # 스크립트 실행 중 오류 발생 시 중단 set -e # 변수 정의 KIND_VERSION="v0.20.0" KUBECTL_VERSION="v1.28.0" DOCKER_COMPOSE_VERSION="v2.22.0" # 필요한 유틸리티 다운로드 및 설치 install_utilities() { # Docker 설치 (Docker가 설치되어 있지 않을 경우) if ! command -v docker &> /dev/null; then echo "Docker를 설치 중입니다..." curl -fsSL https://get.docker.com | bash sudo usermod -aG docker $USER echo "Docker 설치 완료. 사용하려면 로그아웃 후 다시 로그인하세요." else echo "Docker가 이미 설치되어 있습니다." fi # kind 설치 if ! command -v kind &> /dev/null; then echo "Kind를 설치 중입니다..." curl -Lo ./kind https://kind.sigs.k8s.io/dl/${KIND_VERSION}/kind-linux-amd64 chmod +x ./kind sudo mv ./kind /usr/local/bin/kind echo "Kind 설치 완료." else echo "Kind가 이미 설치되어 있습니다." fi # kubectl 설치 if ! command -v kubectl &> /dev/null; then echo "Kubectl을 설치 중입니다..." curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" chmod +x ./kubectl sudo mv ./kubectl /usr/local/bin/kubectl echo "Kubectl 설치 완료." else echo "Kubectl이 이미 설치되어 있습니다." fi # Docker Compose 설치 (필요한 경우) if ! command -v docker-compose &> /dev/null; then echo "Docker Compose를 설치 중입니다..." curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose echo "Docker Compose 설치 완료." else echo "Docker Compose가 이미 설치되어 있습니다." fi } # Kind 클러스터 설정 파일 생성 create_kind_cluster_config() { echo "Kind 클러스터 설정 파일을 생성합니다..." cat &lt;&lt;EOF > kind-cluster-config.yaml kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 nodes: - role: control-plane - role: worker - role: worker - role: worker EOF echo "Kind 클러스터 설정 파일 생성 완료." } # Kind 클러스터 생성 create_kind_cluster() { echo "Kind 클러스터를 생성합니다..." kind create cluster --config kind-cluster-config.yaml echo "Kind 클러스터 생성 완료." } # 주요 함수 호출 install_utilities create_kind_cluster_config create_kind_cluster # 클러스터 정보 출력 kubectl get nodes echo "3개의 worker 노드를 포함한 Kind 클러스터가 성공적으로 생성되었습니다." 스크립트 설명 필수 유틸리티 설치: Docker, kind, kubectl, docker-compose가 설치되지 않은 경우 자동으로 다운로드하고 설치합니다. 클러스터 구성 파일: kind-cluster-config.yaml 파일을 생성하며, 하나의 control-plane 노드와 3개의 worker 노드를 포함합니다. 클러스터 생성: kind를 이용해 클러스터를 생성합니다. kubectl로 클러스터 상태 확인: kubectl 명령어를 통해 생성된 클러스터의 노드 상태를 확인할 수 있습니다. 사용 방법: 스크립트를 파일로 저장 (예: setup_kind_cluster.sh). 파일에 실행 권한을 부여: chmod +x setup_kind_cluster.sh 스크립트 실행: ./setup_kind_cluster.sh 클러스터가 성공적으로 생성되면 kubectl get nodes 명령을 통해 노드 상태를 확인할 수 있습니다. 이 스크립트는 KinD를 활용하여 간단하게 3개의 worker 노드가 있는 클러스터를 설정할 수 있도록 도와줍니다.
...</p></div><footer class=entry-footer><span title='2025-02-14 00:00:00 +0000 UTC'>2월 14, 2025</span></footer><a class=entry-link aria-label="post link to KinD for k8s" href=https://jongyongpark.github.io/posts/k8s_docker/k8s-kind/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jongyongpark.github.io/posts/page/3/>«&nbsp;이전 페이지&nbsp;
</a><a class=next href=https://jongyongpark.github.io/posts/page/5/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://jongyongpark.github.io/>RyanLabs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>